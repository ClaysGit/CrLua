-------------------------------------------------------------------------------
--- Lua utility functions
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.Util'

local CrLua = CrLua or {}
CrLua.Util = assert(not CrLua.Util) and {}

-------------------------------------------------------------------------------
--- Make a table read-only.
-- Note that the table cannot contain <nil> values, use false instead.
-- @param tableName string : table name.
-- @param table : table.
-- @return table : the original table, made read-only.
-------------------------------------------------------------------------------
function CrLua.Util.readOnly(tableName, table)
    assert(type(tableName) == 'string' and type(table) == 'table')

    setmetatable(table, {
        __newindex = function(_, key, value)
            error(TAG .. ': write "' .. tostring(key or '<nil>') .. '" to read-only table "' .. tableName .. '"')
        end,
    })
    return table
end

function CrLua.Util._testReadOnly()
    local readOnlyTable = CrLua.Util.readOnly('myTable', { 'foo', 'bar' })

    -- Access.
    assert(readOnlyTable[1] == 'foo' and readOnlyTable[2] == 'bar')

    -- Can read missing key.
    assert(not readOnlyTable.missingKey)

    -- Cannot write missing key.
    if pcall(function() readOnlyTable.missingKey = 1 end) then
        error('wrote to a missing key')
    end
end

-------------------------------------------------------------------------------
--- Make a table immutable, also report errors when accessing missing keys.
-- Note that the table cannot contain <nil> values, use false instead.
-- @param tableName string : table name.
-- @param table : table.
-- @return table : the original table, made read-only.
-------------------------------------------------------------------------------
function CrLua.Util.lock(tableName, table, exceptions)
    assert(type(tableName) == 'string' and type(table) == 'table')

    local exceptionsSet = {}
    for _, exception in ipairs(exceptions or {}) do
        exceptionsSet[exception] = true
    end

    -- Move contents to a hidden table.
    local hidden = {}
    for k, v in pairs(table) do
        hidden[k] = v
        table[k] = nil
    end
    setmetatable(table, {
        __index = function(_, key)
            local result = hidden[key]
            if not result then
                error(TAG .. ': read missing key "' .. (key or '<nil>') .. '" in locked table "' .. tableName .. '"')
            end
            return result
        end,
        __newindex = function(_, key, value)
            if exceptionsSet[key] then
                hidden[key] = value
            else
                error(TAG .. ': write key "' .. (key or '<nil>') .. '" to locked table "' .. tableName .. '"')
            end
        end,
        __pairs = function(_)
            local function iter(_, k)
                local k, v = next(hidden, k)
                return v and k, v
            end
            return iter, table, nil
        end,
        __ipairs = function(_)
            local function iter(_, i)
                local v = hidden[i + 1]
                return v and i + 1, v
            end
            return iter, table, 0
        end
    })
    return table
end

function CrLua.Util._testLock()
    local lockedTable = CrLua.Util.lock('myTable', { 'foo', 'bar' }, { 2 })

    -- Access.
    assert(lockedTable[1] == 'foo' and lockedTable[2] == 'bar')

    -- Cannot read missing key.
    if pcall(function() local _ = lockedTable.missingKey end) then
        error('read a missing key')
    end

    -- Cannot write locked key.
    if pcall(function() lockedTable[1] = 1 end) then
        error('wrote a locked key')
    end

    -- CAN WRITE exceptions-list key.
    lockedTable[2] = 'baz'
    assert(lockedTable[2] == 'baz')

    -- Cannot write missing key.
    if pcall(function() lockedTable.missingKey = 1 end) then
        error('wrote a missing key')
    end

    local count = 0
    for k, v in pairs(lockedTable) do
        assert((k == 1 and v == 'foo') or (k == 2 and v == 'baz'))
        count = count + 1
    end
    assert(count == 2)

    local count = 0
    for i, v in ipairs(lockedTable) do
        assert((i == 1 and v == 'foo') or (i == 2 and v == 'baz'))
        count = count + 1
    end
    assert(count == 2)
end

-------------------------------------------------------------------------------
--- Compute the distance between two {x,y,z} vectors.
-- @param a table : {x,y,z} keys.
-- @param b table : {x,y,z} keys.
-- @return distance squared (sqrt it if need exact, sq is fine for sorting).
-------------------------------------------------------------------------------
function CrLua.Util.distanceSq(a, b)
    local dx = a.x - b.x
    local dy = a.y - b.y
    local dz = a.z - b.z
    return (dx * dx) + (dy * dy) + (dz * dz)
end

function CrLua.Util._testDistanceSq()
    local a = { x = 0, y = 0, z = 0 }
    local b = { x = 1, y = 2, z = 3 }
    local distanceSq = CrLua.Util.distanceSq(a, b)
    assert(distanceSq == 14)
end

-------------------------------------------------------------------------------
--- Find the minimum value in a table, with optional function for value.
-- Function can return false/nil to reject value from consideration.
-- @param table : table with arbitrary keys (may be a list).
-- @param optional minFunction : call for each value to minimize.
-- @return ? : table value with the min value.
-------------------------------------------------------------------------------
function CrLua.Util.min(table, minFunction)
    assert(type(table) == 'table' and ((not minFunction) or type(minFunction) == 'function'))

    local minScore = nil
    local minKey, minValue = nil, nil
    for k, v in pairs(table) do
        local score = (minFunction and minFunction(v)) or tonumber(v)
        if score and (not minScore or score < minScore) then
            minScore = score
            minKey = k
            minValue = v
        end
    end
    return minKey, minValue
end

function CrLua.Util._testMin()
    local list = { 2, 1, 3, 5, 4 }
    local minFunction = function(v)
        return v
    end
    local k1, min1 = CrLua.Util.min(list)
    local k2, min2 = CrLua.Util.min(list, minFunction)
    assert(k1 == k2 and k1 == 2, 'k=' .. (k1 or '<nil>'))
    assert(min1 == min2 and min1 == 1)
end

-------------------------------------------------------------------------------
--- Find the maximum value in a table, with optional function for value.
-- Function can return false/nil to reject value from consideration.
-- @param table : table with arbitrary keys (may be a list).
-- @param optional maxFunction : call for each value to maximize.
-- @return ? : table value with the max value.
-------------------------------------------------------------------------------
function CrLua.Util.max(table, maxFunction)
    assert(type(table) == 'table' and ((not maxFunction) or type(maxFunction) == 'function'))

    local maxScore = nil
    local maxKey, maxValue = nil, nil
    for k, v in pairs(table) do
        local score = (maxFunction and maxFunction(v)) or tonumber(v)
        if score and (not maxScore or score > maxScore) then
            maxScore = score
            maxKey = k
            maxValue = v
        end
    end
    return maxKey, maxValue
end

function CrLua.Util._testMax()
    local list = { 2, 1, 3, 5, 4 }
    local maxFunction = function(v)
        return v
    end
    local k1, max1 = CrLua.Util.max(list)
    local k2, max2 = CrLua.Util.max(list, maxFunction)
    assert(k1 == k2 and k1 == 4)
    assert(max1 == max2 and max1 == 5)
end

CrLua.Util.lock(TAG, CrLua.Util)

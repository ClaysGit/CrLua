-------------------------------------------------------------------------------
--- Manage "zones" in a TTS/TI4 table, using the command and faction sheets as
-- a guide for where a "zone" is.  For standard 6 or 8 player tables uses
-- hard-coded zone polygons.
--
-- Each zone has:
-- - color (string) : from "Command Sheet (COLOR)".
-- - playerColor (string) : closest faction sheet to each seated player get this.
-- - faction (string) : from "FACTION Sheet" (compare lower case for "of" vs "Of").
-- - tokenFaction (string) : "TOKEN_FACTION Command Token", "TOKEN_FACTION Owner Token"
-- - boundingBox {min={1,2},max={1,2}} : XZ bounding box.
-- - polygon (table) : list of XZ points in clockwise winding order.
-- - y (number) : Y value for table.
--
-- Why color vs playerColor?  These will normally agree, but when a player
-- leaves/disconnects there may be a zone with a faction sheet but no player.
-- Moreover, TTS does not stop players from doing wacky thing like changing a
-- hand color then changing player color while there is still a "Command Sheet
-- (COLOR)" for the wrong color.  In this case, compute both, let someone else
-- decide how to use.
--
-- The boundingBox is the box surrounding the faction sheet + command sheet,
-- really only should be used for a non-standard table when a hard-coded
-- polygon is not available.
--
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.TI4.Zone'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TI4 = CrLua.TI4 or {}
CrLua.TI4.Zone = assert(not CrLua.TI4.Zone) and {
    _require = { 'LockTable', 'Polygon', 'Util', },
    _allowMissingKeys = { 'FACTION_NAMES', 'POLYGONS_6P', 'POLYGONS_8P' },

    _data = { zones = {} },

    -- Faction sheets are named "FACTION Sheet", but there are other objects
    -- out there like "Reference Sheet" that might get accidentally counted
    -- using a generic pattern match.  Instead of blacklisting bad objects,
    -- whitelist good ones.  Only consider faction sheets for:
    FACTION_NAMES = {
        'The Arborec',
        'The Barony of Letnev',
        'The Clan of Saar',
        'The Embers of Muaat',
        'The Emirates of Hacan',
        'The Federation of Sol',
        'The Ghosts of Creuss',
        'The L1Z1X Mindnet',
        'The Mentak Coalition',
        'The Naalu Collective',
        'The Nekro Virus',
        "The Sardakk N'orr",
        'The Universities of Jol-Nar',
        'The Winnu',
        'The Xxcha Kingdom',
        'The Yin Brotherhood',
        'The Yssaril Tribes'
    },

    -- Player zones for Raptor1210's "Twilight Imperium IV".
    POLYGONS_6P = {
        Yellow = {{ 21, -50 }, { 21, -6 }, { 51, -6 }, { 51, -50 }},
        Red = {{ -21, -50 }, { -21, -6 }, { -1.5, -21 }, { 1.5, -21 }, { 21, -6 }, { 21, -50 }},
        Green = {{ -51, -50 }, { -51, -6 }, { -21, -6 }, { -21, -50 }},
        Purple = {{ 21, 6 }, { 21, 49 }, { 51, 49 }, { 51, 6 }},
        Blue = {{ -21, 6 }, { -21, 49 }, { 21, 49 }, { 21, 6 }, { 1.5, 21 }, { -1.5, 21 }},
        White = {{ -51, 6 }, { -51, 49 }, { -21, 49 }, { -21, 6 }},
        --_table = {{ -48, -28 }, { -48, 28 }, { 48, 28 }, { 48, -28 }},
    },
    -- Player zones for the_mantis's "TI4 8 Player Madness".
    POLYGONS_8P = {
        Pink = {{40.5, -100}, {40.5, -15}, {78, -15}, {78, -100}},
        White = {{0, -100}, {0, -15}, {40.5, -15}, {40.5, -100}},
        Red = {{-40.5, -100}, {-40.5, -15}, {0, -15}, {0, -100}},
        Orange = {{-78, -100}, {-78, -15}, {-40.5, -15}, {-40.5, -100}},
        Yellow = {{-78, 15}, {-78, 100}, {-40.5, 100}, {-40.5, 15}},
        Green = {{-40.5, 15}, {-40.5, 100}, {0, 100}, {0, 15}},
        Blue = {{0, 15}, {0, 100}, {40.5, 100}, {40.5, 15}},
        Purple = {{40.5, 15}, {40.5, 100}, {78, 100}, {78, 15}},
    }
}

function CrLua.TI4.Zone.zones()
    return CrLua.TI4.Zone._data.zones
end

function CrLua.TI4.Zone.closest(position)
    assert(type(position) == 'table' and position.x)
    local function distance(zone)
        local bb = zone.bb
        local d1 = CrUtil.distanceSq(position, { x = bb.min.x, y = 1, z = bb.min.z })
        local d2 = CrUtil.distanceSq(position, { x = bb.min.x, y = 1, z = bb.max.z })
        local d3 = CrUtil.distanceSq(position, { x = bb.max.x, y = 1, z = bb.max.z })
        local d4 = CrUtil.distanceSq(position, { x = bb.max.x, y = 1, z = bb.min.z })
        return math.min(d1, d2, d3, d4)
    end
    local _, zone = CrUtil.min(CrLua.TI4.Zone._data.zones, distance)
    return zone
end

function CrLua.TI4.Zone.fromColor(color)
    assert(type(color) == 'string')
    for _, zone in ipairs(CrLua.TI4.Zone._data.zones) do
        if zone.color == color then
            return zone
        end
    end
end

function CrLua.TI4.Zone.fromFaction(faction)
    assert(type(faction) == 'string')
    local faction = string.lower(faction)
    for _, zone in ipairs(CrLua.TI4.Zone._data.zones) do
        if string.lower(zone.faction) == faction then
            return zone
        end
    end
end

function CrLua.TI4.Zone.inside(zone, position)
    assert(type(zone) == 'table' and zone.faction and type(position) == 'table' and position.x)
    if zone.polygon then
        local pointXZ = { position.x, position.z }
        return CrLua.Polygon.inside(zone.polygon, pointXZ)
    end
end

function CrLua.TI4.Zone.vectorLines(zone, override)
    assert(type(zone) == 'table' and zone.faction and type(override) == 'table')
    local result = {
        points = {},
        color = zone.color,
        thickness = override.thickness or 0.2,
        rotation = { x = 0, y = 0, z = 0 },
        loop = true,
        square = false
    }
    if zone.polygon then
        local polygon = zone.polygon
        local inset = CrLua.Polygon.inset(polygon, result.thickness / 2.0)
        result.points = CrLua.Polygon.toXYZ(inset, zone.y)
    end
    return result
end

function CrLua.TI4.Zone.allVectorLines(override)
    assert(type(override) == 'table')
    local result = {}
    for _, zone in ipairs(CrLua.TI4.Zone._data.zones) do
        table.insert(result, CrLua.TI4.Zone.vectorLines(zone, override))
    end
    return result
end

function CrLua.TI4.Zone.boundingBoxVectorLines(zone, override)
    assert(type(zone) == 'table' and zone.faction and type(override) == 'table')
    local result = {
        points = {},
        color = zone.color,
        thickness = override.thickness or 0.2,
        rotation = { x = 0, y = 0, z = 0 },
        loop = true,
        square = false
    }
    if zone.boundingBox then
        local polygon = CrLua.Polygon.boundingBoxCorners(zone.boundingBox)
        local inset = CrLua.Polygon.inset(polygon, result.thickness / 2.0)
        result.points = CrLua.Polygon.toXYZ(inset, zone.y)
    end
    return result
end

function CrLua.TI4.Zone.allBoundingBoxVectorLines(override)
    assert(type(override) == 'table')
    local result = {}
    for _, zone in ipairs(CrLua.TI4.Zone._data.zones) do
        table.insert(result, CrLua.TI4.Zone.boundingBoxVectorLines(zone, override))
    end
    return result
end

-------------------------------------------------------------------------------
--- Fill in the zones' runtime fields (faction, color, etc).
-------------------------------------------------------------------------------
function CrLua.TI4.Zone.update()
    -- Suppress out for aggressive updates.
    local frameCount = Time.frame_count
    if CrLua.TI4.Zone._data.lastUpdateFrameCount == frameCount then
        return
    end
    CrLua.TI4.Zone._data.lastUpdateFrameCount = frameCount
    CrLua.TI4.Zone._data.zones = {}

    -- Find command sheets (indexed by color), faction sheets (indexed by
    -- faction name), and command token bags (indexed by "token faction" name,
    -- which may differ slightly from the faction sheet faction name).
    local colorToCommandSheet = {}
    local factionToFactionSheet = {}
    local tokenFactionToCommandCounterBag = {}
    local numCommandSheets = 0
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()

        -- Look for 'Command Sheet (COLOR)' and 'FACTION Sheet' objects.
        -- First use the cheap string.find to test if 'Sheet' is in the name.
        -- Once we have a candidate, do more expensive pattern matching.
        if string.find(name, ' Sheet') then
            local pos = object.getPosition()

            -- "Command Sheet (COLOR)"
            local color = string.match(name, '^Command Sheet %((%a+)%)$')
            if color then
                colorToCommandSheet[color] = object
                numCommandSheets = numCommandSheets + 1
            end

            -- "FACTION Sheet"
            local faction = string.match(name, '^(.+) Sheet$')
            if faction then
                for _, entry in ipairs(CrLua.TI4.Zone.FACTION_NAMES) do
                    if string.lower(faction) == string.lower(entry) then
                        factionToFactionSheet[faction] = object
                        break
                    end
                end
            end
        end

        -- "TOKEN_FACTION Command Tokens Bag"
        if string.find(name, ' Command Tokens Bag') then
            local tokenFaction, type = string.match(name, '^(.*) (%u%a+) Tokens Bag$')
            if type == 'Command' then
                tokenFactionToCommandCounterBag[tokenFaction] = object
            end
        end
    end

    -- Map faction to closest command sheet and command token bags.  Note this
    -- is from faction sheet to command sheet, not the other way around.  This
    -- way ignores empty seats with a command sheet but no faction sheet.
    local factionToColor = {}
    local factionToCommandSheet = {}
    local factionToTokenFaction = {}
    for faction, factionSheet in pairs(factionToFactionSheet) do
        local function distance(object)
            return CrLua.Util.distanceSq(factionSheet.getPosition(), object.getPosition())
        end

        local color, commandSheet = CrLua.Util.min(colorToCommandSheet, distance)
        factionToColor[faction] = assert(color)
        factionToCommandSheet[faction] = assert(commandSheet)

        local tokenFaction, _ = CrLua.Util.min(tokenFactionToCommandCounterBag, distance)
        factionToTokenFaction[faction] = assert(tokenFaction)
    end

    -- Find the closest faction for each seated player.  If a player disconnects
    -- (or some other non-typical event/set) there may be faction sheets on the
    -- table without any player seated near them.
    local factionList = CrLua.List.fromKeys(factionToFactionSheet)
    local factionToSeatedPlayerColor = {}
    for _, color in ipairs(getSeatedPlayers()) do
        local function factionDistance(faction)
            local factionPosition = factionToFactionSheet[faction].getPosition()
            local player = Player[color]
            local best = false
            for i = 1, player.getHandCount() do
                local handPosition = player.getHandTransform(i).position
                local distanceSq = CrLua.Util.distanceSq(factionPosition, handPosition)
                best = not best and distanceSq or math.min(best, distanceSq)
            end
            return best
        end
        local _, faction = CrLua.Util.min(factionList, factionDistance)
        factionToSeatedPlayerColor[faction] = color
    end

    -- Generate a bounding box for the faction + command sheet pair.  Store the
    -- bounding box min/max points as { 1=x, 2=z } lists.
    for faction, factionSheet in pairs(factionToFactionSheet) do
        local p = factionSheet.getPosition()
        local bb = { min = { p.x, p.z }, max = { p.x, p.z } }

        local bounds = factionSheet.getBounds()
        bb.min[1] = math.min(bb.min[1], bounds.center.x - (bounds.size.x / 2))
        bb.min[2] = math.min(bb.min[2], bounds.center.z - (bounds.size.z / 2))
        bb.max[1] = math.max(bb.max[1], bounds.center.x + (bounds.size.x / 2))
        bb.max[2] = math.max(bb.max[2], bounds.center.z + (bounds.size.z / 2))

        local commandSheet = factionToCommandSheet[faction]
        local bounds = commandSheet.getBounds()
        bb.min[1] = math.min(bb.min[1], bounds.center.x - (bounds.size.x / 2))
        bb.min[2] = math.min(bb.min[2], bounds.center.z - (bounds.size.z / 2))
        bb.max[1] = math.max(bb.max[1], bounds.center.x + (bounds.size.x / 2))
        bb.max[2] = math.max(bb.max[2], bounds.center.z + (bounds.size.z / 2))

        -- Get 'official' zone polygon, hard-coded from 6 and 8 player tables.
        local polygons = false
        local y = false
        if numCommandSheets == 6 then
            polygons = CrLua.TI4.Zone.POLYGONS_6P
            y = 1
        elseif numCommandSheets == 8 then
            polygons = CrLua.TI4.Zone.POLYGONS_8P
            y = 5
        end
        local polygon = false
        if polygons then
            local position = factionSheet.getPosition()
            local pointXZ = { position.x, position.z }
            local color = factionToColor[faction]

            -- First check the default zone for this color.
            polygon = polygons[color] or false
            if polygon and not CrLua.Polygon.inside(polygon, pointXZ) then
                polygon = false
            end

            -- If no default zone or does not match, scan for polygon.
            if not polygon then
                for candidateColor, candidate in pairs(polygons) do
                    if color ~= candidateColor and CrLua.Polygon.inside(candidate, pointXZ) then
                        polygon = candidate
                        break
                    end
                end
            end

        end

        local color = assert(factionToColor[faction])
        local tableName = TAG .. '._data.zones[color=' .. color .. ']'
        table.insert(CrLua.TI4.Zone._data.zones, CrLua.LockTable.readOnlyRequireKey(tableName, {
            color = assert(color),  -- command sheet color
            playerColor = factionToSeatedPlayerColor[faction] or false,
            faction = assert(faction),
            tokenFaction = assert(factionToTokenFaction[faction]),
            boundingBox = assert(bb),
            polygon = polygon or false,
            y = y
        }))
    end
end

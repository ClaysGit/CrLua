-------------------------------------------------------------------------------
--- System utils for Darth Batman and Raptor1210's "Twilight Imperium IV" TTS mod.
-- Inspired by Garnet Bear's Tile Rollers
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.TI4.System'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TI4 = CrLua.TI4 or {}
CrLua.TI4.System = assert(not CrLua.TI4.System) and {
    _require = {},
    _allowMissingKeys = { 'SYSTEMS' },

    DEFAULT_LINE_THICKNESS = 0.2,
    LOCAL_TO_WORLD_TILE_RADIUS = 2.26,
    LOCAL_TO_WORLD_PLANET_RADIUS = 1,
    LOCAL_TO_WORLD_MECATOL_RADIUS = 1.9,
    LOCAL_TO_WORLD_Y = 0.318
}

CrLua.TI4.System.SYSTEMS = {
    ['86e50a'] = { tile = 1, planets = { 'Jord' } },
    ['ac3193'] = { tile = 2, planets = { 'Moll Primus' } },
    ['db8aac'] = { tile = 3, planets = { 'Darien' } },
    ['da7879'] = { tile = 4, planets = { 'Muaat' } },
    ['fc6f7a'] = { tile = 5, planets = { 'Nestphar' } },
    ['420355'] = { tile = 6, planets = { '[0.0.0]' } },
    ['087347'] = { tile = 7, planets = { 'Winnu' } },
    ['ea676a'] = { tile = 8, planets = { 'Mordai II' } },
    ['0122f9'] = { tile = 9, planets = { 'Maaluuk', 'Druaa' } },
    ['e001b4'] = { tile = 10, planets = { 'Arc Prime', 'Wren Terra' } },
    ['d39876'] = { tile = 11, planets = { 'Lisis II', 'Ragh' } },
    ['11598c'] = { tile = 12, planets = { 'Nar', 'Jol' } },
    ['6176bf'] = { tile = 13, planets = { "Tren'lak", 'Quinarra' } },
    ['c2509e'] = { tile = 14, planets = { 'Archon Ren', 'Archon Tau' } },
    ['9c373a'] = { tile = 15, planets = { 'Retillion', 'Shalloq' } },
    ['6a4247'] = { tile = 16, planets = { 'Hercant', 'Arretze', 'Kamdorn' } },
    ['c56a8a'] = { tile = 17, wormholes = { 'delta' } },
    ['04df02'] = { tile = 18, planets = { 'Mecatol Rex' } },
    ['4216fd'] = { tile = 19, planets = { 'Wellon' } },
    ['bc4bcc'] = { tile = 20, planets = { 'Vefut II' } },
    ['f2798a'] = { tile = 21, planets = { 'Thibah' } },
    ['0ea77f'] = { tile = 22, planets = { "Tar'mann" } },
    ['7975f7'] = { tile = 23, planets = { 'Saudor' } },
    ['48cc9f'] = { tile = 24, planets = { 'Mehar Xull' } },
    ['71e1bf'] = { tile = 25, planets = { 'Quann' }, wormholes = { 'beta' } },
    ['f11ef5'] = { tile = 26, planets = { 'Lodor' }, wormholes = { 'alpha' } },
    ['fc239f'] = { tile = 27, planets = { 'New Albion', 'Starpoint' } },
    ['f8caf6'] = { tile = 28, planets = { "Tequ'ran", 'Torkan' } },
    ['0ac98b'] = { tile = 29, planets = { "Qucen'n", 'Rarron' } },
    ['aaae9f'] = { tile = 30, planets = { 'Mellon', 'Zohbat' } },
    ['d5ed63'] = { tile = 31, planets = { 'Lazar', 'Sakulag' } },
    ['48ac87'] = { tile = 32, planets = { 'Dal Bootha', 'Xxehan' } },
    ['87a5a2'] = { tile = 33, planets = { 'Corneeq', 'Resculon' } },
    ['eb99c0'] = { tile = 34, planets = { 'Centauri', 'Gral' } },
    ['dd2ca7'] = { tile = 35, planets = { 'Bereg', 'Lirta IV' } },
    ['a284d1'] = { tile = 36, planets = { 'Arnor', 'Lor' } },
    ['e0ff33'] = { tile = 37, planets = { 'Arinam', 'Meer' } },
    ['b958aa'] = { tile = 38, planets = { 'Abyz', 'Fria' } },
    ['0378a4'] = { tile = 39, wormholes = { 'alpha' } },
    ['ccd7ac'] = { tile = 40, wormholes = { 'beta' } },
    ['47a55d'] = { tile = 41, anomalies = { 'gravity rift' } },
    ['d13aa2'] = { tile = 42, anomalies = { 'nebula'} },
    ['dca098'] = { tile = 43, anomalies = { 'supernova' } },
    ['cd58c7'] = { tile = 44, anomalies = { 'asteroid field' } },
    ['7db8d8'] = { tile = 45, anomalies = { 'asteroid field' } },
    ['9dce5a'] = { tile = 46 },
    ['437f06'] = { tile = 47 },
    ['ff8f60'] = { tile = 48 },
    ['0216be'] = { tile = 49 },
    ['97ee53'] = { tile = 50 },
    ['f38182'] = { tile = 51, planets = { 'Creuss' }, wormholes = { 'delta' } }
}

-------------------------------------------------------------------------------
--- Get all systems.
-- @return table : list of CrLua.TI4.System.SYSTEMS values, with new object field.
-------------------------------------------------------------------------------
function CrLua.TI4.System.getAllSystems()
    local result = {}
    local systems = CrLua.TI4.System.SYSTEMS
    for _, object in ipairs(getAllObjects()) do
        local system = systems[object.getGUID()]
        if system then
            rawset(system, 'object', object)  -- rawset in case locked
            table.insert(result, system)
        end
    end
    return result
end

-------------------------------------------------------------------------------
--- Find system at position.
-- @param position table : {x,y,z} position in world coordinates.
-- @return system table : CrLua.TI4.System.SYSTEMS value with new object field.
-------------------------------------------------------------------------------
function CrLua.TI4.System.fromPosition(position)
    assert(type(position) == 'table' and position.x)
    local hits = Physics.cast({
        origin = { x = position.x, y = position.y - 1, z = position.z },
        direction = { x = 0, y = 1, z = 0 },
        type = 1, -- ray
        max_distance = 2,
    })
    local systems = CrLua.TI4.System.SYSTEMS
    for _, hit in ipairs(hits) do
        local object = hit.hit_object
        local system = systems[object.getGUID()]
        if system then
            rawset(system, 'object', object)  -- rawset in case locked
            return system
        end
    end
end

-------------------------------------------------------------------------------
-- Get planet at position.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates.
-- @param exact boolean : if true, position must be on planet (vs closest planet).
-- @return planet string : or nil if no planet in that zone.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetFromPosition(system, position, exact)
    assert(type(system) == 'table' and system.tile and type(position) == 'table' and position.x)
    local i = CrLua.TI4.System._getZone(system, position)
    local planet = system.planets and #system.planets >= i and system.planets[i]
    if planet and exact then
        local planetPosition = CrLua.TI4.System.planetToPosition(system, planet)
        local local1 = system.object.positionToLocal(position)
        local local2 = system.object.positionToLocal(planetPosition)
        local dx = local1.x - local2.x
        local dz = local1.z - local2.z
        local distance = math.sqrt((dx * dx) + (dz * dz))
        local planetRadius = system.tile == 18 and CrLua.TI4.System.LOCAL_TO_WORLD_MECATOL_RADIUS or CrLua.TI4.System.LOCAL_TO_WORLD_PLANET_RADIUS
        if distance > planetRadius then
            planet = nil
        end
    end
    return planet
end

-------------------------------------------------------------------------------
-- Get planet position.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param planet string : planet name.
-- @return table : {x,y,z} table.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetToPosition(system, planet)
    assert(type(system) == 'table' and system.tile and type(planet) == 'string')

    local planetIndex = false
    for i, entry in ipairs(system.planets or {}) do
        if entry == planet then
            planetIndex = i
            break
        end
    end
    assert(planetIndex)

    local distanceToPlanet = 0
    local bearingToPlanet = 0

    local zoneBoundaries = CrLua.TI4.System._getZoneBorders(system)
    if #zoneBoundaries > 2 then
        local a = zoneBoundaries[planetIndex]
        local b = zoneBoundaries[planetIndex + 1]
        if a < b then
            bearingToPlanet = (a + b) / 2
        else
            bearingToPlanet = ((a + 360 + b) / 2) % 360
        end
        distanceToPlanet = CrLua.TI4.System.LOCAL_TO_WORLD_TILE_RADIUS / 2.0
    end

    return CrLua.TI4.System._bearingToPosition(system, bearingToPlanet, distanceToPlanet)
end

-------------------------------------------------------------------------------
--- Get vector lines for planet.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param planet string : planet name.
-- @param override table : vector lines parameters such as thickness, color.
-- @return table : vector lines entry wrapping planet.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetVectorLine(system, planet, override)
    assert(type(system) == 'table' and system.tile and type(planet) == 'string' and type(override) == 'table')
    assert(system.object)

    -- Do not specify system to get a local position.
    local planetOriginWorld = CrLua.TI4.System.planetToPosition(system, planet)
    local planetOrigin = system.object.positionToLocal(planetOriginWorld)
    local planetRadius = system.tile == 18 and CrLua.TI4.System.LOCAL_TO_WORLD_MECATOL_RADIUS or CrLua.TI4.System.LOCAL_TO_WORLD_PLANET_RADIUS

    local points = {}
    for i = 1, 16 do
        local theta = math.pi * 2.0 * i / 16.0
        local position = {
            x = planetOrigin.x + math.cos(theta) * planetRadius,
            y = CrLua.TI4.System.LOCAL_TO_WORLD_Y,
            z = planetOrigin.z + math.sin(theta) * planetRadius
        }
        table.insert(points, system.object.positionToWorld(position))
    end

    return {
        points = points,
        color = override.color or 'Red',
        thickness = override.thickness or CrLua.TI4.System.DEFAULT_LINE_THICKNESS,
        rotation = { x = 0, y = 0, z = 0 },
        loop = true,
        square = true
    }
end

-------------------------------------------------------------------------------
--- Get vector lines separating all zones.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param override table : vector lines parameters such as thickness, color.
-- @return table : vector lines entry.
-------------------------------------------------------------------------------
function CrLua.TI4.System.vectorLine(system, override)
    assert(type(system) == 'table' and system.tile and type(override) == 'table')
    assert(system.object)

    local zoneBorders = CrLua.TI4.System._getZoneBorders(system)
    if #zoneBorders <= 2 then
        return {}
    end

    local y = CrLua.TI4.System.LOCAL_TO_WORLD_Y
    local center = system.object.positionToWorld({x = 0, y = y, z = 0})
    local r = CrLua.TI4.System.LOCAL_TO_WORLD_TILE_RADIUS
    local outer = {}
    for i = 1, #zoneBorders - 1 do
        local bearing = zoneBorders[i]
        table.insert(outer, CrLua.TI4.System._bearingToPosition(system, bearing, r))
    end

    local points = false
    if #outer < 2 then
        points = {}
    elseif #outer == 2 then
        points = { outer[1], center, outer[2] }
    elseif #outer == 3 then
        points = { outer[1], center, outer[2], center, outer[3] }
    else
        error(TAG .. ': too many zones')
    end

    return {
        points = points,
        color = override.color or 'Red',
        thickness = override.thickness or CrLua.TI4.System.DEFAULT_LINE_THICKNESS,
        rotation = { x = 0, y = 0, z = 0 },
        loop = false,
        square = true
    }
end

-------------------------------------------------------------------------------
--- Get bearings separating zones.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @return table : list of bearings, last should equal first (wrapped).
-------------------------------------------------------------------------------
function CrLua.TI4.System._getZoneBorders(system)
    assert(type(system) == 'table' and system.tile)
    if not system._zoneBorders then
        local numZones = (system.planets and #system.planets or 0) + (system.wormholes and #system.wormholes or 0)

        -- The local coordinate space for a tile shows {x=1,z=1} to be lower left.
        -- Set zone borders to track planets starting left going clockwise.
        if numZones <= 1 then
            rawset(system, '_zoneBorders', { 0, 360 })
        elseif numZones == 2 then
            rawset(system, '_zoneBorders', { 240, 60, 240 })
        elseif numZones == 3 then
            rawset(system, '_zoneBorders', { 210, 330, 90, 210 })
        else
            error(TAG .. ': too many zones (' .. numZones .. ')')
        end

    end
    return assert(system._zoneBorders)
end

-------------------------------------------------------------------------------
--- Which zone contains position?
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates.
-- @return index number : zone index, planets first then wormholes (if both).
-------------------------------------------------------------------------------
function CrLua.TI4.System._getZone(system, position)
    assert(type(system) == 'table' and system.tile and type(position) == 'table' and position.x)
    local bearing = CrLua.TI4.System._positionToBearing(system, position)
    local zoneBorders = CrLua.TI4.System._getZoneBorders(system)
    for i = 1, #zoneBorders - 1 do
        local a = zoneBorders[i]
        local b = zoneBorders[i + 1]
        if a < b then
            if bearing >= a and bearing <= b then
                return i
            end
        else
            -- Zone wraps across zero.
            if bearing >= a or bearing <= b then
                return i
            end
        end
    end
    error('no zone')
end

-------------------------------------------------------------------------------
--- Compute the bearing from the system center to the world position.
-- Bearing is the angle, measured clockwise about the Y axis from the
-- "north" direction.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates, unless no system then local.
-- @return bearing number : 0 <= bearing < 360.
-------------------------------------------------------------------------------
function CrLua.TI4.System._positionToBearing(system, position)
    assert(type(position) == 'table' and position.x)
    if system then
        assert(type(system) == 'table' and system.tile and system.object)
        position = system.object.positionToLocal(position)
    end

    -- Compute bearing in radians.
    local bearing = math.atan2(position.z, -position.x) + (math.pi / 2)

    -- Convert to degrees between 0 and 360.
    bearing = (bearing * 180.0 / math.pi) % 360.0
    if bearing < 0 then
        bearing = bearing + 360.0
    end

    assert(0 <= bearing and bearing < 360)
    return bearing
end

function CrLua.TI4.System._testPositionToBearing()
    local positionsToBearings = {
        [{ x = 0, z = -1 }] = 0,
        [{ x = -1, z = -1 }] = 45,
        [{ x = -1, z = 0 }] = 90,
        [{ x = 0, z = 1 }] = 180,
        [{ x = 1, z = 0 }] = 270
    }
    for position, expected in pairs(positionsToBearings) do
        local observed = CrLua.TI4.System._positionToBearing(false, position)
        assert(expected == observed, expected .. ' saw ' .. observed)
    end
end

-------------------------------------------------------------------------------
--- Compute the world position at the given bearing (relative to system tile
-- orientation) at distance r from the system center.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param bearing number : angle in degrees, clockwise from "north".
-- @param r number : distance from center of tile to result point (in local space!).
-- @return position table : position in world coordinates (or local if no system).
-------------------------------------------------------------------------------
function CrLua.TI4.System._bearingToPosition(system, bearing, r)
    assert(type(bearing) == 'number' and 0 <= bearing and bearing < 360 and type(r) == 'number')
    local bearing = -bearing * math.pi / 180.0
    local result = { x = r * math.sin(bearing), y = 0, z = -r * math.cos(bearing) }
    if system then
        assert(type(system) == 'table' and system.tile and system.object)
        result.y = CrLua.TI4.System.LOCAL_TO_WORLD_Y
        assert(system.object)
        result = system.object.positionToWorld(result)
    end
    return result
end

function CrLua.TI4.System._testBearingToPosition()
    local positionsToBearings = {
        [{ x = 0, z = -1 }] = 0,
        [{ x = -1, z = 0 }] = 90,
        [{ x = 0, z = 1 }] = 180,
        [{ x = 1, z = 0 }] = 270
    }
    for position, bearing in pairs(positionsToBearings) do
        local observed = CrLua.TI4.System._bearingToPosition(false, bearing, 1)
        assert(math.abs(observed.x - position.x) < 0.001, 'x ' .. observed.x .. ' vs ' .. position.x)
        assert(math.abs(observed.z - position.z) < 0.001, 'z ' .. observed.z .. ' vs ' .. position.z)
    end
end

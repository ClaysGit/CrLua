-------------------------------------------------------------------------------
--- System utils for Darth Batman and Raptor1210's "Twilight Imperium IV" TTS mod.
-- Inspired by Garnet Bear's Tile Rollers
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.TI4.System'

CrLua = CrLua or {}  -- global, <include> wraps in a do .. end block
CrLua.TI4 = CrLua.TI4 or {}
CrLua.TI4.System = assert(not CrLua.TI4.System) and {
    _require = {},
    _allowMissingKeys = { 'SYSTEMS' },

    DEFAULT_LINE_THICKNESS = 0.2,
    LOCAL_TILE_RADIUS = 2.26,
    LOCAL_DISTANCE_TO_PLANET = 1.1,
    LOCAL_PLANET_RADIUS = 0.9,
    LOCAL_Y = 0.318
}

CrLua.TI4.System.SYSTEMS = {
    ['86e50a'] = { tile = 1, home = true, planets = {
        { name = 'Jord' },
    }},
    ['ac3193'] = { tile = 2, home = true, planets = {
        { name = 'Moll Primus' },
    }},
    ['db8aac'] = { tile = 3, home = true, planets = {
        { name = 'Darien' },
    }},
    ['da7879'] = { tile = 4, home = true, planets = {
        { name = 'Muaat' },
    }},
    ['fc6f7a'] = { tile = 5, home = true, planets = {
        { name = 'Nestphar' },
    }},
    ['420355'] = { tile = 6, home = true, planets = {
        { name = '[0.0.0]' },
    }},
    ['087347'] = { tile = 7, home = true, planets = {
        { name = 'Winnu' },
    }},
    ['ea676a'] = { tile = 8, home = true, planets = {
        { name = 'Mordai II' },
    }},
    ['0122f9'] = { tile = 9, home = true, planets = {
        { name = 'Maaluuk' },
        { name = 'Druaa' },
    }},
    ['e001b4'] = { tile = 10, home = true, planets = {
        { name = 'Arc Prime' },
        { name = 'Wren Terra' },
    }},
    ['d39876'] = { tile = 11, home = true, planets = {
        { name = 'Lisis II' },
        { name = 'Ragh' },
    }},
    ['11598c'] = { tile = 12, home = true, planets = {
        { name = 'Nar' },
        { name = 'Jol' },
    }},
    ['6176bf'] = { tile = 13, home = true, planets = {
        { name = "Tren'lak" },
        { name = 'Quinarra' },
    }},
    ['c2509e'] = { tile = 14, home = true, planets = {
        { name = 'Archon Ren' },
        { name = 'Archon Tau' },
    }},
    ['9c373a'] = { tile = 15, home = true, planets = {
        { name = 'Retillion' },
        { name = 'Shalloq' },
    }},
    ['6a4247'] = { tile = 16, home = true, planets = {
        { name = 'Hercant' },
        { name = 'Arretze' },
        { name = 'Kamdorn' },
    }},
    ['c56a8a'] = { tile = 17, wormholes = { 'delta' } },
    ['04df02'] = { tile = 18, planets = {
        { name = 'Mecatol Rex', radius = 1.7 },
    }},
    ['4216fd'] = { tile = 19, planets = {
        { name = 'Wellon' },
    }},
    ['bc4bcc'] = { tile = 20, planets = {
        { name = 'Vefut II' },
    }},
    ['f2798a'] = { tile = 21, planets = {
        { name = 'Thibah' },
    }},
    ['0ea77f'] = { tile = 22, planets = {
        { name = "Tar'mann" },
    }},
    ['7975f7'] = { tile = 23, planets = {
        { name = 'Saudor' },
    }},
    ['48cc9f'] = { tile = 24, planets = {
        { name = 'Mehar Xull' },
    }},
    ['71e1bf'] = { tile = 25, wormholes = { 'beta' }, planets = {
        { name = 'Quann' },
    }},
    ['f11ef5'] = { tile = 26, wormholes = { 'alpha' }, planets = {
        { name = 'Lodor' },
    }},
    ['fc239f'] = { tile = 27, planets = {
        { name = 'New Albion' },
        { name = 'Starpoint' },
    }},
    ['f8caf6'] = { tile = 28, planets = {
        { name = "Tequ'ran" },
        { name = 'Torkan' },
    }},
    ['0ac98b'] = { tile = 29, planets = {
        { name = "Qucen'n" },
        { name = 'Rarron' },
    }},
    ['aaae9f'] = { tile = 30, planets = {
        { name = 'Mellon' },
        { name = 'Zohbat' },
    }},
    ['d5ed63'] = { tile = 31, planets = {
        { name = 'Lazar' },
        { name = 'Sakulag' },
    }},
    ['48ac87'] = { tile = 32, planets = {
        { name = 'Dal Bootha' },
        { name = 'Xxehan' },
    }},
    ['87a5a2'] = { tile = 33, planets = {
        { name = 'Corneeq' },
        { name = 'Resculon' },
    }},
    ['eb99c0'] = { tile = 34, planets = {
        { name = 'Centauri' },
        { name = 'Gral' },
    }},
    ['dd2ca7'] = { tile = 35, planets = {
        { name = 'Bereg' },
        { name = 'Lirta IV' },
    }},
    ['a284d1'] = { tile = 36, planets = {
        { name = 'Arnor' },
        { name = 'Lor' },
    }},
    ['e0ff33'] = { tile = 37, planets = {
        { name = 'Arinam' },
        { name = 'Meer' },
    }},
    ['b958aa'] = { tile = 38, planets = {
        { name = 'Abyz' },
        { name = 'Fria' },
    }},
    ['0378a4'] = { tile = 39, wormholes = { 'alpha' } },
    ['ccd7ac'] = { tile = 40, wormholes = { 'beta' } },
    ['47a55d'] = { tile = 41, anomalies = { 'gravity rift' } },
    ['d13aa2'] = { tile = 42, anomalies = { 'nebula'} },
    ['dca098'] = { tile = 43, anomalies = { 'supernova' } },
    ['cd58c7'] = { tile = 44, anomalies = { 'asteroid field' } },
    ['7db8d8'] = { tile = 45, anomalies = { 'asteroid field' } },
    ['9dce5a'] = { tile = 46 },
    ['437f06'] = { tile = 47 },
    ['ff8f60'] = { tile = 48 },
    ['0216be'] = { tile = 49 },
    ['97ee53'] = { tile = 50 },
    ['f38182'] = { tile = 51, home = true, localY = 0.101, wormholes = { 'delta' }, planets = {
        { name = 'Creuss', position = { 0.35, 0.18 }, radius = 0.8 },
    }},
}

-------------------------------------------------------------------------------
--- Get a string describing the system.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @return string
-------------------------------------------------------------------------------
function CrLua.TI4.System.toString(system)
    assert(type(system) == 'table' and system.tile)
    local messageParts = {
        'System ' .. system.tile
    }
    for i, planet in ipairs(system.planets or {}) do
        table.insert(messageParts, i == 1 and ': ' or ', ')
        table.insert(messageParts, '“' .. planet.name .. '”')
    end
    return table.concat(messageParts, '')
end

-------------------------------------------------------------------------------
--- Get all systems.
-- @return table : list of CrLua.TI4.System.SYSTEMS values, with new object field.
-------------------------------------------------------------------------------
function CrLua.TI4.System.getAllSystems()
    local result = {}
    local systems = CrLua.TI4.System.SYSTEMS
    for _, object in ipairs(getAllObjects()) do
        local system = systems[object.getGUID()]
        if system then
            rawset(system, 'object', object)  -- rawset in case locked
            table.insert(result, system)
        end
    end
    return result
end

-------------------------------------------------------------------------------
--- Find system at position.
-- @param position table : {x,y,z} position in world coordinates.
-- @return system table : CrLua.TI4.System.SYSTEMS value with new object field.
-------------------------------------------------------------------------------
function CrLua.TI4.System.fromPosition(position)
    assert(type(position) == 'table' and position.x)
    local hits = Physics.cast({
        origin = { x = position.x, y = position.y - 1, z = position.z },
        direction = { x = 0, y = 1, z = 0 },
        type = 1, -- ray
        max_distance = 2,
    })
    local systems = CrLua.TI4.System.SYSTEMS
    for _, hit in ipairs(hits) do
        local object = hit.hit_object
        local system = systems[object.getGUID()]
        if system then
            rawset(system, 'object', object)  -- rawset in case locked
            return system
        end
    end
end

-------------------------------------------------------------------------------
-- Get planet at position.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates.
-- @param exact boolean : if true, position must be on planet (vs closest planet).
-- @return planet name string : or nil if no planet in that zone.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetFromPosition(system, position, exact)
    assert(type(system) == 'table' and system.tile and type(position) == 'table' and position.x)
    local i = CrLua.TI4.System._getZone(system, position)
    local planet = system.planets and #system.planets >= i and system.planets[i]
    if planet and exact then
        local planetPosition, planetRadius = CrLua.TI4.System.planetToPosition(system, planet.name)
        local dx = position.x - planetPosition.x
        local dz = position.z - planetPosition.z
        local distance = math.sqrt((dx * dx) + (dz * dz))
        if distance > planetRadius then
            planet = nil
        end
    end
    return planet and planet.name
end

-------------------------------------------------------------------------------
-- Get planet position.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param planetName string : planet name.
-- @return table, number : {x,y,z} position table, planet radius.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetToPosition(system, planetName)
    assert(type(system) == 'table' and system.tile and type(planetName) == 'string')

    local planetIndex = false
    for i, entry in ipairs(system.planets or {}) do
        if entry.name == planetName then
            planetIndex = i
            break
        end
    end
    assert(planetIndex)

    -- Compute radius in world space.
    local localRadius = system.planets[planetIndex].radius or CrLua.TI4.System.LOCAL_PLANET_RADIUS
    local p1 = system.object.getPosition()
    local p2 = system.object.positionToWorld({ x = localRadius, y = 0, z = 0 })
    local radiusWorld = math.sqrt((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)

    local overridePosition = system.planets[planetIndex].position
    if overridePosition then
        local posXYZ = { x = overridePosition[1], y = system.localY or CrLua.TI4.System.LOCAL_Y, z = overridePosition[2] }
        return system.object.positionToWorld(posXYZ), radiusWorld
    end

    local distanceToPlanet = 0
    local bearingToPlanet = 0
    local zoneBoundaries = CrLua.TI4.System._getZoneBorders(system)
    if #zoneBoundaries > 2 then
        local a = zoneBoundaries[planetIndex]
        local b = zoneBoundaries[planetIndex + 1]
        if a < b then
            bearingToPlanet = (a + b) / 2
        else
            bearingToPlanet = ((a + 360 + b) / 2) % 360
        end
        distanceToPlanet = CrLua.TI4.System.LOCAL_DISTANCE_TO_PLANET
    end

    -- Planets bearings are almost but not exactly in the center of their zones.
    -- Home system planets are slightly offset.  Different same-number-of-planets
    -- systems vary slightly, so unless want to hard code each tile this is close.
    local numZones = #zoneBoundaries - 1
    if numZones == 1 then
        if system.home then
            distanceToPlanet = 0.35
            bearingToPlanet = 345
        else
            distanceToPlanet = 0.05
            bearingToPlanet = 270
        end

    elseif numZones == 2 then
        if planetIndex == 1 then
            if system.home then
                distanceToPlanet = distanceToPlanet + 0.1
                bearingToPlanet = bearingToPlanet - 4
            else
                distanceToPlanet = distanceToPlanet + 0.05
                bearingToPlanet = bearingToPlanet - 3
            end
        elseif planetIndex == 2 then
            if system.home then
                distanceToPlanet = distanceToPlanet - 0.05
                bearingToPlanet = bearingToPlanet - 15
            else
                distanceToPlanet = distanceToPlanet - 0.2
                bearingToPlanet = bearingToPlanet + 5
            end
        end
    elseif numZones == 3 then
        if planetIndex == 1 then  -- hercant
            distanceToPlanet = distanceToPlanet + 0.25
            bearingToPlanet = bearingToPlanet + 9
        elseif planetIndex == 2 then
            distanceToPlanet = distanceToPlanet + 0.07
            bearingToPlanet = bearingToPlanet - 5
        elseif planetIndex == 3 then
            distanceToPlanet = distanceToPlanet + 0.22
            bearingToPlanet = bearingToPlanet - 6
        end
    end

    local positionWorld = CrLua.TI4.System._bearingToPosition(system, bearingToPlanet, distanceToPlanet)
    return positionWorld, radiusWorld
end

-------------------------------------------------------------------------------
--- Get vector lines for planet.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param planetName string : planet name.
-- @param override table : vector lines parameters such as thickness, color.
-- @return table : vector lines entry wrapping planet.
-------------------------------------------------------------------------------
function CrLua.TI4.System.planetVectorLine(system, planetName, override)
    assert(type(system) == 'table' and system.tile and type(planetName) == 'string' and type(override) == 'table')
    assert(system.object)

    local planetOrigin, planetRadius = CrLua.TI4.System.planetToPosition(system, planetName)

    -- Convert to local space (get local radius from planet list).
    local planetOrigin = system.object.positionToLocal(planetOrigin)
    for _, planet in ipairs(system.planets) do
        if planet.name == planetName then
            planetRadius = planet.radius or CrLua.TI4.System.LOCAL_PLANET_RADIUS
            break
        end
    end

    local points = {}
    for i = 16, 1, -1 do
        local theta = math.pi * 2.0 * i / 16.0
        local position = {
            x = planetOrigin.x + math.cos(theta) * planetRadius,
            y = system.localY or CrLua.TI4.System.LOCAL_Y,
            z = planetOrigin.z + math.sin(theta) * planetRadius
        }
        table.insert(points, system.object.positionToWorld(position))
    end

    return {
        points = points,
        color = override.color or 'Red',
        thickness = override.thickness or CrLua.TI4.System.DEFAULT_LINE_THICKNESS,
        rotation = { x = 0, y = 0, z = 0 },
        loop = true,
        square = true
    }
end

-------------------------------------------------------------------------------
--- Get vector lines separating all zones.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param override table : vector lines parameters such as thickness, color.
-- @return table : vector lines entry.
-------------------------------------------------------------------------------
function CrLua.TI4.System.vectorLine(system, override)
    assert(type(system) == 'table' and system.tile and type(override) == 'table')
    assert(system.object)

    local outer = CrLua.TI4.System.zoneEdgePositions(system)

    local points = false
    if #outer < 2 then
        points = {}
    elseif #outer == 2 then
        points = { outer[1], center, outer[2] }
    elseif #outer == 3 then
        points = { outer[1], center, outer[2], center, outer[3] }
    else
        error(TAG .. ': too many zones')
    end

    return {
        points = points,
        color = override.color or 'Red',
        thickness = override.thickness or CrLua.TI4.System.DEFAULT_LINE_THICKNESS,
        rotation = { x = 0, y = 0, z = 0 },
        loop = false,
        square = true
    }
end

-------------------------------------------------------------------------------
--- Get on-edge points for zone boundaries.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @return table : list of {x,y,z} points.
-------------------------------------------------------------------------------
function CrLua.TI4.System.zoneEdgePositions(system)
    assert(type(system) == 'table' and system.tile)
    assert(system.object)

    local zoneBorders = CrLua.TI4.System._getZoneBorders(system)
    if #zoneBorders <= 2 then
        return {}
    end

    local y = system.localY or CrLua.TI4.System.LOCAL_Y
    local center = system.object.positionToWorld({x = 0, y = y, z = 0})
    local r = CrLua.TI4.System.LOCAL_TILE_RADIUS
    local outer = {}
    for i = 1, #zoneBorders - 1 do
        local bearing = zoneBorders[i]
        table.insert(outer, CrLua.TI4.System._bearingToPosition(system, bearing, r))
    end
    return outer
end

-------------------------------------------------------------------------------
--- Get bearings separating zones.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @return table : list of bearings, last should equal first (wrapped).
-------------------------------------------------------------------------------
function CrLua.TI4.System._getZoneBorders(system)
    assert(type(system) == 'table' and system.tile)
    if not system._zoneBorders then
        local numZones = (system.planets and #system.planets or 0) + (system.wormholes and #system.wormholes or 0)

        -- The local coordinate space for a tile shows {x=1,z=1} to be lower left.
        -- Set zone borders to track planets starting left going clockwise.
        if numZones <= 1 then
            rawset(system, '_zoneBorders', { 0, 360 })
        elseif numZones == 2 then
            rawset(system, '_zoneBorders', { 240, 60, 240 })
        elseif numZones == 3 then
            rawset(system, '_zoneBorders', { 210, 330, 90, 210 })
        else
            error(TAG .. ': too many zones (' .. numZones .. ')')
        end

    end
    return assert(system._zoneBorders)
end

-------------------------------------------------------------------------------
--- Which zone contains position?
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates.
-- @return index number : zone index, planets first then wormholes (if both).
-------------------------------------------------------------------------------
function CrLua.TI4.System._getZone(system, position)
    assert(type(system) == 'table' and system.tile and type(position) == 'table' and position.x)
    local bearing = CrLua.TI4.System._positionToBearing(system, position)
    local zoneBorders = CrLua.TI4.System._getZoneBorders(system)
    for i = 1, #zoneBorders - 1 do
        local a = zoneBorders[i]
        local b = zoneBorders[i + 1]
        if a < b then
            if bearing >= a and bearing <= b then
                return i
            end
        else
            -- Zone wraps across zero.
            if bearing >= a or bearing <= b then
                return i
            end
        end
    end
    error('no zone')
end

-------------------------------------------------------------------------------
--- Compute the bearing from the system center to the world position.
-- Bearing is the angle, measured clockwise about the Y axis from the
-- "north" direction.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param position table : {x,y,z} position in world coordinates, unless no system then local.
-- @return bearing number : 0 <= bearing < 360.
-------------------------------------------------------------------------------
function CrLua.TI4.System._positionToBearing(system, position)
    assert(type(position) == 'table' and position.x)
    if system then
        assert(type(system) == 'table' and system.tile and system.object)
        position = system.object.positionToLocal(position)
    end

    -- Compute bearing in radians.
    local bearing = math.atan2(position.z, -position.x) + (math.pi / 2)

    -- Convert to degrees between 0 and 360.
    bearing = (bearing * 180.0 / math.pi) % 360.0
    if bearing < 0 then
        bearing = bearing + 360.0
    end

    assert(0 <= bearing and bearing < 360)
    return bearing
end

function CrLua.TI4.System._testPositionToBearing()
    local positionsToBearings = {
        [{ x = 0, z = -1 }] = 0,
        [{ x = -1, z = -1 }] = 45,
        [{ x = -1, z = 0 }] = 90,
        [{ x = 0, z = 1 }] = 180,
        [{ x = 1, z = 0 }] = 270
    }
    for position, expected in pairs(positionsToBearings) do
        local observed = CrLua.TI4.System._positionToBearing(false, position)
        assert(expected == observed, expected .. ' saw ' .. observed)
    end
end

-------------------------------------------------------------------------------
--- Compute the world position at the given bearing (relative to system tile
-- orientation) at distance r from the system center.
-- @param system table : CrLua.TI4.System.SYSTEMS value.
-- @param bearing number : angle in degrees, clockwise from "north".
-- @param r number : distance from center of tile to result point (in local space!).
-- @return position table : position in world coordinates (or local if no system).
-------------------------------------------------------------------------------
function CrLua.TI4.System._bearingToPosition(system, bearing, r)
    assert(type(bearing) == 'number' and 0 <= bearing and bearing < 360 and type(r) == 'number')
    local bearing = -bearing * math.pi / 180.0
    local result = { x = r * math.sin(bearing), y = 0, z = -r * math.cos(bearing) }
    if system then
        assert(type(system) == 'table' and system.tile and system.object)
        result.y = system.localY or CrLua.TI4.System.LOCAL_Y
        assert(system.object)
        result = system.object.positionToWorld(result)
    end
    return result
end

function CrLua.TI4.System._testBearingToPosition()
    local positionsToBearings = {
        [{ x = 0, z = -1 }] = 0,
        [{ x = -1, z = 0 }] = 90,
        [{ x = 0, z = 1 }] = 180,
        [{ x = 1, z = 0 }] = 270
    }
    for position, bearing in pairs(positionsToBearings) do
        local observed = CrLua.TI4.System._bearingToPosition(false, bearing, 1)
        assert(math.abs(observed.x - position.x) < 0.001, 'x ' .. observed.x .. ' vs ' .. position.x)
        assert(math.abs(observed.z - position.z) < 0.001, 'z ' .. observed.z .. ' vs ' .. position.z)
    end
end

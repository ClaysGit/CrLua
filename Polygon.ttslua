-------------------------------------------------------------------------------
--- Polygon utility functions.
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.Polygon'

CrLua.Polygon = assert(not CrLua.Polygon) and {}

-------------------------------------------------------------------------------
--- Return the bounding box of a polygon.
-- @param polygon table : list of 2d points, each point is a list of two numbers.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return table : table with min, max points using same xIndex, yIndex.
-------------------------------------------------------------------------------
function CrLua.Polygon.boundingBox(polygon, xIndex, yIndex)
    assert(type(polygon) == 'table')

    local vertexCount = #polygon
    if #polygon == 0 then
        return
    end

    local x = xIndex or 1
    local y = yIndex or 2

    local min = { [x] = polygon[1][x], [y] = polygon[1][y] }
    local max = { [x] = polygon[1][x], [y] = polygon[1][y] }

    for i = 2, vertexCount do
        local vertex = polygon[i]
        min[x] = math.min(min[x], vertex[x])
        min[y] = math.min(min[y], vertex[y])
        max[x] = math.max(max[x], vertex[x])
        max[y] = math.max(max[y], vertex[y])
    end

    return { min = min, max = max }
end

function CrLua.Polygon._testBoundingBox()
    local polygon = { {0, 0}, {-1, 2}, {1, 0}, {0, -2} }
    local box = CrLua.Polygon.boundingBox(polygon)
    assert(box.min[1] == -1 and box.min[2] == -2, box.min[1] .. ', ' .. box.min[2])
    assert(box.max[1] == 1 and box.max[2] == 2)
    local box = CrLua.Polygon.boundingBox(polygon, 1, 2)
    assert(box.min[1] == -1 and box.min[2] == -2, box.min[1] .. ', ' .. box.min[2])
    assert(box.max[1] == 1 and box.max[2] == 2)
end

-------------------------------------------------------------------------------
--- Inset a bounding box.
-- Useful when bounding boxes overlap to create slightly smaller distinct areas.
-- @param box table : {min, max} points.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return table : new table with inset min, max points using same xIndex, yIndex.
-------------------------------------------------------------------------------
function CrLua.Polygon.insetBoundingBox(box, inset, xIndex, yIndex)
    assert(type(box) == 'table' and box.min and type(inset) == 'number')

    local x = xIndex or 1
    local y = yIndex or 2

    return {
        min = { [x] = box.min[x] + inset, [y] = box.min[y] + inset },
        max = { [x] = box.max[x] - inset, [y] = box.max[y] - inset }
    }
end

function CrLua.Polygon._testInsetBoundingBox()
    local box = { min = { 1, 2 }, max = { 8, 9 } }
    local inset = CrLua.Polygon.insetBoundingBox(box, 2)
    assert(inset.min[1] == 3 and inset.min[2] == 4)
    assert(inset.max[1] == 6 and inset.max[2] == 7)
end

-------------------------------------------------------------------------------
--- Get bounding box corners.
-- @param box table : {min, max} points.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return table : list of four corner points using same xIndex, yIndex.
-------------------------------------------------------------------------------
function CrLua.Polygon.corners(box, xIndex, yIndex)
    assert(type(box) == 'table' and box.min)

    local x = xIndex or 1
    local y = yIndex or 2

    return {
        { [x] = box.min[x], [y] = box.min[y] },
        { [x] = box.min[x], [y] = box.max[y] },
        { [x] = box.max[x], [y] = box.min[y] },
        { [x] = box.max[x], [y] = box.max[y] }
    }
end

function CrLua.Polygon._testCorners()
    local box = { min = { 1, 2 }, max = { 8, 9 } }
    local corners = CrLua.Polygon.corners(box)
    assert(#corners == 4)
    assert(corners[1][1] == 1 and corners[1][2] == 2)
    assert(corners[2][1] == 1 and corners[2][2] == 9)
    assert(corners[3][1] == 8 and corners[3][2] == 2)
    assert(corners[4][1] == 8 and corners[4][2] == 9)
end

-------------------------------------------------------------------------------
--- Is the point inside the polygon (2D)?
-- Uses the "ray casting method".
-- @see https://love2d.org/wiki/PointWithinShape
-- ""
-- @param polygon table : list of 2d points, each point is a list of two numbers.
-- @param point table : list of 2 numbers.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return boolean : true if point is inside polygon.
-------------------------------------------------------------------------------
function CrLua.Polygon.inside(polygon, point, xIndex, yIndex)
    assert(type(polygon) == 'table' and type(point) == 'table')

    local x = xIndex or 1
    local y = yIndex or 2

    local i, yflag0, yflag1, inside_flag
	local vtx0, vtx1

	local numverts = #polygon
    local tx = point[x]
    local ty = point[y]

	vtx0 = polygon[numverts]
	vtx1 = polygon[1]

	-- get test bit for above/below X axis
	yflag0 = vtx0[y] >= ty
	inside_flag = false

	for i = 2, numverts + 1 do
		yflag1 = vtx1[y] >= ty

		--[[ Check if endpoints straddle (are on opposite sides) of X axis
		 * (i.e. the Y's differ); if so, +X ray could intersect this edge.
		 * The old test also checked whether the endpoints are both to the
		 * right or to the left of the test point.  However, given the faster
		 * intersection point computation used below, this test was found to
		 * be a break-even proposition for most polygons and a loser for
		 * triangles (where 50% or more of the edges which survive this test
		 * will cross quadrants and so have to have the X intersection computed
		 * anyway).  I credit Joseph Samosky with inspiring me to try dropping
		 * the "both left or both right" part of my code.
		 --]]
		if yflag0 ~= yflag1 then
			--[[ Check intersection of pgon segment with +X ray.
			 * Note if >= point's X; if so, the ray hits it.
			 * The division operation is avoided for the ">=" test by checking
			 * the sign of the first vertex wrto the test point; idea inspired
			 * by Joseph Samosky's and Mark Haigh-Hutchinson's different
			 * polygon inclusion tests.
			 --]]
			if ( ((vtx1[y] - ty) * (vtx0[x] - vtx1[x]) >= (vtx1[x] - tx) * (vtx0[y] - vtx1[y])) == yflag1 ) then
				inside_flag = not inside_flag
			end
		end

		-- Move to the next pair of vertices, retaining info as possible.
		yflag0 = yflag1
		vtx0 = vtx1
		vtx1 = polygon[i]
	end

	return inside_flag
end

function CrLua.Polygon._testInside()
    local polygon = { {0,0}, {0,2}, {2,2}, {2,0} }
    assert(CrLua.Polygon.inside(polygon, {1,1}))
    assert(not CrLua.Polygon.inside(polygon, {3,3}))
end

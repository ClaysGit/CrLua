#include ~/CrLua/Util

-------------------------------------------------------------------------------
--- Polygon utility functions.
-- @author bonkersbgg on BoardGameGeek.com
-------------------------------------------------------------------------------

local TAG = 'CrLua.Polygon'

local CrLua = CrLua or {}
CrLua.Polygon = assert(not CrLua.Polygon) and {}

-------------------------------------------------------------------------------
--- Return the bounding box of a polygon.
-- @param polygon table : list of 2d points, each point is a list of two numbers.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return table, table : {xmin, ymin} and {xmax, ymax} using same xIndex, yIndex.
-------------------------------------------------------------------------------
function CrLua.Polygon.boundingBox(polygon, xIndex, yIndex)
    assert(type(polygon) == 'table')

    local vertexCount = #polygon
    if #polygon == 0 then
        return
    end

    local x = xIndex or 1
    local y = yIndex or 2

    local min = { [x] = polygon[1][x], [y] = polygon[1][y] }
    local max = { [x] = polygon[1][x], [y] = polygon[1][y] }

    for i = 2, vertexCount do
        local vertex = polygon[i]
        if vertex[x] < min[x] then min[x] = vertex[x] end
        if vertex[y] < min[y] then min[y] = vertex[y] end
        if vertex[x] > max[x] then max[x] = vertex[x] end
        if vertex[y] > max[y] then max[y] = vertex[y] end
    end

    return min, max
end

function CrLua.Polygon._testBoundingBox()
    local polygon = { {0, 0}, {-1, 2}, {1, 0}, {0, -2} }
    local min, max = CrLua.Polygon.boundingBox(polygon)
    assert(min[1] == -1 and min[2] == -2, min[1] .. ', ' .. min[2])
    assert(max[1] == 1 and max[2] == 2)
    local min, max = CrLua.Polygon.boundingBox(polygon, 1, 2)
    assert(min[1] == -1 and min[2] == -2, min[1] .. ', ' .. min[2])
    assert(max[1] == 1 and max[2] == 2)
end

-------------------------------------------------------------------------------
--- Is the point inside the polygon (2D)?
-- Uses the "ray casting method".
-- @see https://love2d.org/wiki/PointWithinShape
-- ""
-- @param polygon table : list of 2d points, each point is a list of two numbers.
-- @param point table : list of 2 numbers.
-- @param optional xIndex : if x is not point[1], find it as point[xIndex].
-- @param optional yIndex : if y is not point[2], find it as point[yIndex].
-- @return boolean : true if point is inside polygon.
-------------------------------------------------------------------------------
function CrLua.Polygon.inside(polygon, point, xIndex, yIndex)
    assert(type(polygon) == 'table' and type(point) == 'table')

    local x = xIndex or 1
    local y = yIndex or 2

    local i, yflag0, yflag1, inside_flag
	local vtx0, vtx1

	local numverts = #polygon
    local tx = point[x]
    local ty = point[y]

	vtx0 = polygon[numverts]
	vtx1 = polygon[1]

	-- get test bit for above/below X axis
	yflag0 = vtx0[y] >= ty
	inside_flag = false

	for i = 2, numverts + 1 do
		yflag1 = vtx1[y] >= ty

		--[[ Check if endpoints straddle (are on opposite sides) of X axis
		 * (i.e. the Y's differ); if so, +X ray could intersect this edge.
		 * The old test also checked whether the endpoints are both to the
		 * right or to the left of the test point.  However, given the faster
		 * intersection point computation used below, this test was found to
		 * be a break-even proposition for most polygons and a loser for
		 * triangles (where 50% or more of the edges which survive this test
		 * will cross quadrants and so have to have the X intersection computed
		 * anyway).  I credit Joseph Samosky with inspiring me to try dropping
		 * the "both left or both right" part of my code.
		 --]]
		if yflag0 ~= yflag1 then
			--[[ Check intersection of pgon segment with +X ray.
			 * Note if >= point's X; if so, the ray hits it.
			 * The division operation is avoided for the ">=" test by checking
			 * the sign of the first vertex wrto the test point; idea inspired
			 * by Joseph Samosky's and Mark Haigh-Hutchinson's different
			 * polygon inclusion tests.
			 --]]
			if ( ((vtx1[y] - ty) * (vtx0[x] - vtx1[x]) >= (vtx1[x] - tx) * (vtx0[y] - vtx1[y])) == yflag1 ) then
				inside_flag = not inside_flag
			end
		end

		-- Move to the next pair of vertices, retaining info as possible.
		yflag0 = yflag1
		vtx0 = vtx1
		vtx1 = polygon[i]
	end

	return inside_flag
end

function CrLua.Polygon._testInside()
    local polygon = { {0,0}, {0,2}, {2,2}, {2,0} }
    assert(CrLua.Polygon.inside(polygon, {1,1}))
    assert(not CrLua.Polygon.inside(polygon, {3,3}))
end

CrLua.Util.lock(TAG, CrLua.Polygon)

-- TI4 Map Building Tool by Cruix

-- Maps are stored in a string by their tile numbers,
-- starting directly above Mecatol Rex and moving in
-- a clockwise spiral

-- Tiles are retrieved by their GUIDs, so any tiles that
-- are deleted and replaced with a new GUID will need to
-- have their information updated in createTiles() below

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local ROTATE_TILES_FOR_Z = false

cur_input = ""
slice_datalabel_name = "slice_data_label"
do_lock = true
tile_diameter = 6.08
tile_radius = 3
tile_limit = 60
mecatol_guid = "04df02"
mecatol_name = "Mecatol Rex"
custodians_guid = "70642f"
waiting_id = 0
second_pass_delay = 1
deck_last_cards = {}
blanktile = {guid = "", key = "0"}
redbag_guid = "14a45f"
bluebag_guid = "69311f"
bag_guids = {
    redbag_guid,
    bluebag_guid,
    "dc3ab8",
    "a28c98",
    "4e62ee",
    "64e0ad",
    "236a35",
    "e32608",
    "10dc17",
    "5530cc",
    "888d81",
    "b65c3f",
    "be60fc",
    "a5f431",
    "db203a",
    "1f9f1a",
    "5b55e3",
    "037d7e",
    "bd8c3b",
    "cb9a22",  -- TI3 systems
}

tiles_by_key = {}
tiles_by_guid = {}
planets = { mecatol_name }

slicetext_6p = {{0, 1}, {0.87, 0.5}, {0.87, -0.5}, {0, -0.92}, {-0.87, -0.5}, {-0.87, 0.5}}
slicetext_5p = {{-0.3, 0.84}, {0.87, 0.5}, {0.87, -0.5}, {0, -0.92}, {-0.9, -0.15}}
slicetext_4p = {{-0.3, 0.84}, {0.9, 0.15}, {0.3, -0.8}, {-0.9, -0.15}}
slicetext_3p = {{0.87, 0.5}, {0, -0.92}, {-0.87, 0.5}}

ownership_6p = {1, 2, 3, 4, 5, 6, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 1}
ownership_5p = {1, 2, 3, 4, 5, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 5, 0, 1, 1, 0, 2, 2, 2, 3, 3, 3, 4, 4, 4, 0, 5, 5, 5, 0, 1, 1}
ownership_4p = {1, 2, 0, 3, 4, 0, 1, 0, 2, 2, 0, 3, 3, 0, 4, 4, 0, 1, 1, 1, 2, 2, 2, 2, 0, 3, 3, 3, 3, 4, 4, 4, 4, 0, 1, 1}
ownership_3p = {0, 1, 0, 2, 0, 3, 0, 1, 1, 1, 0, 2, 2, 2, 0, 3, 3, 3, 0, 0, 1, 1, 1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 3, 3, 3, 0}

function onLoad()
    createInputs()
    createTiles()
end

function createTiles()
    addtile(blanktile)

    for _, system in pairs(_systemHelper.systems()) do

        local entry = {
            guid = system.guid,
            key = tostring(system.tile),
            home = system.home or nil,
            planets = nil,
            resources = nil,
            influence = nil,
            skips = nil,
        }

        if system.planets and #system.planets > 0 then
            entry.planets = {}
            for _, planet in ipairs(system.planets or {}) do
                table.insert(entry.planets, planet.name)
                if planet.resources and planet.resources > 0 then
                    entry.resources = (entry.resources or 0) + planet.resources
                end
                if planet.influence and planet.influence > 0 then
                    entry.influence = (entry.influence or 0) + planet.influence
                end
                if planet.tech then
                    local skip = string.upper(string.sub(planet.tech, 1, 1))
                    entry.skips = (entry.skip or '') .. skip
                end
            end
        end

        if entry.guid ~= mecatol_guid then
            addtile(entry)
        end
    end
end

function addtile(tileinfo)
    tiles_by_key[tileinfo.key] = tileinfo
    tiles_by_guid[tileinfo.guid] = tileinfo
    if tileinfo.planets ~= nil then
        for i, p in ipairs(tileinfo.planets) do
            table.insert(planets, p)
        end
    end
end

function createInputs()
    self.createInput({
        input_function = "input_string",
        function_owner = self,
        value    = 0,
        alignment  = 4,
        position  = {x=0, y=0.2, z=0},
        width    = 1000,
        height    = 180,
        font_size  = 50,
        validation  = 1,
        alignment  = 2,
        value    = "",
        label     = "Enter map string or press 'save' to save the current map"
    })
    self.createButton({
        click_function  = "build",
        function_owner  = self,
        label      = "Build",
        position    = {x=0, y=0.5, z=0.4},
        width      = 500,
        height      = 200,
        font_size    = 100,
    })
    self.createButton({
        click_function  = "save",
        function_owner  = self,
        label      = "Save",
        position    = {x=0, y=0.5, z=0.8},
        width      = 500,
        height      = 200,
        font_size    = 100,
    })
    self.createButton({
        click_function  = "toggle_lock",
        function_owner  = self,
        label      = "lock tiles",
        position    = {x=0.8, y=0.5, z=0.4},
        width      = 250,
        height      = 50,
        font_size    = 40,
    })
    self.createButton({
        click_function  = "place_cards",
        function_owner  = self,
        label      = "Place Cards",
        position    = {x=-0.9, y=0.5, z=0.4},
        width      = 400,
        height      = 200,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "return_cards",
        function_owner  = self,
        label      = "Return Cards",
        position    = {x=-0.9, y=0.5, z=0.8},
        width      = 400,
        height      = 200,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "clear_tiles",
        function_owner  = self,
        label      = "Clear",
        position    = {x=0.95, y=0.5, z=0.8},
        width      = 400,
        height      = 200,
        font_size    = 100,
    })
    self.createButton({
        click_function  = "count_slices3",
        function_owner  = self,
        label      = "3p",
        position    = {x=-1.2, y=0.5, z=-0.7},
        width      = 100,
        height      = 100,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "count_slices4",
        function_owner  = self,
        label      = "4p",
        position    = {x=-1, y=0.5, z=-0.7},
        width      = 100,
        height      = 100,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "count_slices5",
        function_owner  = self,
        label      = "5p",
        position    = {x=-0.8, y=0.5, z=-0.7},
        width      = 100,
        height      = 100,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "count_slices6",
        function_owner  = self,
        label      = "6p",
        position    = {x=-0.6, y=0.5, z=-0.7},
        width      = 100,
        height      = 100,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "clear_slicelabels",
        function_owner  = self,
        label      = "clear",
        position    = {x=-0.35, y=0.5, z=-0.7},
        width      = 160,
        height      = 100,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "pass",
        function_owner  = self,
        label      = "Count Resources",
        position    = {x=-0.8, y=0.5, z=-0.9},
        width      = 0,
        height      = 0,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "pass",
        function_owner  = self,
        label      = "Draw Lines",
        position    = {x=-0.8, y=0.5, z=-0.5},
        width      = 0,
        height      = 0,
        font_size    = 60,
    })
    self.createButton({
        click_function  = "drawAuto",
        function_owner  = self,
        label      = "Auto",
        position    = {x=-1, y=0.5, z=-0.3},
        width      = 320,
        height      = 100,
        font_size    = 60,
    })
end

function input_string(_, _, input)
    cur_input = input
end

function toggle_lock(_, color)
    do_lock = not do_lock
    local newlabel
    if do_lock then
        newlabel = "lock tiles"
    else
        newlabel = "unlock tiles"
    end
    self.editButton({index = 2, label = newlabel})
end

---------------------
-- Map building stuff
---------------------

function build(_, color)
    broadcastToAll("Building map from string: " .. cur_input)
    place_tiles(parse_string(cur_input))
end

function parse_string(input)
    local buildlist = {}
    for key in string.gmatch(input, "%d+") do
        if tiles_by_key[key] ~= nil then
            table.insert(buildlist, tiles_by_key[key])
        else
            broadcastToAll("Error parsing; no tile has the number " .. key)
            table.insert(buildlist, blanktile)
        end
    end
    return buildlist
end

function place_tiles(buildlist)
    local origin = {
        position = { x = 0, y = 1, z = 0 },
        rotation = { x = 0, y = 0, z = 0 }
    }

    local mecatol = getObjectFromGUID(mecatol_guid)
    if mecatol then
        origin.position = mecatol.getPosition()
        origin.rotation = mecatol.getRotation()
    else
        broadcastToAll("Unable to find Mecatol Rex, generating map at the center of the table.")
    end

    local hex_itr = spiral_hex_iterator(origin.position, origin.rotation)
    for i, info in ipairs(buildlist) do
        local position = hex_itr()
        local rotation = {
            x = origin.rotation.x,
            y = origin.rotation.y + ((position.z < 0 and ROTATE_TILES_FOR_Z) and 180 or 0),
            z = origin.rotation.z
        }
        place_tile(info, position, rotation)
    end
end

function place_tile(tileinfo, location, rotation)
    if tileinfo == blanktile then
        return true
    end
    local guid = tileinfo.guid
    local tile = getObjectFromGUID(guid)
    if tile ~= nil then
        tile.setPositionSmooth(location)
        tile.setRotationSmooth(rotation)
        tile.setLock(do_lock)
        return true
    else
        for i, g in ipairs(bag_guids) do
            local bag = getObjectFromGUID(g)
            if place_tile_from_bag(bag, guid, location, rotation) then
                return true
            end
        end
    end
    broadcastToAll("Unable to find tile number " .. tileinfo.key .. ", ensure that no tiles have been deleted, and that all tiles are on the table or in their starting bags.")
    return false
end

function place_tile_from_bag(bag, guid, location, rotation)
    local function delayedLock(object)
        Wait.time(function() object.setLock(do_lock) end, 1)
    end

    if bag ~= nil and bag.getObjects ~= nil then
        for i, g in ipairs(bag.getObjects()) do
            if g.guid == guid then
                bag.takeObject({
                    guid = guid,
                    position = location,
                    rotation = rotation,
                    callback_function = do_lock and delayedLock
                })
                return true
            end
        end
    else
        return false
    end
end

function clear_tiles(_, color)
    broadcastToAll("Returning tiles")
    local redbag = getObjectFromGUID(redbag_guid)
    local bluebag = getObjectFromGUID(bluebag_guid)
    if redbag == nil then
        broadcastToAll("Cannot find red planet tiles bag")
    end
    if bluebag == nil then
        broadcastToAll("Cannot find blue planet tiles bag")
    end

    for i, obj in ipairs(getAllObjects()) do
        local info = tiles_by_guid[obj.guid]
        if info ~= nil and info.home == nil then
            obj.setLock(false)
            if info.planets ~= nil then
                if bluebag ~= nil then
                    bluebag.putObject(obj)
                end
            else
                if redbag ~= nil then
                    redbag.putObject(obj)
                end
            end
        end
    end
end

---------------------
-- Map saving stuff
---------------------

function save(_, color)
    broadcastToAll("saving map")
    save_tiles()
end

function save_tiles()
    local tile_itr = placed_tiles_iterator()
    if(tile_itr == nil) then
        return
    end

    local string = ""
    local blanks = 0
    for spot=1,tile_limit do
        local tile = tile_itr()
        if(tile ~= nil) then
            for i=1,blanks do
                string = string .. "0 "
            end
            string = string .. tile.info.key .. " "
            blanks = 0
        else
            blanks = blanks + 1
        end
    end
    cur_input = string
    self.editInput({index = 0, value = string})
end

---------------------
-- Card stuff
---------------------

function place_cards(_, color)
    broadcastToAll("Placing planet cards")

    local tile_itr = placed_tiles_iterator()
    if tile_itr == nil then
        return
    end
    local mecatol = getObjectFromGUID(mecatol_guid)
    local rot = mecatol.getRotation()
    rot.z = 180
    place_card(mecatol_name, mecatol.positionToWorld({x = 0, y = 1, z = 0}), rot)
    local custodians = getObjectFromGUID(custodians_guid)
    if custodians ~= nil then
        local custpos = custodians.getPosition()
        local mecpos = mecatol.getPosition()
        custodians.setPositionSmooth(mecatol.positionToWorld({x = 0, y = 5, z = 0}))
        custodians.setRotationSmooth(mecatol.getRotation())
    end

    for spot=1,tile_limit do
        local tile = tile_itr()
        if tile ~= nil then
            local planets = tile.info.planets
            if planets ~= nil and not tile.info.home then
                local num = #planets
                rot = tile.obj.getRotation()
                rot.z = 180
                if num == 1 then
                    place_card(planets[1], tile.obj.positionToWorld({x = 0, y = 1, z = 0}), rot, true)
                elseif num == 2 then
                    place_card(planets[1], tile.obj.positionToWorld({x = 0.6, y = 1, z = -1}), rot, true)
                    place_card(planets[2], tile.obj.positionToWorld({x = -0.4, y = 1, z = 1}), rot, true)
                end
            end
        end
    end
end

function return_cards(_, color)
    broadcastToAll("Returning planet cards")
    local planet_deck_loc = self.positionToWorld({
        x = 2,
        y = 1,
        z = 0
    })
    planet_deck_rot = self.getRotation()
    for i, p in ipairs(planets) do
        place_card(p, planet_deck_loc, planet_deck_rot, false)
    end
end

function place_card(name, location, rotation, broadcast_not_found)
    if name == "" then
        return true
    end

    if deck_last_cards[name] ~= nil then
        deck_last_cards[name] = {loc = location, rot = rotation}
        return true
    end

    for i, obj in ipairs(getAllObjects()) do
        if obj.tag == "Deck" then
            local deck_contents = obj.getObjects()
            for i, g in ipairs(deck_contents) do
                if g.nickname == name then
                    if #deck_contents == 2 then
                        Timer.create({
                            identifier="afterdeckdestroy" .. waiting_id, function_name="handle_waiting_card",
                            function_owner=self, delay=second_pass_delay
                        })
                        waiting_id = waiting_id + 1
                        if i == 1 then
                            deck_last_cards[deck_contents[2].nickname] = {}
                        else
                            deck_last_cards[deck_contents[1].nickname] = {}
                        end
                    end
                    obj.takeObject({
                        guid = g.guid,
                        position = location,
                        rotation = rotation
                    })
                    return true
                end
            end
        elseif obj.tag == "Card" then
            if obj.getName() == name then
                obj.setPositionSmooth(location)
                obj.setRotationSmooth(rotation)
                return true
            end
        end
    end
    if broadcast_not_found then
        broadcastToAll("Unable to find planet card for " .. name .. ", ensure that it has not been deleted and that it or a deck containing it is on the table.")
    end
    return false
end

function handle_waiting_card()
    for name, val in pairs(deck_last_cards) do
        if val.loc ~= nil then
            deck_last_cards[name] = nil
            place_card(name, val.loc, val.rot, false)
            return
        end
    end
end

---------------------
-- Counting stuff
---------------------

function count_slices3(_, color)
    count_slices(ownership_3p, slicetext_3p)
end

function count_slices4(_, color)
    count_slices(ownership_4p, slicetext_4p)
end

function count_slices5(_, color)
    count_slices(ownership_5p, slicetext_5p)
end

function count_slices6(_, color)
    count_slices(ownership_6p, slicetext_6p)
end

function clear_slicelabels()
    for i, obj in ipairs(getAllObjects()) do
        if(obj.getName() == slice_datalabel_name) and (obj.TextTool ~= nil) then
            destroyObject(obj)
        end
    end
end

function count_slices(ownership, slicetext)
    clear_slicelabels()
    local mecatol = getObjectFromGUID(mecatol_guid)
    if mecatol == nil then
        broadcastToAll("Unable to find Mecatol Rex, ensure that it has not been deleted and that it is at the center of the table.")
        return
    end
    local counts = {}
    for i, xz in ipairs(slicetext) do
        table.insert(counts, {resources = 0, influence = 0, skips = ""})
    end

    local tile_itr = placed_tiles_iterator()
    if(tile_itr == nil) then
        return
    end
    for i, owner in ipairs(ownership) do
        local tile = tile_itr()
        if (owner ~= 0) and (tile ~= nil) then
            if tile.info.resources ~= nil then
                counts[owner].resources = counts[owner].resources + tile.info.resources
            end
            if tile.info.influence ~= nil then
                counts[owner].influence = counts[owner].influence + tile.info.influence
            end
            if tile.info.skips ~= nil then
                counts[owner].skips = counts[owner].skips..tile.info.skips
            end
        end
    end

    for i, xz in ipairs(slicetext) do
        local resources = 0
        local influence = 0
        local skips = "RYB"
        local textpos = mecatol.getPosition()
        textpos = mecatol.positionToWorld({x = tile_diameter * 3 * xz[1], y = 1, z = tile_diameter * 3 * xz[2]})
        textpos = {-textpos.x, textpos.y, -textpos.z}
        local textrot = mecatol.getRotation()
        textrot.x = textrot.x + 90
        textrot.y = textrot.y + 180
        local table = {type = "3DText", position = textpos, rotation = textrot}
        local text = spawnObject(table)
        text.TextTool.setValue(counts[i].resources.."/"..counts[i].influence.." "..counts[i].skips)
        text.setName(slice_datalabel_name)
    end
end

---------------------
-- Helpers
---------------------

function pass()
end

function spiral_hex_iterator(startpos, startrot)
    local level = 1
    local dir = 120
    local steps = 0
    local north = startrot.y + 180
    local nextpos = move_in_dir(startpos, north)
    return function()
        local thispos = nextpos
        nextpos = move_in_dir(nextpos, north + dir)
        steps = steps + 1
        if steps >= level then
            steps = 0
            dir = (dir + 60) % 360
            if dir == 120 then
                nextpos = move_in_dir(nextpos, north)
                level = level + 1
            end
        end
        return thispos
    end
end

function move_in_dir(start, dir)
    return {x = start.x + math.sin(math.rad(dir)) * tile_diameter, y = start.y, z = start.z + math.cos(math.rad(dir)) * tile_diameter}
end

function placed_tiles_iterator()
    local mecatol = getObjectFromGUID(mecatol_guid)

    if mecatol == nil then
        broadcastToAll("Unable to find Mecatol Rex, ensure that it has not been deleted and that it is at the center of the table.")
        return nil
    end

    local hex_itr = spiral_hex_iterator(mecatol.getPosition(), mecatol.getRotation())
    return function()
        local hexpos = hex_itr()
        for g, info in pairs(tiles_by_guid) do
            local obj = getObjectFromGUID(g)
            if obj ~= nil then
                local objpos = obj.getPosition()
                if (math.abs(objpos.x - hexpos.x) < tile_radius) and (math.abs(objpos.z - hexpos.z) < tile_radius) then
                    return {obj = obj, info = info}
                end
            end
        end
        return nil
    end
end

function drawAuto()
    local function isZoneHelper2()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'TI4_ZONE_HELPER' then
                return object.getVar('drawBordersVectorLines') and true
            end
        end
    end

    if isZoneHelper2() then
        _zoneHelper.drawBordersVectorLines({})
    else
        local lines = {}
        local _thickness = 0.1
        for _, color in ipairs(_zoneHelper.zones()) do
            table.insert(lines, {
                points = _zoneHelper.zoneBorder({
                    color = color,
                    inset = _thickness / 2.0,
                    clipToTable = true,
                }),
                color = color,
                thickness = _thickness,
                loop = true,
                square = true
            })
        end
        Global.setVectorLines(lines)
    end
end

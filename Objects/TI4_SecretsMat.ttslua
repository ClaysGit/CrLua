--- Snap secret objectives to grid.
-- @author Darrell

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local SNAP_POINTS = {
    PADDING = {  -- around edge of grid
        x = 0.5,
        z = 0.5
    },
    SPACING = {
        x = 2.5,
        z = 3.5
    },
    ROTATION = {
        x = 0,
        y = 180,
        z = 180
    },
    BOX_SIZE = {
        x = 0.5,
        z = 1
    }
}

-- Snap points are layed out in a 8x3 grid, [row][col] indexing.
local _snapPointsGrid = false

function onLoad(save_state)
    resetSnapPoints()
    drawSnapPoints()

    self.addContextMenuItem('Redraw boxes', drawSnapPoints, false)
end

function onPlayerTurnStart(player_color_start, player_color_previous)
    -- in case all lines are erased, redraw on turn start
    drawSnapPoints()
end

-- Helper "event" it triggers when changing player count.
function onSetupHelperPlayerCountChanged()
    drawSnapPoints()
end

function resetSnapPoints()
    local bounds = self.getBoundsNormalized()
    local scale = self.getScale()

    -- Create as many snap points as fit inside bounds.
    local numCols = math.floor(bounds.size.x / SNAP_POINTS.SPACING.x)
    local numRows = math.floor(bounds.size.z / SNAP_POINTS.SPACING.z)

    -- Compute spacing in local space.
    local size = {
        x = bounds.size.x / scale.x,
        z = bounds.size.z / scale.z
    }
    local spacing = {
        x = SNAP_POINTS.SPACING.x / scale.x,
        z = SNAP_POINTS.SPACING.z / scale.z,
    }
    local padding = {
        x = (size.x - (spacing.x * numCols)) / 2,
        z = (size.z - (spacing.z * numRows)) / 2,
    }

    local x0 = -(size.x / 2) + padding.x + (spacing.x / 2)
    local z0 = -(size.z / 2) + padding.z + (spacing.z / 2)
    local dx = spacing.x
    local dz = spacing.z

    local w = padding.x * 2 + numCols * spacing.x
    local h = padding.z * 2 + numRows * spacing.z

    --print('xxx ' .. w .. 'x' .. h .. ' vs scale ' .. size.x .. 'x' .. size.z)

    _snapPointsGrid = {}
    local allSnapPoints = {}
    for row = 0, numRows - 1 do
        local columnEntries = {}
        for col = 0, numCols - 1 do
            local snapPoint = {
                position = {
                    x = x0 + col * dx,
                    y = bounds.size.y,
                    z = z0 + row * dz
                },
                rotation = SNAP_POINTS.ROTATION,
                rotation_snap = true
            }
            table.insert(columnEntries, snapPoint)
            table.insert(allSnapPoints, snapPoint)
        end
        table.insert(_snapPointsGrid, columnEntries)
    end
    self.setSnapPoints(allSnapPoints)
end

function drawSnapPoints()
    local colIdxToColor = {}
    for i, color in ipairs(_zoneHelper and _zoneHelper.zones() or {}) do
        local rgba = Color.fromString(color)
        rgba.a = 0.67  -- blend a little
        colIdxToColor[i] = rgba
    end

    local thickness = 0.01
    local defaultColor = { r = 0.3, g = 0.3, b = 0.3 }

    local lines = {}
    local dx = SNAP_POINTS.BOX_SIZE.x / self.getScale().x
    local dz = SNAP_POINTS.BOX_SIZE.z / self.getScale().z

    for rowIdx, row in ipairs(_snapPointsGrid) do
        for colIdx, snapPoint in ipairs(row) do
            local p = assert(snapPoint.position)
            local y = p.y + 0.02
            table.insert(lines, {
                points = {
                    { x = p.x - dx, y = y, z = p.z - dz },
                    { x = p.x - dx, y = y, z = p.z + dz },
                    { x = p.x + dx, y = y, z = p.z + dz },
                    { x = p.x + dx, y = y, z = p.z - dz },
                },
                thickness = thickness,
                color = colIdxToColor[colIdx] or defaultColor,
                loop = true,
                square = true
            })
        end
    end
    self.setVectorLines(lines)
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)

-------------------------------------------------------------------------------
--- Draw a border around per-faction controlled map tiles.
-- @author Darrell
-- This was a feature request by "@Mr Smains" on the "help-support-requests"
-- Discord channel on 5/1/2020.
-------------------------------------------------------------------------------

local TAG = 'CrLua.Objects.ColorFactionMapTiles'

local _config = {
    enabled = true,
    show = {
        planet = false,
        ground = true,
        space = false,
    },
    thickness = {
        planet = 0.1,
        ground = 0.2,
        space = 0.1
    },
    padding = {
        planet = 0,
        ground = 0,
        space = 0.4
    },
    invisibleToSet = {}
}

local _cache = false
local _controlledViewObject = false

-------------------------------------------------------------------------------

function onLoad(saveState)
    CrLua.Log.d(TAG, 'onLoad: |data|=' .. (saveState and string.len(saveState) or -1))
    local success, value = pcall(function() return JSON.decode(saveState) end)
    if success then
        _config = value or _config
    end

    -- Use a second object with restricted visibility to affect who can see the lines.
    -- Do not restrict visibility on self, control panel is visible to all.
    local cvoName = self.getName() .. ' controlled view object'
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == cvoName then
            _controlledViewObject = object
            break
        end
    end
    if not _controlledViewObject then
        _controlledViewObject = spawnObject({
            type              = 'BlockSquare',
            position          = { x = 0, y = -10, z = 0 },
            sound             = false,
            snap_to_grid      = false,
        })
        _controlledViewObject.setName(cvoName)
        _controlledViewObject.setDescription('Restricts visibility to control who can see lines')
        _controlledViewObject.setLock(true)
        _controlledViewObject.interactable = false
    end

    Wait.frames(updateUiFromConfig, 10)

    -- Require manaul update to show again.  If something when HORRIBLY WRONG,
    -- do not jump into doing it again unless asked!
    --if _config.enabled then
    --    drawPolygons()
    --end
end

function onSave()
    local result = JSON.encode(_config)
    --CrLua.Log.d(TAG, 'onSave: |data|=' .. string.len(result))
    return result
end

-------------------------------------------------------------------------------

function onButtonClick(player, wha, id)
    if id == 'hide' then
        _config.enabled = false
        removePolygons()
    elseif id == 'update' then
        _config.enabled = true
        updateCache()
        drawPolygons()
    else
        error(TAG .. ': unknown button "' .. id .. '"')
    end
end

function onSliderValueChanged(player, value, id)
    local itemType, valueType = string.match(id, '(%l+)(%u%l+)Slider')
    local valueId = itemType .. valueType .. 'Value'

    local value = tonumber(value)
    local displayValue = math.floor(value * 100.0) / 10.0
    self.UI.setValue(valueId, displayValue)

    valueType = string.lower(valueType)
    assert(_config[valueType] and _config[valueType][itemType])

    _config[valueType][itemType] = value

    if _config.enabled then
        drawPolygons()
    end
end

function onToggleValueChanged(player, value, id)
    local valueAsBool = string.lower(value) == 'true' and true or false
    assert(type(valueAsBool) == 'boolean')
    if string.match(id, '^%l') then
        if id == 'planet' then
            _config.show.planet = valueAsBool or false
        elseif id == 'ground' then
            _config.show.ground = valueAsBool or false
        elseif id == 'space' then
            _config.show.space = valueAsBool or false
        else
            error(TAG .. ': unknown id "' .. id '"')
        end
    else -- uppercase means toggle color
        local found = false
        for _, color in ipairs(Player.getColors()) do
            if color == id then
                found = true
                break
            end
        end
        if not found then
            error(TAG .. ': unknown id "' .. id '"')
        end
        if not valueAsBool then
            _config.invisibleToSet[id] = true
        else
            _config.invisibleToSet[id] = nil
        end
    end

    if _config.enabled then
        drawPolygons()
    end
end

function updateUiFromConfig()
    self.UI.setAttribute('enabled', 'isOn', _config.enabled)
    for itemType, value in pairs(_config.show) do
        local id = itemType
        self.UI.setAttribute(id, 'isOn', value)
    end
    for itemType, value in pairs(_config.thickness) do
        local id = itemType .. 'ThicknessSlider'
        self.UI.setAttribute(id, 'value', value)
        local id = itemType .. 'ThicknessValue'
        local value = math.floor(tonumber(value) * 100) / 10
        self.UI.setValue(id, value)
    end
    for itemType, value in pairs(_config.padding) do
        local id = itemType .. 'PaddingSlider'
        self.UI.setAttribute(id, 'value', value)
        local id = itemType .. 'PaddingValue'
        local value = math.floor(tonumber(value) * 100) / 10
        self.UI.setValue(id, value)
    end
    for _, color in ipairs(Player.getColors()) do
        if not _config.invisibleToSet[color] then
            self.UI.setAttribute(color, 'isOn', true)
        end
    end
end

-------------------------------------------------------------------------------

function errorHex(hex, message)
    Global.setVectorLines({ CrLua.TI4.Hex.vectorLine(hex, { color = 'Red' }) })
    error(message)
end

-------------------------------------------------------------------------------

function updateCache()
    -- Keep the non-inset polygons to be able to rapidly adjust thickness.
    _cache = {
        originalPolygons = {
            planets = false,
            ground = false,
            space = false,
        },
        y = false
    }

    local hexToOwners = getSystemOwners()

    _cache.originalPolygons.planets = {}
    for hex, owners in pairs(hexToOwners) do
        for planetName, color in pairs(owners.planetName) do
            local line = CrLua.TI4.System.planetVectorLine(owners.system, planetName, {thickness = 0})
            local polygon = CrLua.Polygon.fromXYZ(line.points)
            table.insert(polygon, polygon[1])  -- loop
            table.insert(_cache.originalPolygons.planets, {
                color = color,
                polygon = polygon
            })
        end
    end

    _cache.originalPolygons.ground = {}
    _cache.originalPolygons.space = {}
    for _, zone in ipairs(CrLua.TI4.Zone.all()) do
        local color = assert(zone.color)
        local ownFullySet, ownPartialSet, ownSpaceSet = getOwned(hexToOwners, color)

        -- Control ground, with partial hexes.
        local polygons = getControlPolygons(ownFullySet, ownPartialSet)
        for _, polygon in ipairs(polygons) do
            table.insert(_cache.originalPolygons.ground, {
                color = color,
                polygon = polygon
            })
        end

        -- Control space.
        local polygons = getControlPolygons(ownSpaceSet, false)
        for _, polygon in ipairs(polygons) do
            table.insert(_cache.originalPolygons.space, {
                color = color,
                polygon = polygon
            })
        end
    end

    -- Get a world Y value from CrLua.TI4.System.
    local y = CrLua.TI4.System.LOCAL_Y
    local system = CrLua.TI4.System.fromPosition({ x = 0, y = 0, z = 0 })
    assert(system and system.object)
    local position = system.object.positionToWorld({ x = 0, y = y, z = 0 })
    _cache.y = position.y
end

function removePolygons()
    _controlledViewObject.setVectorLines()
    _cache = false
end

function drawPolygons()
    if not _cache then
        updateCache()
    end
    assert(_cache and _cache.originalPolygons)
    local y = assert(_cache.y)

    local lines = {}
    local function addLine(polygon, inset, thickness, color)
        local a = polygon[1]
        local b = polygon[#polygon]
        local loop = almostEqual(a, b)
        if loop then
            table.remove(polygon)
        end
        if #polygon > 2 then
            local polygon = CrLua.Polygon.inset(polygon, inset)
            local points = CrLua.Polygon.toXYZ(polygon, y)
            for i, point in ipairs(points) do
                points[i] = _controlledViewObject.positionToLocal(point)
            end
            table.insert(lines, {
                points = points,
                thickness = thickness,
                color = color,
                square = true,
                loop = loop
            })
        end
    end

    if _config.show.planet then
        for _, entry in ipairs(_cache.originalPolygons.planets) do
            local thickness = _config.thickness.planet
            local inset = thickness / 2.0 + _config.padding.planet
            addLine(entry.polygon, inset, thickness, entry.color)
        end
    end
    if _config.show.ground then
        for _, entry in ipairs(_cache.originalPolygons.ground) do
            local thickness = _config.thickness.ground
            local inset = thickness / 2.0 + _config.padding.ground
            addLine(entry.polygon, inset, thickness, entry.color)
        end
    end
    if _config.show.space then
        for _, entry in ipairs(_cache.originalPolygons.space) do
            local thickness = _config.thickness.space
            local inset = thickness / 2.0 + _config.padding.space
            addLine(entry.polygon, inset, thickness, entry.color)
        end
    end

    local invisibleToList = CrLua.List.fromKeys(_config.invisibleToSet)
    _controlledViewObject.setInvisibleTo(invisibleToList)
    _controlledViewObject.setVectorLines(lines)
end

-------------------------------------------------------------------------------

--- Get owner tokens.
-- Results have {color,hex,system,planet fields.}
function getOwnerTokens()
    -- Map from token faction to color.
    local tokenFactionColor = {}
    local zones = CrLua.TI4.Zone.all()
    for _, zone in ipairs(zones) do
        if zone.tokenFaction and zone.color then
            tokenFactionColor[zone.tokenFaction] = zone.color
        end
    end

    local result = {}
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        local tokenFaction = string.match(name, '^(.*) Owner Token$')
        if tokenFaction and tokenFactionColor[tokenFaction] then
            table.insert(result, {
                ownerToken = true,
                object = object,
                color = tokenFactionColor[tokenFaction],
            })
        end
    end
    return result
end

--- Get map from hex to list of {object, color, hex, system, ground, planet} tables.
function getAllUnitsAndOwnerTokens()
    -- Map from hex to system.
    local hexToSystem = {}
    for _, system in ipairs(CrLua.TI4.System.getAllSystems()) do
        local hex = CrLua.TI4.Hex.fromPosition(system.object.getPosition())
        hexToSystem[hex] = assert(not hexToSystem[hex]) and system
    end

    -- Get all relevant things.
    local units = CrLua.TI4.Unit.getAllUnits()
    local ownerTokens = getOwnerTokens()
    local things = CrLua.List.join(units, ownerTokens)

    -- It is possible orphaned tokens are on the board (someone forgot to
    -- place plastic?).  Ignore those (fixes MrSmains bug report).
    local function hasColor(thing)
        return type(thing.color) == 'string'
    end
    things = CrLua.List.filter(things, hasColor)

    -- Add hex, system, and ground, planet.
    local hexToThings = {}
    for _, thing in ipairs(things) do
        if type(thing.object) ~= 'userdata' then
            error(TAG .. ': thing.object is unexpected type "' .. type(thing.object))
        end
        if type(thing.color) ~= 'string' then
            error(TAG .. ': thing.color is unexpected type "' .. type(thing.color))
        end
        local position = thing.object.getPosition()
        thing.hex = CrLua.TI4.Hex.fromPosition(position)
        thing.system = hexToSystem[thing.hex]

        if thing.ownerToken then
            thing.ground = true
        else
            local attributes = CrLua.TI4.Unit.attributes(thing)
            if attributes[CrLua.TI4.Unit.ATTR.GROUND] or attributes[CrLua.TI4.Unit.ATTR.STRUCTURE] then
                thing.ground = true
            end
        end

        thing.planetName = thing.system and thing.ground and CrLua.TI4.System.planetFromPosition(thing.system, position, true)

        -- Keep all things in space, plus any ground units/owner tokens on planets.
        if thing.system and (not thing.ground or thing.planetName) then
            local entry = hexToThings[thing.hex]
            if not entry then
                entry = {}
                hexToThings[thing.hex] = entry
            end
            table.insert(entry, thing)
        end
    end

    return hexToThings
end

--- Get a map from hex to owner table with {ground, space, planetName[]} owners.
-- If planets are split between different players do not assign ground owner.
-- If any planet is not owned, do not assign ground owner.
function getSystemOwners()
    local hexToThings = getAllUnitsAndOwnerTokens()
    local hexToOwners = {}
    for hex, things in pairs(hexToThings) do
        for _, thing in ipairs(things) do
            local owners = hexToOwners[hex]
            if not owners then
                owners = {
                    system = assert(thing.system),
                    planetName = {}
                }
                hexToOwners[hex] = owners
            end

            assert(thing.color and thing.system)

            -- Wholely owned ground/space.
            if thing.ground then
                if owners.ground == nil then
                    owners.ground = thing.color
                elseif owners.ground ~= thing.color then
                    owners.ground = false
                end
            else
                if owners.space == nil then
                    owners.space = thing.color
                elseif owners.space ~= thing.color then
                    errorHex(hex, TAG .. ': more than one space color in tile ' .. thing.system.tile)
                end
            end

            -- Per-planet.
            if thing.ground then
                if owners.planetName[thing.planetName] and owners.planetName[thing.planetName] ~= thing.color then
                    errorHex(hex, TAG .. ': more than one ground color on ' .. thing.planetName .. ' tile ' .. thing.system.tile)
                end
                owners.planetName[thing.planetName] = thing.color
            end
        end
    end

    -- Remove ground owner if any planet is not owned.
    for hex, owners in pairs(hexToOwners) do
        local system = assert(owners.system)
        for _, planet in ipairs(system.planets or {}) do
            if not owners.planetName[planet.name] then
                owners.ground = false
                break
            end
        end
    end

    return hexToOwners
end

--- Get the hexes fully owned, partially owned, and space owned.
function getOwned(hexToOwners, color)
    local ownFullySet = {}
    local ownPartialSet = {}
    local ownSpaceSet = {}
    for hex, owners in pairs(hexToOwners) do
        if owners.ground == color then
            ownFullySet[hex] = true
        else
            for planetName, planetOwner in pairs(owners.planetName) do
                if planetOwner == color then
                    local entry = ownPartialSet[hex]
                    if not entry then
                        entry = {
                            system = assert(owners.system),
                            planetNames = {}
                        }
                        ownPartialSet[hex] = entry
                    end
                    table.insert(entry.planetNames, assert(planetName))
                end
            end
        end
        if owners.space == color then
            ownSpaceSet[hex] = true
        end
    end
    return ownFullySet, ownPartialSet, ownSpaceSet
end

-------------------------------------------------------------------------------

function almostEqual(a, b, epsilon)
    local dx = math.abs((a.x or a[1]) - (b.x or b[1]))
    local dz = math.abs((a.z or a[2]) - (b.z or b[2]))
    return dx < (epsilon or 0.01) and dz < (epsilon or 0.01)
end

function edge(hex1, hex2)
    assert(type(hex1) == 'string' and type(hex2) == 'string')
    return hex1 .. hex2
end

function reverseNeighborIndex(forwardIndex)
    return (((forwardIndex - 1) + 3) % 6) + 1
end

-- Get map from edge to points.
function getControlEdges(hexSet)
    assert(type(hexSet) == 'table')
    local edgeSet = {}
    for hex, _ in pairs(hexSet) do
        for _, neighbor in ipairs(CrLua.TI4.Hex.neighbors(hex)) do
            if not hexSet[neighbor] then
                edgeSet[edge(hex, neighbor)] = CrLua.TI4.Hex.commonEdge(hex, neighbor)
            end
        end
    end
    return edgeSet
end

-- Mutate edges to flow into partially owned hexes.
function applyPartialControlEdges(edgeSet, partialHexSet)
    assert(type(edgeSet) == 'table' and type(partialHexSet) == 'table')

    for partialHex, partial in pairs(partialHexSet) do

        local system = assert(partial.system)
        if #system.planets == 2 then
            -- Get zone points and planet location.
            assert(#partial.planetNames == 1)
            local planetName = assert(partial.planetNames[1])
            local planetPosition = CrLua.TI4.System.planetToPosition(system, planetName)
            local zonePoints = CrLua.TI4.System.zoneEdgePositions(system)
            assert(#zonePoints == 2)

            -- Replace any neighbor's edges?
            local neighbors = CrLua.TI4.Hex.neighbors(partialHex)
            for i, hex in ipairs(neighbors) do

                -- Get midpoint of the common edge (and points in wind order wrt neighbor).
                local a1, a2 = table.unpack(CrLua.TI4.Hex.commonEdge(hex, partialHex))
                local aMidpoint = { x = (a1.x + a2.x) / 2, y = (a1.y + a2.y) / 2, z = (a1.z + a2.z) / 2 }
                local aIsZonePoint1 = almostEqual(aMidpoint, zonePoints[1], 1)

                -- Get midpoint of the opposite edge (a,b in winding order).
                local farHex = neighbors[reverseNeighborIndex(i)]
                local b1, b2 = table.unpack(CrLua.TI4.Hex.commonEdge(farHex, partialHex))
                local bMidpoint = { x = (b1.x + b2.x) / 2, y = (b1.y + b2.y) / 2, z = (b1.z + b2.z) / 2 }
                local bIsZonePoint1 = almostEqual(bMidpoint, zonePoints[1], 1)

                -- Is the owned planet on "this side" of the system?
                local thisSide
                if aIsZonePoint1 or bIsZonePoint1 then
                    local d1 = CrLua.Util.distanceSq(a1, planetPosition)
                    local d2 = CrLua.Util.distanceSq(a2, planetPosition)
                    thisSide = d1 < d2
                else
                    local d1 = CrLua.Util.distanceSq(aMidpoint, planetPosition)
                    local d2 = CrLua.Util.distanceSq(bMidpoint, planetPosition)
                    thisSide = d1 < d2
                end

                -- Is there an existing edge?
                local partialEdge = edge(partialHex, hex)
                local reverseEdge = edge(hex, partialHex)
                local existingEdge = edgeSet[reverseEdge]

                -- If this edge midpoint is a zone border point, add or replace
                -- with a partial edge.  Only cross mid for one direction.
                if aIsZonePoint1 then

                    if existingEdge then
                        if thisSide then
                            edgeSet[reverseEdge] = { bMidpoint, aMidpoint, a2 }
                        else
                            edgeSet[reverseEdge] = { a1, aMidpoint, bMidpoint }
                        end
                    else
                        if thisSide then
                            edgeSet[partialEdge] = { bMidpoint, aMidpoint, a1 }
                        else
                            edgeSet[partialEdge] = { a2, aMidpoint, bMidpoint }
                        end
                    end

                elseif bIsZonePoint1 then

                    if existingEdge then
                        if thisSide then
                            edgeSet[reverseEdge] = { aMidpoint, a2 }
                        else
                            edgeSet[reverseEdge] = { a1, aMidpoint }
                        end
                    else
                        if thisSide then
                            edgeSet[partialEdge] = { aMidpoint, a1 }
                        else
                            edgeSet[partialEdge] = { a2, aMidpoint }
                        end
                    end

                elseif thisSide and existingEdge then

                    -- This edge connects to the partial control area.  Remove.
                    edgeSet[reverseEdge] = nil

                elseif thisSide then

                    -- No edge but partial control area.  Add edge.
                    edgeSet[partialEdge] = { a2, a1 }

                end
            end

        elseif #system.planets == 3 then

            local ownedPlanetNameSet = {}
            for i, planet in ipairs(system.planets) do
                for _, planetName in ipairs(partial.planetNames) do
                    ownedPlanetNameSet[planetName] = true
                end
            end

            local zonePoints = CrLua.TI4.System.zoneEdgePositions(system)
            assert(#zonePoints == 3)
            local function isZonePoint(position)
                for i, zonePoint in ipairs(zonePoints) do
                    if almostEqual(position, zonePoint, 1) then
                        return i
                    end
                end
            end

            for _, hex in ipairs(CrLua.TI4.Hex.neighbors(partialHex)) do
                local partialEdge = edge(partialHex, hex)
                local reverseEdge = edge(hex, partialHex)
                local existingEdge = edgeSet[reverseEdge]

                local a1, a2 = table.unpack(CrLua.TI4.Hex.commonEdge(hex, partialHex))
                local aMidpoint = { x = (a1.x + a2.x) / 2, y = (a1.y + a2.y) / 2, z = (a1.z + a2.z) / 2 }
                local function planetDistance(planet)
                    local position = CrLua.TI4.System.planetToPosition(system, planet.name)
                    return CrLua.Util.distanceSq(position, aMidpoint)
                end
                local _, closestPlanet = CrLua.Util.min(system.planets, planetDistance)
                local ownZone = ownedPlanetNameSet[closestPlanet.name]

                local zoneIndex = false
                for i, planet in ipairs(system.planets) do
                    if planet.name == closestPlanet.name then
                        zoneIndex = i
                    end
                end
                assert(zoneIndex)
                local prevPlanetName = system.planets[zoneIndex == 1 and 3 or zoneIndex - 1].name
                local nextPlanetName = system.planets[zoneIndex == 3 and 1 or zoneIndex + 1].name
                local ownPrev = ownedPlanetNameSet[prevPlanetName]
                local ownNext = ownedPlanetNameSet[nextPlanetName]

                --[[
                CrLua.Log.d(TAG, table.concat({
                    'closest=' .. closestPlanet.name .. '/' .. tostring(ownZone),
                    'prev=' .. prevPlanetName .. '/' .. tostring(ownPrev),
                    'next=' .. nextPlanetName .. '/' .. tostring(ownNext),
                }, ', '))
                --]]

                if existingEdge and ownZone then
                    if isZonePoint(a1) then
                        if ownNext then
                            edgeSet[reverseEdge] = nil
                        else
                            edgeSet[reverseEdge] = { a1, systemPosition }
                        end
                    elseif isZonePoint(a2) then
                        if ownPrev then
                            edgeSet[reverseEdge] = nil
                        else
                            edgeSet[reverseEdge] = { systemPosition, a2 }
                        end
                    else
                        error('neither edge endpoint is a zone point?')
                    end
                end

                if not existingEdge and ownZone then
                    if isZonePoint(a1) then
                        if ownNext then
                            edgeSet[partialEdge] = { a2, a1 }
                        else
                            edgeSet[partialEdge] = { a2, a1, system.object.getPosition() }
                        end
                    elseif isZonePoint(a2) then
                        if ownPrev then
                            edgeSet[partialEdge] = { a2, a1 }
                        else
                            edgeSet[partialEdge] = { system.object.getPosition(), a2, a1 }
                        end
                    else
                        error('neither edge endpoint is a zone point?')
                    end
                end
            end

        end

    end
end

--- Get one polygon from a collection of hexes, removing edges as it goes.
-- The set may still have entries when finished meaning there is at least one
-- more disconnected polygon to find.
function getControlPolygon(hexSet, edgeSet)
    assert(type(hexSet) == 'table' and type(edgeSet) == 'table')
    --CrLua.Log.d(TAG, 'getControlPolygon: |edgeSet|=' .. #CrLua.List.fromKeys(edgeSet))

    local polygon = false
    local function addEdge(key, points)
        assert(edgeSet[key])
        edgeSet[key] = nil
        polygon = polygon or {{ points[1].x, points[1].z }}
        assert(almostEqual(polygon[#polygon], points[1]))  -- always extend from last
        for i = 2, #points do
            table.insert(polygon, { points[i].x, points[i].z })
        end
    end

    local function getStartingEdge()
        for k, points in pairs(edgeSet) do
            addEdge(k, points)
            return true
        end
        return false
    end
    if not getStartingEdge() then
        CrLua.Log.d(TAG, 'getControlPolygon: getStartedEdge failed')
        return false
    end

    -- Connect forward.
    local connected = false
    repeat
        local connect = polygon[#polygon]
        connected = false
        for k, points in pairs(edgeSet) do
            if almostEqual(connect, points[1]) then
                addEdge(k, points)
                connected = true
                break
            end
        end
    until not connected

    -- Connect backward (should not happen if getting closed polygons).
    repeat
        local connect = polygon[1]
        connected = false
        for k, points in pairs(edgeSet) do
            if almostEqual(connect, points[#points]) then
                edgeSet[k] = nil
                for i = #points - 1, 1, -1 do
                    table.insert(polygon, 1, { points[i].x, points[i].z })
                end
                connected = true
                break
            end
        end
    until not connected

    -- The last point should always be the same as the first.  Remove last.
    local a = polygon[1]
    local b = polygon[#polygon]
    if not almostEqual(a, b) then
        --error('last ~= first')
    end

    --CrLua.Log.d(TAG, 'getControlPolygon: |polygon|=' .. #polygon)
    if #polygon <= 2 then
        --error('#polygon=' .. #polygon)
        return false
    end
    return polygon
end

function getControlPolygons(hexSet, partialSet)
    local function isEmptySet(set)
        for _, _ in pairs(set) do
            return false
        end
        return true
    end

    local edgeSet = getControlEdges(hexSet)
    if partialSet then
        applyPartialControlEdges(edgeSet, partialSet)
    end

    local polygons = {}
    while not isEmptySet(edgeSet) do
        local polygon = getControlPolygon(hexSet, edgeSet)
        if polygon then
            table.insert(polygons, polygon)
        else
            break
        end
    end
    return polygons
end

-------------------------------------------------------------------------------

#include <~/CrLua/CrLua>
#include <~/CrLua/LockGlobals>

#include <~/CrLua/TI4/Hex>
#include <~/CrLua/TI4/System>
#include <~/CrLua/TI4/Unit>
#include <~/CrLua/TI4/Zone>

#include <~/CrLua/List>
#include <~/CrLua/LockTable>
#include <~/CrLua/Log>
#include <~/CrLua/Polygon>
#include <~/CrLua/RedBlobHex>
#include <~/CrLua/Table>
#include <~/CrLua/Util>

--CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
--#include <~/CrLua/UnitTest>
--CrLua.UnitTest.runTests(TAG, CrLua, true)

CrLua.assertRequired({ 'TI4.Hex', 'TI4.System', 'TI4.Unit', 'List', 'Log' })
CrLua.lock()

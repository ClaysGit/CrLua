--- TI4 Graveyard bag v3.0, move objects inserted into this bag to correct locations.
-- @author original by Mantis
-- @author card handling by GarnetBear
-- @author May 2020 update by Darrell
-- @author v3 May 2020 update by Darrell
--
-- v3.1: safer transition when two cards forming a deck, and vice versa.
-- v3.2: wait for TTS before moving to final destination in order to preserve guid.
-- v3.3 [August 2020]: migrate to deck helper.

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')

-- Token bags use inconsistent name to bag, hard code for simplicity.
local TOKEN_BAGS = {
    ['x1 Fighter Token'] = 'x1 Fighters Tokens Bag',
    ['x3 Fighter Token'] = 'x3 Fighters Tokens Bag',
    ['x1 Infantry'] = 'x1 Infantry Token Bag',
    ['x3 Infantry'] = 'x3 Infantry Token Bag',
    ['Commodities/Tradegoods x1'] = 'Commodities/Tradegoods x1 Bag',
    ['Commodities/Tradegoods x3'] = 'Commodities/Tradegoods x3 Bag'
}

-- Bag with faction tokens.
local PICK_FACTION_BAG = 'Pick a Faction to Play'

-------------------------------------------------------------------------------

local data = {
    objectNameToBagGuid = {},
    pickFactionTokenBagGuid = nil,

    objects = {
        -- Objects added to graveyard deemed worth processing.
        waitingForDestroy = {},

        -- When an object from waitingForDestroy gets destroyed, move here.
        ready = {},
    },

    coroutineStartTime = false,
}

-------------------------------------------------------------------------------

--- Get bag for object.
local function getNonCardDestination(objectName)
    assert(type(objectName) == 'string')

    local bagGuid = data.objectNameToBagGuid[objectName]
    local bag = bagGuid and getObjectFromGUID(bagGuid)

    -- If we do not have a bag, look for one and remember it if found.  If more
    -- than one choose closest (reduces objects from flying over the table).
    -- Remember via guid to prevent trying to access a deleted bag later.
    -- Do not store "nacks" for objects with no bag, it could be unpacked!
    if not bag and string.len(objectName) > 0 then
        local acceptBag = {
            [objectName] = true,
            [objectName .. 's Bag'] = true,
            [TOKEN_BAGS[objectName] or false] = true
        }
        local bestDistance = false
        for _, candidate in ipairs(getAllObjects()) do
            local tag = candidate.tag
            local name = candidate.getName()
            if (tag == 'Bag' or tag == 'Infinite') and acceptBag[name] then
                local p1 = self.getPosition()
                local p2 = candidate.getPosition()
                local dSq = ((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
                if not bestDistance or dSq < bestDistance then
                    bag = candidate
                    bestDistance = dSq
                end
            end
        end
        data.objectNameToBagGuid[objectName] = bag and bag.getGUID()
    end

    -- If "FACTION Owner Token" and no bag, put in the "Pick a Faction to Play"
    -- bag (scan again to make earlier, more common scan do less work).
    local faction = (not bag) and _factionHelper.fromTokenName(objectName)
    print('xxx ' .. objectName .. ' ' .. (faction and faction.name or '-'))
    if not bag and faction then
        local bagGuid = data.pickFactionTokenBagGuid
        bag = bagGuid and getObjectFromGUID(bagGuid)
        if not bag then
            for _, candidate in ipairs(getAllObjects()) do
                if candidate.getName() == PICK_FACTION_BAG then
                    bag = candidate
                    break
                end
            end
        end
        data.pickFactionTokenBagGuid = bag and bag.getGUID()
    end

    return bag
end

-------------------------------------------------------------------------------

function onObjectEnterContainer(container, enterObject)
    if container == self then

        -- Take note of an object we want to move once TTS finishes destroy.
        local function waitForDestroy(object, state)
            data.objects.waitingForDestroy[object] = {
                guid = object.guid,
                name = object.getName(),
                state = state
            }
        end

        local discardParams = {
            guid = enterObject.getGUID(),
            name = enterObject.getName(),
            containerGuid = self.getGUID(),
            waitForDestroy = true,
        }

        if enterObject.tag == 'Card' and _deckHelper.discardCard(discardParams) then
            -- deck helper is handling it.
        elseif enterObject.tag == 'Deck' and _deckHelper.discardDeck(discardParams) then
            -- deck helper is handling it.
        else
            local bag = getNonCardDestination(enterObject.getName())
            if bag then
                waitForDestroy(enterObject, bag)
            end
        end
    end
end

function onObjectDestroy(dyingObject)
    local objectData = data.objects.waitingForDestroy[dyingObject]
    if objectData then
        -- Promote to ready.
        data.objects.waitingForDestroy[dyingObject] = nil
        table.insert(data.objects.ready, objectData)

        -- Start coroutine if work to be done.
        local isRunning = data.coroutineStartTime and (Time.time - data.coroutineStartTime) < 3
        if #data.objects.ready > 0 and not isRunning then
            startLuaCoroutine(self, 'processReadyCoroutine')
            data.coroutineStartTime = Time.time
        end
    end
end

function processReadyCoroutine()
    -- Coroutine started on object's last frame (during onObjectDestroy).
    -- Wait one more frame for TTS to reclaim it, so we can retrieve it from
    -- self preserving the same GUID.
    coroutine.yield(0)

    while #data.objects.ready > 0 do
        local objectData = table.remove(data.objects.ready)

        -- Be paranoid about guid collisions.  Unlikely but not impossible.
        local function getObjectIndex()
            for _, entry in ipairs(self.getObjects()) do
                if entry.guid == objectData.guid and entry.name == objectData.name then
                    return entry.index
                end
            end
            -- When an entry does not have a name, TTS uses the tag (it seems).
            -- If we did not find a guid AND name match, try guid only.
            for _, entry in ipairs(self.getObjects()) do
                if entry.guid == objectData.guid then
                    return entry.index
                end
            end
            error(self.getName() .. ': missing entry')
        end

        local position = self.getPosition()
        local object = self.takeObject({
            index = getObjectIndex(),
            position = { x = position.x, y = position.y + 10, z = position.z }
        })
        assert(object)

        -- Wait a frame after takeObject before put so the leave/enter
        -- events happen in logical order.
        object.setLock(true)
        coroutine.yield(0)
        object.setLock(false)

        object.setRotation(objectData.state.getRotation()) -- rotate to match bag
        objectData.state.putObject(object)
    end

    -- Finished.  RETURN 1 TO STOP COROUTINE!
    data.coroutineStartTime = false
    return 1
end

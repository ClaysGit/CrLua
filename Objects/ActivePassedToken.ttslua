--- Active/passed token.
-- @author bonkersbgg at boardgamegeek.com
--
-- Place one token near each player, each token assigns itself to the closest
-- seated player.
--
-- When flipped to "passed" the token will automatically skip that player's
-- turn, broadcasting to all players that player has passed.
--
-- Once all players have passed, the token disables turns (via Turns.enable)
-- and all tokens flip back to active.

-- Utility functions, defined at end.
local CrLua = {}

local data = {
    -- This token belongs to which seated player (string).
    ownerPlayerColor = nil,

    -- Reset when turns get enabled again (boolean).
    needsReset = false,

    -- Use TI4 zone, or seated player locations to assign color?
    -- (Initially nil, set to true or false to choose TI4 zone or seat location.)
    useTI4Zones = nil,
}

-------------------------------------------------------------------------------
-- OBJECT EVENT METHODS

function onLoad()
    CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.NONE)
    CrLua.Log.d('onLoad')
end

function onDrop(playerColor)
    resetTokenForNewOwner()
end

function onPlayerChangeColor(playerColor)
    resetTokenForNewOwner()
end

function onPlayerTurnStart(playerColorStart, playerColorPrevious)
    CrLua.Log.d('onPlayerTurnStart ' .. playerColorStart)

    -- If not yet assigned to a player, do so now.
    if not data.ownerPlayerColor then
        resetTokenForNewOwner()
    end

    -- Do not manipulate any Turns state now, let all objects process the
    -- same turn start values and maybe pass the turn after a few frames.
    if isMyTurn() then
        Wait.frames(maybePassTurn, 2)
    end
end

-------------------------------------------------------------------------------

--- Is this object an Active/Passed token?
-- @return boolean true if peer.
function isPeer(object)
    return object.getName() == self.getName()
end

--- Get all Active/Passed tokens on the board.
-- @param includeSelf boolean include this object too?
-- @return table list of objects
function getPeers(includeSelf)
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if isPeer(object) and (object ~= self or includeSelf) then
            table.insert(result, object)
        end
    end
    CrLua.Log.d('getPeers: found ' .. #result .. ' peers')
    return result
end

--- Make sure each player is in the list without repeats.
-- @return boolean true if all players have one token.
function sanityCheckPeersWithIncludeSelf(peers)
    local result = true
    local colorCount = {}
    for _, peer in ipairs(peers) do
        local color = playerColorAtPosition(peer.getPosition())
        if color then
            colorCount[color] = (colorCount[color] or 0) + 1
        end
    end
    for color, count in pairs(colorCount) do
        if count > 1 then
            result = false
            local player = Player[color]
            local name = (player and player.steam_name) or color
            printToAll('Warning: player ' .. name .. ' has multiple active/passed tokens', color)
        end
    end
    local seated = getSeatedPlayers()
    for _, color in ipairs(seated) do
        if not colorCount[color] then
            result = false
            local player = Player[color]
            local name = (player and player.steam_name) or color
            printToAll('Warning: player ' .. name .. ' does not have an active/passed token', color)
        end
    end
    return result
end

--- Is this token showing "active"?
-- @return boolean true if active.
function isActive()
    local result = not self.is_face_down
    CrLua.Log.d('isActive -> ' .. tostring(result))
    return result
end

--- Is any active/passed token still active?
-- @param peers list of active/passed token objects.
-- @return boolean true if any is active.
function anyPeerIsActive(peers)
    local result = false
    for _, peer in ipairs(peers) do
        if not peer.is_face_down then
            result = true
            break
        end
    end
    CrLua.Log.d('anyPeerActive -> ' .. tostring(result))
    return result
end

function resetPeersWithIncludeSelf(peers)
    for _, peer in ipairs(peers) do
        peer.flip()
    end
end

--- Is the current turn the player who owns this token?
-- @return boolean true if my turn.
function isMyTurn()
    local result = Turns.enable and Turns.turn_color == data.ownerPlayerColor
    CrLua.Log.d('isMyTurn -> ' .. tostring(result))
    return result
end

-------------------------------------------------------------------------------

--- Assign this to the closest seated player.
-- Also tints the side of the token for a visual confirmation.
function resetTokenForNewOwner()
    local playerColor = playerColorAtPosition(self.getPosition())

    if playerColor == data.ownerPlayerColor then
        return
    end

    CrLua.Log.d('resetTokenForNewOwner ' .. (playerColor or '<nil>'))
    data.ownerPlayerColor = playerColor
    self.setColorTint(data.ownerPlayerColor or 'Grey')
end

--- Pass turn if this token is set to "passed".  If all tokens are set to
-- "passed" then disable turns altogether, requiring turns be re-enabled
-- via some external means to proceed.
-- @return boolean true if passed turn.
function maybePassTurn()
    -- Out of paranoia make sure it is still this token owner's turn.
    -- It is possible some other script changed turns while this function
    -- was waiting to be called, or in some cases such as hot-seat games
    -- it appears TTS calls onPlayerTurnStart twice each turn.
    if not isMyTurn() then
        CrLua.Log.d('maybePassTurn: not my turn, aborting')
        return false
    end

    -- Make sure everyone has exactly one active/passed token.
    local peers = getPeers(true)
    local sanityCheck = sanityCheckPeersWithIncludeSelf(peers)

    -- Do nothing if still active (play normally).
    if isActive() then
        CrLua.Log.d('maybePassTurn: still active, aborting')
        return false
    end

    -- At this point we know it is "my" turn and the token is set to "passed".
    -- Pass this turn, or if all players have passed disable turns altogether.
    -- (Requires external event to re-enable turns.)
    -- Note: if the sanity check failed then there is not one token per player.
    -- In that case, continue to pass turns but do not consider "all" passed.
    if anyPeerIsActive(peers) or not sanityCheck then
        CrLua.Log.d('maybePassTurn: at least one active peer, passing turn')
        local player = Player[data.ownerPlayerColor]
        local name = (player and player.steam_name) or data.ownerPlayerColor
        broadcastToAll('Player ' .. name .. ' passed.', data.ownerPlayerColor)
        Turns.turn_color = Turns.getNextTurnColor()
    else
        CrLua.Log.d('maybePassTurn: no active peers, disabling turns')
        broadcastToAll('All players have passed.', data.ownerPlayerColor)
        resetPeersWithIncludeSelf(peers)
        Turns.enable = false
    end
    return true
end

-------------------------------------------------------------------------------

--- Get player for the given table position.
-- @param position table : {x,y,z} table.
-- @return color string : player at postition, or nil if none.
function playerColorAtPosition(position)
    -- Detect and apply TI4 zones (cache for later use).
    if data.useTI4Zones == nil then
        local updatedZones = CrLua.TI4.Zone.updateZoneColors()
        data.useTI4Zones = (updatedZones and true) or false
        CrLua.Log.d('useTI4Zones=' .. tostring(data.useTI4Zones))
    end

    -- If we have TI4 zones, use them.  Otherwise use closest seated player.
    -- With TI4 zones, it is possible a token is not in any player's zone!
    local playerColor
    if data.useTI4Zones then
        local zone = CrLua.TI4.Zone.insideWhichPlayerZone(position)
        playerColor = zone and CrLua.TI4.Zone.color(zone)
    else
        playerColor = CrLua.TTS.closestPlayer(position)
    end
    CrLua.Log.d('playerColorAtPosition -> ' .. (playerColor or '<nil>'))
    return playerColor
end

-------------------------------------------------------------------------------

#include ~/CrLua/Log
#include ~/CrLua/TTS
#include ~/CrLua/TI4/Zone
#include ~/CrLua/LockGlobals

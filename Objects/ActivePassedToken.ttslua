--- Active/passed token.
-- @author bonkersbgg at boardgamegeek.com
--
-- Place one token near each player, each token assigns itself to the closest
-- seated player.
--
-- When flipped to "passed" the token will automatically skip that player's
-- turn, broadcasting to all players that player has passed.
--
-- Once all players have passed, the token disables turns (via Turns.enable)
-- and all tokens flip back to active.

local TAG = 'ActivePassedToken'

-------------------------------------------------------------------------------
-- OBJECT EVENT METHODS

function onLoad()
    -- If this is a copy/paste, reset name on new object.
    self.setName(defaultObjectName())
    CrLua.Log.d(TAG, 'onLoad "' .. (self.getName() or '') .. '"')
end

function onPlayerTurnStart(playerColorStart, playerColorPrevious)
    CrLua.Log.d(TAG, 'onPlayerTurnStart ' .. playerColorStart)

    -- If not yet assigned to a player, attempt to do so now.
    if not myColor() then
        resetTokenForNewOwner()
    end

    -- Do not manipulate any Turns state now, let all objects process the
    -- same turn start values and maybe pass the turn after a few frames.
    if isMyTurn() then
        Wait.frames(maybePassTurn, 2)
    end
end

-------------------------------------------------------------------------------

--- Get the color from an Active/Passed token object name.
-- @param name string : game Object name.
-- @return color string : color, or nil if not valid.
function objectNameToColor(name)
    -- All possible player colors (including "spectators").
    local validColorNames = {
        White = true, Brown = true, Red = true, Orange = true, Yellow = true,
        Green = true, Teal = true, Blue = true, Purple = true, Pink = true,
        Grey = true, Black = true
    }
    local color = string.match(name, '^Active/Passed %((%a+)%)$')
    return validColorNames[color] and color
end

--- Get an Active/Passed token object name for the given color.
function colorToObjectName(color)
    return string.format('Active/Passed (%s)', color or 'unassigned')
end

function defaultObjectName()
    return colorToObjectName()
end

function myColor()
    return objectNameToColor(self.getName())
end

-------------------------------------------------------------------------------

--- Is this object an Active/Passed token?
-- @param name string : peer game Object name.
-- @return boolean true if peer.
function isPeerName(name)
    local color = objectNameToColor(name)
    if color then
        CrLua.Log.d(TAG, 'isPeer found ' .. color)
    end
    return color and true
end

--- Get all Active/Passed tokens on the board.
-- @param includeSelf boolean include this object too?
-- @return table list of objects
function getPeers(includeSelf)
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if isPeerName(object.getName()) and (object ~= self or includeSelf) then
            table.insert(result, object)
        end
    end
    CrLua.Log.d(TAG, 'getPeers: found ' .. #result .. ' peers')
    return result
end

--- Make sure each player is in the list without repeats.
-- @return boolean true if all players have one token.
function sanityCheckPeersWithIncludeSelf(peers)
    local result = true
    local colorCount = {}
    for _, peer in ipairs(peers) do
        local color = objectNameToColor(peer.getName())
        if color then
            colorCount[color] = (colorCount[color] or 0) + 1
        end
    end
    for color, count in pairs(colorCount) do
        if count > 1 then
            result = false
            local player = Player[color]
            local name = (player and player.steam_name) or color
            printToAll('Warning: player ' .. name .. ' has multiple active/passed tokens', color)
        end
    end
    local seated = getSeatedPlayers()
    for _, color in ipairs(seated) do
        if not colorCount[color] then
            result = false
            local player = Player[color]
            local name = (player and player.steam_name) or color
            printToAll('Warning: player ' .. name .. ' does not have an active/passed token', color)
        end
    end
    return result
end

--- Is this token showing "active"?
-- @return boolean true if active.
function isActive()
    local result = not self.is_face_down
    CrLua.Log.d(TAG, 'isActive -> ' .. tostring(result))
    return result
end

--- Is any active/passed token still active?
-- @param peers list of active/passed token objects.
-- @return boolean true if any is active.
function anyPeerIsActive(peers)
    local result = false
    for _, peer in ipairs(peers) do
        if not peer.is_face_down then
            result = true
            break
        end
    end
    CrLua.Log.d(TAG, 'anyPeerActive -> ' .. tostring(result))
    return result
end

function resetPeersWithIncludeSelf(peers)
    for _, peer in ipairs(peers) do
        peer.flip()
    end
end

--- Is the current turn the player who owns this token?
-- @return boolean true if my turn.
function isMyTurn()
    local result = Turns.enable and Turns.turn_color == myColor()
    CrLua.Log.d(TAG, 'isMyTurn -> ' .. tostring(result))
    return result
end

-------------------------------------------------------------------------------

--- Assign this to the closest seated player.
-- Also tints the side of the token for a visual confirmation.
function resetTokenForNewOwner()
    local oldColor = myColor()
    local newColor = playerColorAtPosition(self.getPosition())
    if newColor == oldColor then
        return
    end

    -- Tint this object to indicate color.
    CrLua.Log.d(TAG, 'resetTokenForNewOwner ' .. (oldColor or '<nil>') .. ' -> ' .. (newColor or '<nil>'))
    self.setColorTint(newColor or 'Grey')

    -- Also rename self.
    local name = colorToObjectName(newColor)
    self.setName(name)
end

--- Pass turn if this token is set to "passed".  If all tokens are set to
-- "passed" then disable turns altogether, requiring turns be re-enabled
-- via some external means to proceed.
-- @return boolean true if passed turn.
function maybePassTurn()
    -- Out of paranoia make sure it is still this token owner's turn.
    -- It is possible some other script changed turns while this function
    -- was waiting to be called, or in some cases such as hot-seat games
    -- it appears TTS calls onPlayerTurnStart twice each turn.
    if not isMyTurn() then
        CrLua.Log.d(TAG, 'maybePassTurn: not my turn, aborting')
        return false
    end

    -- Make sure everyone has exactly one active/passed token.
    local peers = getPeers(true)
    local sanityCheck = sanityCheckPeersWithIncludeSelf(peers)

    -- Do nothing if still active (play normally).
    if isActive() then
        CrLua.Log.d(TAG, 'maybePassTurn: still active, aborting')
        return false
    end

    -- At this point we know it is "my" turn and the token is set to "passed".
    -- Pass this turn, or if all players have passed disable turns altogether.
    -- (Requires external event to re-enable turns.)
    -- Note: if the sanity check failed then there is not one token per player.
    -- In that case, continue to pass turns but do not consider "all" passed.
    local myColor = myColor()
    if anyPeerIsActive(peers) or not sanityCheck then
        CrLua.Log.d(TAG, 'maybePassTurn: at least one active peer, passing turn')
        local player = Player[myColor]
        local name = (player and player.steam_name) or myColor or '?'
        broadcastToAll('Player ' .. name .. ' passed.', myColor)
        Turns.turn_color = Turns.getNextTurnColor()
    else
        CrLua.Log.d(TAG, 'maybePassTurn: no active peers, disabling turns')
        broadcastToAll('All players have passed.', myColor)
        resetPeersWithIncludeSelf(peers)
        Turns.enable = false
    end
    return true
end

-------------------------------------------------------------------------------

--- Get player for the given table position.
-- @param position table : {x,y,z} table.
-- @return color string : player at postition, or nil if none.
function playerColorAtPosition(position)
    local playerColor = CrLua.TTS.Player.closest(position)
    CrLua.Log.d(TAG, 'playerColorAtPosition -> ' .. (playerColor or '<nil>'))
    return playerColor
end

-------------------------------------------------------------------------------

local patchConfig = {}
function doPatch()
    if not patchConfig then
        error(TAG .. ': already patched')
    end
    local originalPatchConfig = patchConfig
    patchConfig = false
    CrLua.TTS.Patch.patch(originalPatchConfig)
end

#include <~/CrLua/CrLua>
#include <~/CrLua/LockGlobals>

#include <~/CrLua/List>
#include <~/CrLua/LockTable>
#include <~/CrLua/Log>
#include <~/CrLua/Polygon>
#include <~/CrLua/Util>
#include <~/CrLua/TTS/Player>

--[[
#include <~/CrLua/UnitTest>
CrLua.UnitTest.runTests('CrLua', CrLua, true)
--]]

--<strip>--

#include <~/CrLua/Kruft/Spiral>
#include <~/CrLua/TTS/Patch>

-- Interpose on top of any onLoad function to do addional setup.
local originalOnLoad = onLoad
function onLoad(save_state)
    if originalOnLoad then
        originalOnLoad()
    end

    if true or self.getName() == 'Active/Passed Patcher' then

        local originalLogLevel = CrLua.Log.getLogLevel()
        --CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)

        CrLua.Log.d(TAG, 'adding patch button')
        self.createButton({
            click_function = 'doPatch',
            function_owner = self,
            label          = 'PATCH\nACTIVE/PASSED\nTOKENS',
            position       = { x = 0, y = 0.2, z = 0 },
            rotation       = nil, -- Vector,
            scale          = nil, -- Vector,
            width          = 1100, -- int,
            height         = 600, -- int,
            font_size      = 150, -- int,
            color          = nil, -- Color,
            font_color     = nil, -- Color,
            tooltip        = 'Locate and patch Active/Passed tokens to this version'
        })

        -- Replace the lua script in patched objects with this object's script,
        -- but first removing the between-strip-tags content.
        local patchedLua = self.getLuaScript()
        patchedLua = CrLua.TTS.Patch.stripFromLuaScript(patchedLua, 'strip')

        function patchConfig.shouldScanContainer(containerObjectData)
            local name = containerObjectData.name
            CrLua.Log.d(TAG, 'shouldScan: "' .. name .. '"')

            -- This config is specific to the standard TI4 module!
            if name == 'Variant Pieces (Searching Recommended)' then
                return true
            end
            if name == 'Frankenstein Bags' then
                return true
            end
            if string.match(name, '.+ Box$') then
                return true
            end
            return false
        end
        function patchConfig.shouldPatch(objectData)
            local name = objectData.name
            CrLua.Log.d(TAG, 'shouldPatch: "' .. name .. '"')
            if name == 'Active/Passed token' then
                return true -- name used by original version of this token
            end
            return isPeerName(name) or name == defaultObjectName()
        end
        function patchConfig.patch(object, objectData)
            local name = objectData.name
            CrLua.Log.d(TAG, 'patch: "' .. name .. '"')

            local newObject = CrLua.TTS.Patch.replaceLuaScript(object, patchedLua)

            -- Update any custom assets to match ours.
            local custom = self.getCustomObject()
            newObject.setCustomObject(custom)

            -- Use the new "Active/Passed (color)" naming scheme.
            newObject.setName(defaultObjectName())

            return newObject
        end
        function patchConfig.onFinish()
            CrLua.Log.setLogLevel(originalLogLevel)
        end

    end
end
originalOnLoad = nil

-- Replace event functions so this object by itself is ONLY used for patching.
-- This chunk of code (between the 'strip' tags) gets removed in patch version.
if true then
    local mt = getmetatable(_G)
    setmetatable(_G)
    function onPlayerChangeColor(playerColor) end
    function onPlayerTurnStart(playerColorStart, playerColorPrevious) end
    setmetatable(_G, mt)
end

--</strip>--

CrLua.assertRequired() -- do this BEFORE lock
CrLua.lock()

--- Active/passed token.
-- @author Darrell
--
-- When flipped to "passed" the token will automatically skip that player's
-- turn, broadcasting to all players that player has passed.
--
-- Once all players have passed, the token disables turns (via Turns.enable)
-- and all tokens flip back to active.

local TAG = 'ActivePassedToken'

-------------------------------------------------------------------------------
-- OBJECT EVENT METHODS

local _timerId = false
local _isFaceDown = false

function onLoad()
    CrLua.Log.d(TAG, 'onLoad "' .. (self.getName() or '') .. '"')

    _isFaceDown = self.is_face_down
    -- Guid may change if there's a conflict.  Wait a moment before using.
    local function delayedCreateTimer()
        _timerId = 'Active/Passed:' .. self.getGUID()

        local function colorIndex()
            local color = myColor()
            for i, candidate in ipairs(Player.getColors()) do
                if color == candidate then
                    return i
                end
            end
            return 0
        end
        math.randomseed(colorIndex())

        -- No need to remove the timer if this is destroyed, TTS ignores it.
        Timer.destroy(_timerId)
        Timer.create({
            identifier = _timerId,
            function_owner = self,
            function_name = 'timerCallback',
            delay = 1.5 + (math.random() * 0.5),  -- seconds
            repetitions = 0  -- repeat until explictly Timer.destroy'ed
        })
    end
    Wait.frames(delayedCreateTimer, 10)
end

function timerCallback()
    if _isFaceDown ~= self.is_face_down then
        _isFaceDown = self.is_face_down

        local color = myColor()
        if _isFaceDown and color then
            local message = 'Active/Passed: ' .. color .. ' passes'
            broadcastToAll(message, color)
        end
    end
end

function onPlayerTurnStart(playerColorStart, playerColorPrevious)
    CrLua.Log.d(TAG, 'onPlayerTurnStart ' .. (playerColorStart or 'nil'))

    -- Do not manipulate any Turns state now, let all objects process the
    -- same turn start values and maybe pass the turn after a few frames.
    if isMyTurn() then
        Wait.frames(maybePassTurn, 2)
    end
end

function onPlayerChangeColor(playerColor)
    if playerColor == myColor() and not isActive() then
        self.flip()
    end
end

-------------------------------------------------------------------------------

function parseColor(name)
    local color = string.match(name, '^Active/Passed %((%a+)%)$')
    color = color and (string.upper(string.sub(color, 1, 1)) .. string.lower(string.sub(color, 2)))
    return color
end

function myColor()
    return parseColor(self.getName())
end

-------------------------------------------------------------------------------

--- Is this object an Active/Passed token?
-- @param name string : peer game Object name.
-- @return boolean true if peer.
function isPeerName(name)
    local color = parseColor(name)
    if color then
        CrLua.Log.d(TAG, 'isPeer found ' .. color)
    end
    return color and true
end

--- Get all Active/Passed tokens on the board.
-- @param includeSelf boolean include this object too?
-- @return table list of objects
function getPeers(includeSelf)
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if isPeerName(object.getName()) and (object ~= self or includeSelf) then
            table.insert(result, object)
        end
    end
    CrLua.Log.d(TAG, 'getPeers: found ' .. #result .. ' peers')
    return result
end

--- Make sure each player is in the list without repeats.
-- @return boolean true if all players have one token.
function sanityCheckPeersWithIncludeSelf(peers)
    local result = true
    local colorCount = {}
    for _, peer in ipairs(peers) do
        local color = parseColor(peer.getName())
        if color then
            colorCount[color] = (colorCount[color] or 0) + 1
        end
    end
    for color, count in pairs(colorCount) do
        if count > 1 then
            result = false
            printToAll('Warning: ' .. color .. ' has multiple active/passed tokens', color)
        end
    end
    return result
end

--- Is this token showing "active"?
-- @return boolean true if active.
function isActive()
    local result = not self.is_face_down
    CrLua.Log.d(TAG, 'isActive -> ' .. tostring(result))
    return result
end

--- Is any active/passed token still active?
-- @param peers list of active/passed token objects.
-- @return color, color pair: any seated player active?  any missing players active?
function anyPeerIsActive(peers)
    local seatedSet = {}
    for _, color in ipairs(getSeatedPlayers()) do
        seatedSet[color] = true
    end
    local activeSeated = false
    local activeNotSeated = false
    for _, peer in ipairs(peers) do
        if not peer.is_face_down then
            local peerColor = parseColor(peer.getName())
            if seatedSet[peerColor] then
                activeSeated = activeSeated or peerColor
            else
                activeNotSeated = activeNotSeated or peerColor
            end
        end
    end
    CrLua.Log.d(TAG, 'anyPeerActive -> ' .. tostring(activeSeated) .. ', ' .. tostring(activeNotSeated))
    return activeSeated, activeNotSeated
end

function setActivePeersWithIncludeSelf(peers)
    local seatedSet = {}
    for _, color in ipairs(getSeatedPlayers()) do
        seatedSet[color] = true
    end
    for _, peer in ipairs(peers) do
        local peerColor = parseColor(peer.getName())
        if peer.is_face_down and seatedSet[peerColor] then
            peer.flip()
        end
    end
end

--- Is the current turn the player who owns this token?
-- @return boolean true if my turn.
function isMyTurn()
    local result = Turns.enable and Turns.turn_color == myColor()
    CrLua.Log.d(TAG, 'isMyTurn -> ' .. tostring(result))
    return result
end

-------------------------------------------------------------------------------

--- Pass turn if this token is set to "passed".  If all tokens are set to
-- "passed" then disable turns altogether, requiring turns be re-enabled
-- via some external means to proceed.
-- @return boolean true if passed turn.
function maybePassTurn()
    -- Out of paranoia make sure it is still this token owner's turn.
    -- It is possible some other script changed turns while this function
    -- was waiting to be called, or in some cases such as hot-seat games
    -- it appears TTS calls onPlayerTurnStart twice each turn.
    if not isMyTurn() then
        CrLua.Log.d(TAG, 'maybePassTurn: not my turn, aborting')
        return false
    end

    -- Make sure everyone has exactly one active/passed token.
    local peers = getPeers(true)
    local sanityCheck = sanityCheckPeersWithIncludeSelf(peers)
    if not sanityCheck then
        CrLua.Log.d(TAG, 'maybePassTurn: sanity check failed, aborting')
        return false
    end

    -- Do nothing if still active (play normally).
    if isActive() then
        CrLua.Log.d(TAG, 'maybePassTurn: still active, aborting')
        return false
    end

    -- At this point we know it is "my" turn and the token is set to "passed".
    -- Pass this turn, or if all players have passed disable turns altogether.
    -- (Requires external event to re-enable turns.)
    -- Note: if the sanity check failed then there is not one token per player.
    -- In that case, continue to pass turns but do not consider "all" passed.
    local myColor = myColor()
    local activeSeated, activeNotSeated = anyPeerIsActive(peers)
    if activeSeated then
        CrLua.Log.d(TAG, 'maybePassTurn: at least one active seated peer, passing turn')
        local player = Player[myColor]
        local name = (player and player.steam_name) or myColor or '?'
        broadcastToAll('Player ' .. name .. ' passed.', myColor)
        Turns.turn_color = Turns.getNextTurnColor()
    elseif activeNotSeated then
        CrLua.Log.d(TAG, 'maybePassTurn: at least one active unseated peer, aborting')
        broadcastToAll('Player ' .. activeNotSeated .. ' still active but not at table')
    else
        CrLua.Log.d(TAG, 'maybePassTurn: no active peers, disabling turns')
        broadcastToAll('All players have passed.', myColor)
        setActivePeersWithIncludeSelf(peers)
        Turns.enable = false
    end
    return true
end

-------------------------------------------------------------------------------

#include <~/CrLua/CrLua>
#include <~/CrLua/LockGlobals>

#include <~/CrLua/LockTable>
#include <~/CrLua/Log>

CrLua.assertRequired({'Log'}) -- do this BEFORE lock
CrLua.lock()

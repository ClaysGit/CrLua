-------------------------------------------------------------------------------
--- Auto-fill the TTS/TI4 MultiRoller
-- TTS/TI4 by Darth Batman and Raptor1210.
-- MultiRoller by GarnetBear
-- @author bonkersbgg on BoardGameGeek.com
--[[

This script keeps track of the last activated system (command token dropped
by the active player this turn), and scans the board to fill in the_Mantis's
excellent TI4 MultiRoller.

The active fleet takes into account if the MultiRoller belongs to the attacker,
defender, or third party who happens to have range with an adjacent PDS2.
Per-planet combats assign units to the closest planet.

It scans for Antimass Deflector on the other party, and selects the best unit
for Plasma Scoring.

PDS2 targets adjacent and through-wormhole, including the Creuss flagship's
mobile delta wormhole.  The Winnu flagship sets its count to the number of
non-fighter opponents.  The Xxcha flagship has an adjacent-reaching PDS.

Creuss players might want to enable "grid" on their homeworld so it aligns well
with the table grid, making sure units on the planet are counted.

This requires Turns be enabed to ignore when a non-active player touches a
command token.  (Turns are automatically enabled via the "place trade goods and
set turns" button.)  For a hot-seat like environment, a player must change color
to the current active turn in order to recognize system activation.

HOW TO USE:

Right click this object and select "Save Object".  Start a TI4 game, then
click "Objects" at the top, then "Saved Objects", then this saved object to
spawn one in the game.  Clicking the "add auto-fill buttons" adds an "auto-fill"
button to each MultiRoller sheet.

During a game, clicking the "auto-fill" button fills in the combat MultiRoller.
The script prints console messages to the clicking player, or right click to
broadcast them to the entire table.

]]
-------------------------------------------------------------------------------

local TAG = 'AutoFillMultiRoller'

local data = {
    visualizeHexes = true,
    panelToMultiRoller = false,
    multiRollerToColor = false,
    lastActivatedPosition = false,
    perPlanetButtons = {}  -- map from function name to button index
}

local TYPE = {
    SPACE_CANNON_OFFENSE = { name = 'Space Cannon Offense', roll = 'clickSPC' },
    ANTI_FIGHTER_BARRAGE = { name = 'Anti-Fighter Barrage', roll = 'clickAFB' },
    SPACE_COMBAT = { name = 'Space Combat', roll = 'clickCMBT' },
    BOMBARDMENT = { name = 'Bombardment', perPlanet = true, roll = 'clickBOMB' },
    SPACE_CANNON_DEFENSE = { name = 'Space Cannon Defense', perPlanet = true, roll = 'clickSPC' },
    GROUND_COMBAT = { name = 'Ground Combat', perPlanet = true, roll = 'clickCMBT' }
}

local PLASMA_SCORING_BUTTON = {
    ['Flagship'] = 'PS1',
    ['War Sun'] = 'PS2',
    ['Dreadnought'] = 'PS4',
    ['PDS'] = 'PS9',
    ['Space Dock'] = 'PS10'
}

local CARDS = {
    ['PDS II'] = { owner = 'us' },
    ['Antimass Deflectors'] = { owner = 'them' },
    ['Plasma Scoring'] = { owner = 'us' },
    ['Experimental Battlestation'] = { owner = 'us' }
}

PANEL = {
    NAME = 'Auto-Fill TI4 MultiRoller',
    DESCRIPTION = 'Click to count units in the activated system (and adjacent when appropriate) and fill in the TI4 MultiRoller.  Reports fill to all players, right-click will only report to self.'
}

function getAutoFillFunctionName(autoFillType, planetIndex)
    return autoFillType .. (planetIndex and '_' .. planetIndex or '')
end

-- Create functions for each TYPE, function is named for the TYPE key.
-- Create _1, _2, and _3 variants for multi-planet systems.
function createAutoFillFunctions()
    for autoFillType, attributes in pairs(TYPE) do
        local max = attributes.perPlanet and 3 or 1
        for i = 1, max do
            local function redirectOnClick(buttonContainer, clickerColor, altClick)
                -- Get the MultiRoller associate with this auto-fill panel.
                local multiRoller = data.panelToMultiRoller[buttonContainer]
                local playerColor = data.multiRollerToColor[multiRoller]
                autoFill(multiRoller, clickerColor, playerColor, autoFillType, max > 1 and i, altClick)
            end
            local functionName = getAutoFillFunctionName(autoFillType, max > 1 and i)
            assert(not self.getVar(functionName))
            self.setVar(functionName, redirectOnClick)
        end
    end
end

-------------------------------------------------------------------------------

function onLoad(save_state)
    CrLua.Log.d(TAG, 'onLoad')
    createAutoFillFunctions()

    -- Scale the block and attach a button with reversed scale.
    local scale = { x = 6, y = 0.1, z = 2.5 }
    local invScale = { x = 1 / scale.x, y = 1 / scale.y, z = 1 / scale.z }
    self.setScale(scale)
    self.createButton({
        click_function = 'addAutoFillPlusOtherSetup',
        function_owner = self,
        label = 'ADD AUTO-FILL\nMULTIROLLER BUTTONS',
        font_size = 200,
        width = 2400,
        height = 600,
        position = { x = 0, y = 0.5, z = -0.15 },
        scale = invScale,
    })
    self.createButton({
        click_function = 'removeAutoFillButtonsFromMultiRollers',
        function_owner = self,
        label = 'REMOVE',
        font_size = 200,
        width = 2400,
        height = 300,
        position = { x = 0, y = 0.5, z = 0.3 },
        scale = invScale,
    })
    self.interactable = true

    Wait.frames(removeAutoFillButtonsFromMultiRollers, 2)
    Wait.frames(addAutoFillPlusOtherSetup, 20)
end

function onPlayerTurnStart(playerColorStart, playerColorPrevious)
    CrLua.Log.d(TAG, 'onPlayerTurnStart: clearing last activated position')
    data.lastActivatedPosition = false
    updateAutoFillButtonsForActivatedSystem()
end

function onObjectDrop(playerColor, droppedObject)
    local isPlayerCurrentTurn = playerColor == Turns.turn_color
    if not isPlayerCurrentTurn then
        return
    end
    local isCommandToken = string.find(droppedObject.getName(), ' Command Token')
    if not isCommandToken then
        return
    end
    local system = CrLua.TI4.System.fromPosition(droppedObject.getPosition())
    if not system then
        return  -- ignore tokens not dropped on a system
    end

    CrLua.Log.d(TAG, 'onObjectDrop: activated by ' .. playerColor)
    data.lastActivatedPosition = droppedObject.getPosition()
    updateAutoFillButtonsForActivatedSystem()
end

function addAutoFillPlusOtherSetup()
    assignMultiRollerColors()
    addAutoFillButtonsToMultiRollers()
    Wait.frames(updateAutoFillButtonsForActivatedSystem, 2)
end

-------------------------------------------------------------------------------

--- Get the hex and adjacent hexes from a position.
function getHexes(position)
    assert(type(position) == 'table' and type(position.x) == 'number')

    -- Get this hex, and adjacent hexes.
    local hex = CrLua.TI4.Hex.fromPosition(position)
    local adjacentHexes = CrLua.TI4.Hex.neighbors(hex)

    -- Get the wormholes in this hex, plus other wormhole-adjacent hexes.
    -- As a side-effect, the filter function adds 'hex' to each wormhole.
    local function isWormholeInSelfHex(wormhole)
        local position = wormhole.object.getPosition()
        wormhole.hex = CrLua.TI4.Hex.fromPosition(position)
        return wormhole.hex == hex
    end
    local wormholes, adjacentWormholes = CrLua.TI4.Wormhole.getAllWormholes(isWormholeInSelfHex)
    for _, wormhole in ipairs(adjacentWormholes) do
        table.insert(adjacentHexes, wormhole.hex)
    end

    -- Remove any duplicates.
    adjacentHexes = CrLua.List.unique(adjacentHexes)

    if data.visualizeHexes then
        local lines = {}
        table.insert(lines, CrLua.TI4.Hex.vectorLines(hex, { color = {1,0,0} }))
        for _, adjacentHex in ipairs(adjacentHexes) do
            table.insert(lines, CrLua.TI4.Hex.vectorLines(adjacentHex, { color = {0,1,0} }))
        end
        Global.setVectorLines(lines)
    end

    return hex, adjacentHexes
end

--- Get units in the position's hex, as well as units in adjacent hexes.
function getUnits(hex, adjacentHexes)
    assert(type(hex) == 'string' and not adjacentHexes or type(adjacentHexes) == 'table')

    -- Get units in this hex and adjacent hexes.
    -- As a side-effect, filter adds 'hex' to each unit.
    local adjacentHexesSet = CrLua.List.toSet(adjacentHexes or {})
    local function isInSelfOrAdjacentHex(unit)
        local position = unit.object.getPosition()
        unit.hex = CrLua.TI4.Hex.fromPosition(position)
        return unit.hex == hex or adjacentHexesSet[unit.hex]
    end
    local units = CrLua.TI4.Unit.getAllUnits(isInSelfOrAdjacentHex)

    -- Split into in-hex and in-adjacent hex lists.
    local unitsInHex = {}
    local unitsInAdjacent = {}
    for _, unit in ipairs(units) do
        if unit.hex == hex then
            table.insert(unitsInHex, unit)
        else
            table.insert(unitsInAdjacent, unit)
        end
    end

    -- Fill in any missing colors (anonymous 'x3 Infantry' tokens, etc).
    -- Only do this for the hex in question.
    CrLua.TI4.Unit.assignUnitTokenColors(unitsInHex)

    return unitsInHex, unitsInAdjacent
end

--- Get cards if held by appropriate player.
function getCards(selfColor, enemyColor)
    local selfZone = selfColor and CrLua.TI4.Zone.fromColor(selfColor)
    local enemyZone = enemyColor and CrLua.TI4.Zone.fromColor(enemyColor)

    local objectNames = CrLua.List.fromKeys(CARDS)
    local objectsByName = CrLua.TTS.Object.getByName(objectNames)

    local result = {}
    for cardName, cardObjects in pairs(objectsByName) do
        for _, cardObject in ipairs(cardObjects) do
            if not cardObject.is_face_down then
                local owner = CARDS[cardName].owner
                local zone = owner == 'us' and selfZone or enemyZone
                if zone and CrLua.TI4.Zone.inside(zone, cardObject.getPosition()) then
                    table.insert(result, cardName)
                    break
                end
            end
        end
    end
    return result
end

-------------------------------------------------------------------------------

function autoFill(multiRoller, clickerColor, selfColor, typeKey, planetIndex, altClick)
    local typeAttributes = assert(TYPE[typeKey])

    CrLua.TI4.Zone.update()

    if not data.lastActivatedPosition then
        printToColor(TAG .. ': no activated system', clickerColor, {1,0,0})
        return
    end

    local activatingColor = Turns.turn_color
    if not activatingColor then
        printToColor(TAG .. ': no activating player', clickerColor, {1,0,0})
        return
    end

    -- Get units in hex and adjacent (including wormholes) systems.
    local hex, adjacent = getHexes(data.lastActivatedPosition)
    local unitsInHex, unitsInAdjacent = getUnits(hex, adjacent)

    -- If per-planet, restrict to units in hex to those on the given planet.
    local planet = false
    if planetIndex then
        local system = CrLua.TI4.System.fromPosition(data.lastActivatedPosition)
        if system and system.planets and #system.planets >= planetIndex then
            planet = system.planets[planetIndex]
            local onPlanet = {}
            for _, unit in ipairs(unitsInHex) do
                if CrLua.TI4.System.planetFromPosition(system, unit.object.getPosition()) == planet then
                    table.insert(onPlanet, unit)
                elseif unit.unitName == 'Fighter' or unit.unitName == 'Flagship' then
                    -- Also include fighters and flagship in order to include
                    -- them in ground combat if the Naalu flagship.  This will
                    -- get filtered out later if not Naalu.
                    table.insert(onPlanet, unit)
                end
            end
            unitsInHex = onPlanet
            unitsInAdjacent = {}
        end
    end

    -- Deduce enemy color as the only non-self in the system.
    local enemyColors = CrLua.TI4.Unit.getEnemyColors(selfColor, activatingColor, unitsInHex)
    if enemyColors and #enemyColors > 1 then
        error(TAG .. ': multiple enemies? (' .. table.concat(enemyColors, ', ') .. ')')
    end
    local enemyColor = enemyColors and enemyColors[1]

    -- Split into self and enemy units.
    local selfUnitsInHex = CrLua.TI4.Unit.filterToColor(unitsInHex, selfColor)
    local selfUnitsAdacent = CrLua.TI4.Unit.filterToColor(unitsInAdjacent, selfColor)
    local enemyUnitsInHex = enemyColor and CrLua.TI4.Unit.filterToColor(unitsInHex, enemyColor) or {}
    unitsInHex = nil
    unitsInAdjacent = nil

    -- Get cards.
    local cards = getCards(selfColor, enemyColor)
    local cardSet = CrLua.List.toSet(cards)

    -- Is bombardment allowed?
    local planetaryShield = false
    if enemyColor then
        local units = CrLua.TI4.Unit.filterToPlanetaryShield(enemyUnitsInHex)
        planetaryShield = planetaryShield or #units > 0
    end
    if selfColor then
        local units = CrLua.TI4.Unit.filterToIgnorePlanetaryShield(selfUnitsInHex)
        planetaryShield = planetaryShield and #units == 0
    end

    -- Now get just the units that matter for the combat type.
    local fillUnits = {}
    local psUnit = false
    if typeAttributes == TYPE.SPACE_CANNON_OFFENSE then
        fillUnits = CrLua.TI4.Unit.filterToSpaceCannon(selfUnitsInHex)
        local adjacentSpaceCannons = CrLua.TI4.Unit.filterToSpaceCannon(selfUnitsAdacent)
        for _, unit in ipairs(adjacentSpaceCannons) do
            if unit.unitName == 'Flagship' or cardSet['PDS II'] then
                table.insert(fillUnits, unit)
            end
        end
        fillUnits, psUnit = CrLua.TI4.Unit.filterToSpaceCannon(fillUnits)
    elseif typeAttributes == TYPE.ANTI_FIGHTER_BARRAGE then
        fillUnits = CrLua.TI4.Unit.filterToAntiFighterBarrage(selfUnitsInHex)
    elseif typeAttributes == TYPE.SPACE_COMBAT then
        fillUnits = CrLua.TI4.Unit.filterToShips(selfUnitsInHex)
    elseif typeAttributes == TYPE.BOMBARDMENT then
        fillUnits, psUnit = CrLua.TI4.Unit.filterToBombardment(selfUnitsInHex)
        if planetaryShield then
            fillUnits = {}
        end
    elseif typeAttributes == TYPE.SPACE_CANNON_DEFENSE then
        fillUnits, psUnit = CrLua.TI4.Unit.filterToSpaceCannon(selfUnitsInHex)
    elseif typeAttributes == TYPE.GROUND_COMBAT then
        fillUnits = CrLua.TI4.Unit.filterToGround(selfUnitsInHex)
    else
        error(TAG .. ' unknown type "' .. typeAttributes.name .. "'")
    end

    -- Employ experimental battlestation?
    if typeAttributes == TYPE.SPACE_CANNON_OFFENSE and cardSet['Experimental Battlestation'] then
        -- Look for at least one local or adjacent.
        for _, unit in ipairs(CrLua.List.join(selfUnitsInHex, selfUnitsAdacent)) do
            if unit.unitName == 'Space Dock' then
                unit.special = 'Experimental Battlestation'
                table.insert(fillUnits, unit)
                psUnit = unit
                break
            end
        end
    end

    -- Consolidate units to a single entry per type.
    local unitCount = {}
    local adjacentUnitCount = {}
    local special = {}
    for _, unit in ipairs(fillUnits or {}) do
        local unitName = assert(unit.unitName)
        local count = assert(unit.count)

        -- Respect non-fighter-dice ability.
        if unitName == 'Flagship' then
            local attrs = CrLua.TI4.Unit.attributes(unit)
            if attrs[CrLua.TI4.Unit.ATTR.NON_FIGHTER_DICE] then
                count = #CrLua.TI4.Unit.filterToNonFighterShips(enemyUnitsInHex) or 0
            end
        end
        unitCount[unitName] = (unitCount[unitName] or 0) + count
        if unit.hex ~= hex then
            adjacentUnitCount[unitName] = (adjacentUnitCount[unitName] or 0) + count
        end
        special[unitName] = special[unitName] or unit.special
    end

    local prefix = { 'AutoFill ' .. typeAttributes.name }
    if planet then
        table.insert(prefix, '(' .. planet .. ')')
    end
    table.insert(prefix, selfColor .. ' vs ' .. (enemyColor or '<unknown>'))
    local message = table.concat(prefix, ' ') .. ': '

    local messages = {}
    for unitName, count in pairs(unitCount) do
        local name = unitName
        if count > 1 and unitName ~= 'Infantry' and unitName ~= 'PDS' then
            name = name .. 's'
        end
        local message = count .. ' ' .. name
        if adjacentUnitCount[unitName] then
            message = message .. ' (' .. adjacentUnitCount[unitName] .. ' adjacent)'
        end
        if special[unitName] then
            message = message .. ' (' .. special[unitName] .. ')'
        end
        if psUnit and psUnit.unitName == unitName then
            message = message .. ' (Plasma Scoring)'
        end
        table.insert(messages, message)
    end
    if cardSet['Antimass Deflectors'] then
        table.insert(messages, enemyColor .. ' has Antimass Deflectors')
    end

    if #messages > 0 then
        message = message .. table.concat(messages, ', ') .. '.'
    elseif typeAttributes == TYPE.BOMBARDMENT and planetaryShield then
        message = message .. 'no units (Planetary Shield).'
    end
    if altClick then
        local toPlayer = CrLua.TTS.Player.isSeated(selfColor) and selfColor or clickerColor
        printToColor(message, toPlayer, selfColor)
    else
        printToAll(message, selfColor)
    end

    injectValues{
        multiRoller = assert(multiRoller),
        unitCount = assert(unitCount),
        hasAntimassDeflectors = cardSet['Antimass Deflectors'],
        suggestPdsUnitName = psUnit and psUnit.unitName,
        selfColor = assert(selfColor),
        roll = typeAttributes.roll
    }
end

-------------------------------------------------------------------------------

function injectValues(parameters)
    local multiRoller = assert(parameters.multiRoller)
    local color = assert(parameters.selfColor)
    local unitCount = parameters.unitCount

    multiRoller.call('resetCounters')


    local inputs = parameters.multiRoller.getInputs()
    for unitName, count in pairs(unitCount) do
        local inputLabel = 'UNIT:' .. unitName
        local found = false
        for _, input in ipairs(inputs) do
            if input.label == inputLabel then
                found = true
                parameters.multiRoller.editInput({ index = input.index, value = count })
                break
            end
        end
        if not found then
            error('Warning: no input ' .. inputLabel)
        end
    end

    if parameters.hasAntimassDeflectors then
        multiRoller.call('clickAMD')
    end

    if parameters.suggestPdsUnitName then
        local button = assert(PLASMA_SCORING_BUTTON[parameters.suggestPdsUnitName])
        multiRoller.call(button)
    end

    -- "Update" by calling the associated function.  Call can only pass one argument!
    multiRoller.call('detectCards', color)

    if multiRoller.getVar('clickButtonHack') then
        multiRoller.call('clickButtonHack', { parameters.roll, color, false })
    end
end

-------------------------------------------------------------------------------

function updateAutoFillButtonsForActivatedSystem()
    local planets = {}
    if data.lastActivatedPosition then
        local system = CrLua.TI4.System.fromPosition(data.lastActivatedPosition)
        planets = system and system.planets or {}
    end

    local function getButton(panel, buttonIndex)
        local buttons = panel.getButtons()
        for _, button in ipairs(buttons) do
            if button.index == buttonIndex then
                return button
            end
        end
    end

    local panels = getAutoFillPanels()
    for _, panel in ipairs(panels) do
        for planetIndex, buttonIndices in pairs(data.perPlanetButtons) do
            for buttonIndex, clickFunction in pairs(buttonIndices) do
                local button = assert(getButton(panel, buttonIndex))
                if planetIndex <= #planets then
                    button.click_function = clickFunction
                    button.label = string.upper(planets[planetIndex])
                else
                    button.click_function = '_doNothing'
                    button.label = '---'
                end
                panel.editButton(button)
            end
        end
    end
end

-------------------------------------------------------------------------------

function _doNothing() end

function spawnAutoFillPanelForMultiRoller(multiRoller)
    -- Create a new panel for the buttons.
    -- Position takes into account the roller orientation.
    local panelPos = multiRoller.positionToWorld({
        x = 0,
        y = 0,
        z = 1.3
    })
    local panel = spawnObject({
        type = 'Custom_Tile',
        position = panelPos,
        scale = {
            x = 9.95,
            y = 1,
            z = 2.8
        },
        rotation = multiRoller.getRotation(),
        snap_to_grid = false,
        sound = false,
    })
    panel.setCustomObject({
        -- Image is 16x16 white box.
        image = 'http://cloud-3.steamusercontent.com/ugc/1025076968516134092/AFBACE0CF0D33833B8CE0D45A916F4ED8B7E83EF/',
        type = 0,
        thickness = 0.2,
        stackable = false
    })
    panel.setName(PANEL.NAME)
    panel.setDescription(PANEL.DESCRIPTION)
    panel.use_grid = false
    panel.use_snap_points = false
    panel.use_gravity = false
    --panel.interactable = false
    panel.setPosition(panelPos)
    panel.setLock(true)

    local fontSize = 220
    local width = 1400
    local height = 500
    local x0 = -0.8
    local dx = 0.32
    local y = 0.201
    local z0 = -0.65
    local dz = 0.44

    local invScale = panel.getScale()
    local buttonScale = { x = 1.0 / invScale.x, y = 1.0 / invScale.y, z = 1.0 / invScale.z }

    -- Note: the function_owner is used to locate the function, and must be
    -- "self".  When the function gets called, the first parameter "obj"
    -- will be the object the button is connected to via createButton.
    local typeIndex = 0
    local buttonIndex = 0
    for autoFillType, attributes in pairs(TYPE) do
        panel.createButton({
            click_function = '_doNothing',
            function_owner = self,
            label = string.gsub(string.upper(attributes.name), ' ', '\n'),
            font_size = fontSize,
            width = 0,
            height = 0,
            position = { x = x0 + typeIndex * dx, y = y, z = z0 + 0 * dz },
            scale = buttonScale,
        })
        buttonIndex = buttonIndex + 1

        local max = attributes and attributes.perPlanet and 3 or 1
        for i = 1, max do
            local click_function = getAutoFillFunctionName(autoFillType, max > 1 and i)
            panel.createButton({
                click_function = click_function,
                function_owner = self,
                label = 'AUTO-FILL' .. (max > 1 and '\nPLANET ' .. i or ''),
                font_size = fontSize,
                width = width,
                height = height,
                position = { x = x0 + typeIndex * dx, y = y, z = z0 + i * dz },
                scale = buttonScale,
                --tooltip = 'Left click to auto-fill ' .. autoFillType .. ' and send message to all players.  Right click to send message only to self.'
            })
            if max > 1 then
                local perPlanetButtons = data.perPlanetButtons[i]
                if not perPlanetButtons then
                    perPlanetButtons = {}
                    data.perPlanetButtons[i] = perPlanetButtons
                end
                perPlanetButtons[buttonIndex] = click_function
            end
            buttonIndex = buttonIndex + 1
        end
        typeIndex = typeIndex + 1
    end

    return panel
end

function getAutoFillPanels()
    local result = {}
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == PANEL.NAME then
            table.insert(result, object)
        end
    end
    return (#result > 0 and result) or nil
end

function addAutoFillButtonsToMultiRollers()
    local existing = getAutoFillPanels()
    if existing then
        CrLua.Log.e(TAG, 'already have auto-fill buttons')
        return
    end

    data.panelToMultiRoller = {}
    local count = 0
    for _, object in ipairs(getAllObjects()) do
        local startPos, endPos = string.find(object.getName(), 'TI4 MultiRoller')
        if startPos == 1 then
            local panel = spawnAutoFillPanelForMultiRoller(object)
            data.panelToMultiRoller[panel] = object
            count = count + 1
        end
    end
    CrLua.Log.d(TAG, 'added auto-fill buttons to ' .. count .. ' MultiRollers')
end

function removeAutoFillButtonsFromMultiRollers()
    local existing = getAutoFillPanels()
    if not existing then
        CrLua.Log.e(TAG, 'no auto-fill buttons to remove')
        return
    end

    data.panelToMultiRoller = false

    local count = #existing
    for _, object in ipairs(existing) do
        destroyObject(object)
    end
    CrLua.Log.d(TAG, 'removed auto-fill buttons from ' .. count .. ' MultiRollers')
end

function assignMultiRollerColors()
    local multiRollers = {}
    local colorToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        local startPos, endPos = string.find(name, 'TI4 MultiRoller')
        if startPos == 1 then
            table.insert(multiRollers, object)
        end
        local startPos, endPos = string.find(name, 'Command Sheet')
        if startPos == 1 then
            local color = string.match(name, '^Command Sheet %((%a+)%)$')
            if color then
                colorToPosition[color] = object.getPosition()
            end
        end
    end

    data.multiRollerToColor = {}
    for _, multiRoller in ipairs(multiRollers) do
        local multiRollerPosition = multiRoller.getPosition()
        local function distance(colorPosition)
            return CrLua.Util.distanceSq(multiRollerPosition, colorPosition)
        end
        local color, _ = CrLua.Util.min(colorToPosition, distance)
        data.multiRollerToColor[multiRoller] = color
    end
end

-------------------------------------------------------------------------------

#include <~/CrLua/CrLua>
#include <~/CrLua/LockGlobals>

#include <~/CrLua/TI4/Hex>
#include <~/CrLua/TI4/System>
#include <~/CrLua/TI4/Unit>
#include <~/CrLua/TI4/Wormhole>
#include <~/CrLua/TI4/Zone>

#include <~/CrLua/TTS/Object>
#include <~/CrLua/TTS/Player>

#include <~/CrLua/List>
#include <~/CrLua/LockTable>
#include <~/CrLua/Log>
#include <~/CrLua/Polygon>
#include <~/CrLua/RedBlobHex>
#include <~/CrLua/Table>
#include <~/CrLua/Util>

--#include <~/CrLua/UnitTest>
--CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
--CrLua.UnitTest.runTests(TAG, CrLua, true)

CrLua.assertRequired({ 'TI4.Hex', 'TI4.Unit', 'TI4.Wormhole', 'TTS.Player', 'List', 'Log' })
CrLua.lock()

--- Shared unit logic.
-- @author Darrell

-- Users should copy this getHelperClient function, and use via:
--
-- local unitHelper = getHelperClient('TI4_UNIT_HELPER')
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local _nonFighterShipSet = {
    ['Carrier'] = true,
    ['Destroyer'] = true,
    ['Cruiser'] = true,
    ['Dreadnought'] = true,
    ['Flagship'] = true,
    ['War Sun'] = true,
}

local _unitTypes = {
    ['Carrier'] = {
        cost = 3,
        spaceCombat = { dice = 1, hit = 9 },
        move = 1,
        capacity = 4,
    },
    ['Cruiser'] = {
        cost = 2,
        spaceCombat = { dice = 1, hit = 7 },
        move = 2,
    },
    ['Destroyer'] = {
        antiFighterBarrage = { dice = 2, hit = 8 },
        cost = 1,
        spaceCombat = { dice = 1, hit = 9 },
        move = 2,
    },
    ['Dreadnought'] = {
        sustainDamage = true,
        bombardment = { dice = 1, hit = 5 },
        cost = 4,
        spaceCombat = { dice = 1, hit = 5 },
        move = 2,
    },
    ['Fighter'] = {
        cost = 0.5,
        spaceCombat = { dice = 1, hit = 9 },
    },
    ['Flagship'] = {
        sustainDamage = true,
        cost = 8,
        move = 1,
        capacity = 3,
    },
    ['Infantry'] = {
        cost = 0.5,
        groundCombat = { dice = 1, hit = 8 },
    },
    ['PDS'] = {
        planetaryShield = true,
        spaceCannon = { dice = 1, hit = 6 },
    },
    ['Space Dock'] = {
        production = -2,
    },
    ['War Sun'] = {},
}

-- "override" replaces base unit, "upgrade" requires unit upgrade card.
local _unitOverrides = {
    -- Standard unit upgrades.
    ['Carrier II'] = { upgrade = 'Carrier', move = 2, capacity = 6 },
    ['Cruiser II'] = { upgrade = 'Cruiser', spaceCombat = { hit = 6 }, move = 3, capacity = 1 },
    ['Destroyer II'] = { upgrade = 'Destroyer', antiFighterBarrage = { dice = 3, hit = 6 }, spaceCombat = { hit = 8 } },
    ['Dreadnought II'] = { upgrade = 'Dreadnought', move = 2 },
    ['Fighter II'] = { upgrade = 'Fighter', spaceCombat = { hit = 8 }, move = 2 },
    ['Infantry II'] = { upgrade = 'Infantry', groundCombat = { hit = 7 } },
    ['PDS II'] = { upgrade = 'PDS', spaceCannon = { hit = 5 } },
    ['Space Dock II'] = { upgrade = 'Space Dock', production = -4 },
    ['War Sun'] = { upgrade = 'War Sun', sustainDamage = true, bombardment = { dice = 3, hit = 3 }, cost = 12, spaceCombat = { dice = 3, hit = 3 }, move = 2, capacity = 6 },

    -- Faction unit overrides and upgrades.
    ['Advanced Carrier I'] = { override = 'Carrier', capacity = 6 },
    ['Advanced Carrier II'] = { upgrade = 'Carrier', sustainDamage = true, capacity = 8 },
    ['Exotrireme I'] = { override = 'Dreadnought', bombardment = { dice = 2, hit = 4 } },
    ['Exotrireme II'] = { upgrade = 'Dreadnought', bombardment = { dice = 2, hit = 4 }, move = 2 },
    ['Floating Factory I'] = { override = 'Space Dock', production = 5, move = 1, capacity = 4 },
    ['Floating Factory II'] = { upgrade = 'Space Dock', production = 7, move = 2, capacity = 5 },
    ['Hybrid Crystal Fighter I'] = { override = 'Fighter', spaceCombat = { hit = 8 } },
    ['Hybrid Crystal Fighter II'] = { upgrade = 'Fighter', spaceCombat = { hit = 7 }, move = 2 },
    ['Letani Warrior I'] = { override = 'Infantry', production = 1 },
    ['Letani Warrior II'] = { upgrade = 'Infantry', production = 2, groundCombat = { hit = 7 } },
    ['Prototype War Sun I'] = { override = 'War Sun', sustainDamage = true, bombardment = { dice = 3, hit = 3 }, cost = 12, spaceCombat = { dice = 3, hit = 3 }, move = 1, capacity = 6 },
    ['Prototype War Sun II'] = { upgrade = 'War Sun', sustainDamage = true, bombardment = { dice = 3, hit = 3 }, cost = 10, spaceCombat = { dice = 3, hit = 3 }, move = 3, capacity = 6 },
    ['Spec Ops I'] = { override = 'Infantry', groundCombat = { hit = 7 } },
    ['Spec Ops II'] = { upgrade = 'Infantry', groundCombat = { hit = 6 } },
    ['Super Dreadnought I'] = { override = 'Dreadnought', capacity = 2 },
    ['Super Dreadnought II'] = { upgrade = 'Dreadnought', bombardment = { dice = 1, hit = 4 }, move = 2, capacity = 2 },

    -- Codex.
    ['????_REDACTED_????'] = { override = 'Destroyer', antiFighterBarrage = { dice = 3, hit = 6 }, spaceCombat = { hit = 7 }, capacity = 1 },

    -- Flagships.
    ['Arc Secundus'] = { override = 'Flagship', bombardment = { dice = 3, hit = 5 }, spaceCombat = { dice = 2, hit = 5 } },
    ["C'Morran N'orr"] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 6 } },
    ['Duha Menaimon'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 7 }, capacity = 5 },
    ['Fourth Moon'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 7 } },
    ['Genesis'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 5 }, capacity = 12 },
    ['Hil Colish'] = { override = 'Flagship', spaceCombat = { dice = 1, hit = 5 } },
    ['J.N.S. Hylarim'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 6 } },
    ['Loncara Ssodu'] = { override = 'Flagship', spaceCannon = { dice = 3, hit = 5 }, spaceCombat = { dice = 2, hit = 7 } },
    ['Matriarch'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 9 }, capacity = 6 },
    ['Salai Sai Corian'] = { override = 'Flagship', spaceCombat = { dice = 1, hit = 7 } },
    ['Son of Ragh'] = { override = 'Flagship', antiFighterBarrage = { dice = 4, hit = 6 }, spaceCombat = { dice = 2, hit = 5 } },
    ['The Alastor'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 9 } },
    ['The Inferno'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 5 } },
    ['Van Hauge'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 9 } },
    ['Wrath of Kenara'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 7 } },
    ["Y'sia Y'ssrila"] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 5 }, move = 2 },
    ['[0.0.1]'] = { override = 'Flagship', spaceCombat = { dice = 2, hit = 5 }, capacity = 5 },
}

local _rollModifiers = {
    ['Antimass Deflectors'] = {
        description = '-1 to all SPACE CANNON rolls',
    },

    ['Blitz'] = {
        description = 'BOMBARDMENT 6 to non-fighter, non-bomdbardment ships',
    },

    ['Bunker'] = {
        description = '-4 to all BOMBARDMENT rolls',
        anywhereOnTable = true,
    },

    ["C'morran N'orr"] = {
        description = "+1 to all COMBAT rolls for other ships with the C'morran N'orr",
    },

    ['Fighter Prototype'] = {
        description = "+2 to fighters' COMBAT rolls",
    },

    ['Fragile'] = {
        description = '-1 to all COMBAT rolls',
    },

    ['Morale Boost'] = {
        description = '+1 to all COMBAT rolls',
    },
    ['Morale Boost (1)'] = { alias = 'Morale Boost' },
    ['Morale Boost (2)'] = { alias = 'Morale Boost' },
    ['Morale Boost (3)'] = { alias = 'Morale Boost' },
    ['Morale Boost (4)'] = { alias = 'Morale Boost' },

    ['Nebula Defence'] = {
        description = '+1 to all COMBAT rolls (defender)',
    },

    ['Plasma Scoring'] = {
        descirption = '+1 die to a single BOMBARDMENT roll'
    },

    ['Prophecy of Ixth'] = {
        description = "+1 to fighter's COMBAT rolls",
    },

    ['Regulated Conscription'] = {
        description = 'Fighters and infantry cost 1 each',
        anywhereOnTable = true,
    },

    ['Tekklar Legion'] = {
        description = '+1 to all COMBAT rolls for attacker',  -- -1 to Sardakk if other player has it
    },

    ['Unrelenting'] = {
        description = '+1 to all COMBAT rolls',
    },
}

--- Get a (for debugging) text summary.
-- @param unitAttrs table : unitType to unit attributes tables.
function unitAttributesSummary(unitAttrs)
    assert(type(unitAttrs) == 'table')

    local ignoreAttributeSet = {
        ['name'] = true,
        ['override'] = true,
        ['upgrade'] = true,
    }

    local message = {}
    for unitType, attrs in pairs(unitAttrs) do
        local unitMessage = {}
        if attrs.name and attrs.name ~= unitType then
            table.insert(unitMessage, 'name="' .. attrs.name .. '"')
        end
        for k, v in pairs(attrs) do
            if k == 'antiFighterBarrage' then
                table.insert(unitMessage, k .. '=' .. v.hit .. 'x' .. v.dice )
            elseif k == 'bombardment' then
                table.insert(unitMessage, k .. '=' .. v.hit .. 'x' .. v.dice )
            elseif k == 'capacity' then
                table.insert(unitMessage, k .. '=' .. v )
            elseif k == 'cost' then
                table.insert(unitMessage, k .. '=' .. v )
            elseif k == 'groundCombat' then
                table.insert(unitMessage, k .. '=' .. v.hit .. 'x' .. v.dice )
            elseif k == 'move' then
                table.insert(unitMessage, k .. '=' .. v )
            elseif k == 'planetaryShield' then
                table.insert(unitMessage, k .. '=true')
            elseif k == 'production' then
                table.insert(unitMessage, k .. '=' .. v )
            elseif k == 'spaceCannon' then
                table.insert(unitMessage, k .. '=' .. v.hit .. 'x' .. v.dice )
            elseif k == 'spaceCombat' then
                table.insert(unitMessage, k .. '=' .. v.hit .. 'x' .. v.dice )
            elseif k == 'sustainDamage' then
                table.insert(unitMessage, k .. '=true')
            elseif not ignoreAttributeSet[k] then
                error('unknown attribute "' .. k .. '"')
            end
        end
        table.insert(message, unitType .. ': ' .. table.concat(unitMessage, ', '))
    end

    return table.concat(message, '\n')
end

--- Get unit attributes.
-- @param unitOverrides table : list of unit override name strings.
-- @return table : unit type to unit attributes tables.
function unitAttributes(unitOverrides)
    assert(type(unitOverrides) == 'table')

    -- Overwrite orig fields.
    local function apply(orig, override)
        assert(type(orig) == 'table' and type(override) == 'table')
        for k, v in pairs(orig) do
            if type(v) == 'table' then
                apply(v, override[k] or {})
            else
                orig[k] = override[k] or v
            end
        end
        for k, v in pairs(override) do
            if not orig[k] then
                orig[k] = v
            end
        end
    end

    -- Start with base attributes (copy for private mutations).
    local result = _copy(_unitTypes)

    for unitType, attrs in pairs(result) do
        -- Apply any faction overrides.
        for _, name in ipairs(unitOverrides) do
            local unitOverride = assert(_unitOverrides[name])
            if unitOverride.override == unitType then
                apply(attrs, unitOverride)
                attrs.name = name
            end
        end

        -- Apply any unit upgrades.
        for _, name in ipairs(unitOverrides) do
            local unitOverride = _unitOverrides[name]
            if unitOverride.upgrade == unitType then
                apply(attrs, unitOverride)
                attrs.name = name
            end
        end
    end
    return result
end

function applyRollModifiers(unitAttrs, myColor, myRollModifiers, opponentColor, opponentRollModifiers)
    assert(type(unitAttrs) == 'table')
    assert(type(myColor) == 'string' and type(myRollModifiers) == 'table')
    assert(type(opponentColor) == 'string' and type(opponentRollModifiers) == 'table')

    unitAttrs = _copy(unitAttrs)
    local modifiers = {}

    local mySet = {}
    for _, name in ipairs(myRollModifiers) do
        mySet[name] = true
    end
    local opponentSet = {}
    for _, name in ipairs(opponentRollModifiers) do
        opponentSet[name] = true
    end

    if opponentSet['Antimass Deflectors'] then
        table.insert(modifiers, 'Antimass Deflectors')
        for _, attr in pairs(unitAttrs) do
            if attr.spaceCannon then
                attr.spaceCannon.hit = attr.spaceCannon.hit + 1
            end
        end
    end

    if mySet['Blitz'] then
        table.insert(modifiers, 'Blitz')
        for unitType, attr in pairs(unitAttrs) do
            if _nonFighterShipSet[unitType] and not attr.bombardment then
                attr.bombardment = { dice = 1, hit = 6 }
            end
        end
    end

    -- TODO XXX MORE MODIFIERS HERE

    return unitAttrs, modifiers
end

--- Get a table from player color to list of unit override names.
function getColorToUnitOverrides()
    local colorToUnitOverrideSet = {}

    local function addOverride(color, name)
        local entry = colorToUnitOverrideSet[color]
        if not entry then
            entry = {}
            colorToUnitOverrideSet[color] = entry
        end
        entry[name] = true
    end

    -- Faction overrides (only get overrides, not upgrades!)
    for color, faction in pairs(_factionHelper.allFactions()) do
        if faction then
            if faction.flagship then
                addOverride(color, faction.flagship)
            end
            for _, unit in ipairs(faction.units or {}) do
                local attrs = _unitOverrides[unit]
                if attrs.override then
                    addOverride(color, unit)
                end
            end
        end
    end

    -- Unit upgrade cards (or Franken tiles for faction overrides).
    local tagSet = { ['Card'] = true, ['Tile'] = true }
    local inHandGuidSet = _zoneHelper.inHand()
    local guidToName = {}
    local guidToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local guid = object.getGUID()
        local name = object.getName()
        if (not object.is_face_down) and (not inHandGuidSet[guid]) and tagSet[object.tag] and _unitOverrides[name] then
            guidToName[guid] = name
            guidToPosition[guid] = object.getPosition()
        end
    end
    local guidToZoneColor = _zoneHelper.zonesFromPositions(guidToPosition)
    for guid, zoneColor in pairs(guidToZoneColor) do
        local name = guidToName[guid]
        addOverride(zoneColor, name)
    end

    local colorToUnitOverrides = {}
    for color, unitOverrideSet in pairs(colorToUnitOverrideSet) do
        local entry = {}
        for name, _ in pairs(unitOverrideSet) do
            table.insert(entry, name)
        end
        colorToUnitOverrides[color] = entry
    end
    return colorToUnitOverrides
end

--- Get a table from player color to list of roll modifier names.
function getColorToRollModifiers()
    local colorToRollModifierSet = {}

    local function addModifier(color, name)
        local entry = colorToRollModifierSet[color]
        if not entry then
            entry = {}
            colorToRollModifierSet[color] = entry
        end
        entry[name] = true
    end

    -- Faction abilities.
    for color, faction in pairs(_factionHelper.allFactions()) do
        for _, ability in ipairs(faction and faction.abilities or {}) do
            if _rollModifiers[ability] then
                addModifier(color, ability)
            end
        end
    end

    -- Cards/Franken tiles.  Add "anywhereOnTable" to ALL colors.
    local tagSet = { ['Card'] = true, ['Tile'] = true }
    local inHandGuidSet = _zoneHelper.inHand()
    local guidToName = {}
    local guidToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local guid = object.getGUID()
        local name = object.getName()
        if (not object.is_face_down) and (not inHandGuidSet[guid]) and tagSet[object.tag] and _rollModifiers[name] then
            name = _rollModifiers[name].alias or name
            guidToName[guid] = name
            guidToPosition[guid] = object.getPosition()
            if _rollModifiers[name].anywhereOnTable then
                for _, color in ipairs(_zoneHelper.getZones()) do
                    addModifier(color, name)
                end
            end
        end
    end
    local guidToZoneColor = _zoneHelper.zonesFromPositions(guidToPosition)
    for guid, zoneColor in pairs(guidToZoneColor) do
        local name = guidToName[guid]
        addModifier(zoneColor, name)
    end

    local colorToRollModifiers = {}
    for color, rollModifiersSet in pairs(colorToRollModifierSet) do
        local entry = {}
        for name, _ in pairs(rollModifiersSet) do
            table.insert(entry, name)
        end
        colorToRollModifiers[color] = entry
    end
    return colorToRollModifiers
end

-------------------------------------------------------------------------------

local _objectNameToUnitData = false

function _init()
    -- Build a COMPLETE map from name to { unitType, color, count } attributes.
    -- This way table scans can do a simple membership check rather than
    -- string.match or other heavier lifting to identify units.  In some cases
    -- do not know the color.
    _objectNameToUnitData = {
        ['x1 Fighter Token'] = {
            tag = 'Tile',
            unitType = 'Fighter',
            count = 1
        },
        ['x3 Fighter Token'] = {
            tag = 'Tile',
            unitType = 'Fighter',
            count = 3
        },
        ['x1 Infantry'] = {
            tag = 'Tile',
            unitType = 'Infantry',
            count = 1
        },
        ['x3 Infantry'] = {
            tag = 'Tile',
            unitType = 'Infantry',
            count = 3
        },
    }

    -- Add flagships.  Do not know the color (and may change).
    for _, faction in pairs(_factionHelper.allFactions(true)) do
        _objectNameToUnitData[faction.flagship] = {
            tag = 'Generic',
            unitType = 'Flagship',
            count = 1,
            factionTokenName = faction.tokenName
        }
    end

    -- Add units.
    for _, color in ipairs(Player.getColors()) do
        for unitType, _ in pairs(_unitTypes) do
            local name = color .. ' ' .. unitType
            _objectNameToUnitData[name] = {
                tag = unitType == 'Infantry' and 'Figurine' or 'Generic',
                unitType = unitType,
                count = 1,
                color = color
            }
        end
    end
end

--- Get all units on the table.  Unit data tables contain:
-- { unitType, count, color, hex } keys.  Tokens and flagships have no color,
-- call fillUnitColors to add them.
-- @return table : list of unit data tables.
function units()
    local result = {}
    local guidToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local unitData = _objectNameToUnitData[object.getName()]
        if unitData and unitData.tag == object.tag then
            local unitData = _copy(tagSetAndUnitData.unitData)
            unitData.guid = object.getGUID()
            unitData.position = object.getPosition()
            table.insert(result, unitData)
            guidToPosition[unitData.guid] = unitData.position
        end
    end
    local guidToHex = _systemHelper.hexesFromPositions(guidToPosition)
    for _, unitData in ipairs(result) do
        unitData.hex = guidToHex[unitData.guid]
    end
    return result
end

--- Set colors for anonymous tokens to closest with-color unit in the same hex.
-- @param units table : list of unit data tables.
-- @return table : list of unit data tables with colors added.
function fillUnitColors(units)
    units = _copy(units)
    local hexToHaveColorUnits = {}
    local hexToNeedColorUnits = {}
    for _, unit in ipairs(units) do
        if unit.factionTokenName then
            local faction = unit.factionTokenName and _factionHelper.fromTokenName(unit.factionTokenName)
            unit.color = faction and faction.color
        end
        if unit.color then
            local entry = hexToHaveColorUnits[unit.hex]
            if not entry then
                entry = {}
                hexToHaveColorUnits[unit.hex] = {}
            end
            table.insert(entry, unit)
        else
            local entry = hexToNeedColorUnits[unit.hex]
            if not entry then
                entry = {}
                hexToNeedColorUnits[unit.hex] = {}
            end
            table.insert(entry, unit)
        end
    end

    -- Set need-color units to closest have-color.
    for hex, needColorUnits in pairs(hexToNeedColorUnits) do
        local haveColorUnits = hexToHaveColorUnits[hex] or {}
        local p0 = needColorUnit.position
        local bestDistanceSq, bestColor = false, false
        for _, needColorUnit in ipairs(needColorUnits) do
            local p1 = haveColorUnit.position
            local dSq = (p0.x - p1.x) ^ 2 + (p0.z - p1.z) ^ 2
            if not bestDistanceSq or dSq < bestDistanceSq then
                bestHaveColorUnit = haveColorUnit
                bestDistanceSq = dSq
            end
            if bestHaveColorUnit then
                needColorUnit.color = bestHaveColorUnit.color
            end
        end
    end
    return units
end

-------------------------------------------------------------------------------

function injectUnitOverride(unitOverride)
end

-------------------------------------------------------------------------------

function _copy(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and _copy(v) or v
        end
        t = copy
    end
    return t
end

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_UNIT_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    self.addContextMenuItem('Verify tables', _verifyTables)
    self.addContextMenuItem('Verify factions', _verifyFactions)
    self.addContextMenuItem('Dump attributes', _dumpAttributes)

    _init()
end

function _verifyTables()
    for name, attrs in pairs(_unitTypes) do
        _validateUnitType(name, attrs)
    end
    for name, override in pairs(_unitOverrides) do
        _validateUnitOverride(name, override)
    end
    print('verifyTables: done')
end

function _verifyFactions()
    for _, faction in ipairs(_factionHelper.allFactions(true)) do
        local flagship = assert(faction.flagship)
        assert(_unitOverrides[flagship], 'Missing flagship "' .. flagship .. '" ("' .. faction.name .. '")')
        for _, unit in ipairs(faction.units) do
            assert(_unitOverrides[unit], 'Missing unit "' .. unit .. '" ("' .. faction.name .. '")')
        end
    end
    print('verifyFactions: done')
end

function _dumpAttributes()
    -- Ideally this would be inside a coroutine with a yield(0) between most items.
    local colorToUnitOverrides = getColorToUnitOverrides()
    local colorToRollModifiers = getColorToRollModifiers()

    for _, color in ipairs(_zoneHelper.zones()) do
        local unitOverrides = colorToUnitOverrides[color] or {}
        local unitAttrs = unitAttributes(unitOverrides)

        local myColor = color
        local myRollModifiers = colorToRollModifiers[color] or {}
        local opponentColor = ''
        local opponentRollModifiers = {}
        local unitAttrs, modifiers = applyRollModifiers(unitAttrs, myColor, myRollModifiers, opponentColor, opponentRollModifiers)

        local summary = unitAttributesSummary(unitAttrs)
        print(string.upper(color) .. ':\n' .. summary)
    end
end

-------------------------------------------------------------------------------

function _validateUnitType(unitType, unitAttributes)
    assert(type(unitType) == 'string' and type(unitAttributes) == 'table')
    for k, v in pairs(unitAttributes) do
        if k == 'antiFighterBarrage' then
            assert(v.dice, unitType .. '.antiFighterBarrage.dice')
            assert(v.hit, unitType .. '.antiFighterBarrage.hit')
        elseif k == 'bombardment' then
            assert(v.dice, unitType .. '.bombardment.dice')
            assert(v.hit, unitType .. '.bombardment.hit')
        elseif k == 'capacity' then
            assert(type(v) == 'number', unitType .. '.capacity')
        elseif k == 'cost' then
            assert(type(v) == 'number', unitType .. '.cost')
        elseif k == 'groundCombat' then
            assert(v.dice, unitType .. '.groundCombat.dice')
            assert(v.hit, unitType .. '.groundCombat.hit')
        elseif k == 'move' then
            assert(type(v) == 'number', unitType .. '.move')
        elseif k == 'planetaryShield' then
            assert(type(v) == 'boolean', unitType .. '.planetaryShield')
        elseif k == 'production' then
            assert(type(v) == 'number', unitType .. '.production')
        elseif k == 'spaceCannon' then
            assert(v.dice, unitType .. '.spaceCannon.dice')
            assert(v.hit, unitType .. '.spaceCannon.hit')
        elseif k == 'spaceCombat' then
            assert(v.dice, unitType .. '.spaceCombat.dice')
            assert(v.hit, unitType .. '.spaceCombat.hit')
        elseif k == 'sustainDamage' then
            assert(type(v) == 'boolean', unitType .. '.sustainDamage')
        else
            error('unknown unit type attribute ' .. unitType .. '.' .. k)
        end
    end
end

function _validateUnitOverride(name, unitOverride)
    assert(type(name) == 'string' and type(unitOverride) == 'table')

    assert(unitOverride.upgrade or unitOverride.override, name .. '.{upgrade|override}')

    for k, v in pairs(unitOverride) do
        if k == 'override' then
            assert(not unitOverride.upgrade)
            assert(_unitTypes[v], name .. '.override')
        elseif k == 'upgrade' then
            assert(not unitOverride.override)
            assert(_unitTypes[v], name .. '.upgrade')
        end
    end
end

-------------------------------------------------------------------------------
--- Partially lock the _G global variable table.
-- Include this AFTER creating any necessary globals to prevent new ones.
--
-- - Existing globals can still be read AND WRITTEN.
-- - Cannot read non-existent globals.
-- - Cannot write new globals.
--
-- This helps catch typos where what was meant to access a local instead
-- references a (hopefully non-existent) global, as well as forgetting to use
-- "local" when creating objects.
--
-- @author Darrell
-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)

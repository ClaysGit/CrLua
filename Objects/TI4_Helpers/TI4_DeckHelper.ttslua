--- Shared deck locations, etc.
-- @author Darrell

-- Users should copy this getHelperClient function, and use via:
--
-- local deckHelper = getHelperClient('TI4_DECK_HELPER')
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

-- Find decks based on placemats, that way can move mats and it just works.
local PLACEMAT_GUID = {
    SCORE = '7b15c0',
    DECKS = '6dac8e',
}

local DECKS = {
    ['Public Objectives I'] = {
        transform = {
            parentGuid = PLACEMAT_GUID.SCORE,  -- {-91.22, 0.01, -0.86} @ {7.13, 1.00, 7.13}
            deck = {
                position = { x = 1.23, y = 0, z = -0.53 },
                rotation = { x = 0, y = 0, z = 180 },
            }
        },
        cardNames = {
            'Corner the Market',
            'Develop Weaponry',
            'Diversify Research',
            'Erect a Monument',
            'Expand Borders',
            'Found Research Outposts',
            'Intimidate Council',
            'Lead From The Front',
            'Negotiate Trade Routes',
            'Sway the Council',
        },
    },
    ['Public Objectives II'] = {
        transform = {
            parentGuid = PLACEMAT_GUID.SCORE,
            deck = {
                position = { x = 1.23, y = 0, z = 0.53 },
                rotation = { x = 0, y = 0, z = 180 },
            }
        },
        cardNames = {
            'Centralize Galactic Trade',
            'Conquer the Weak',
            'Form Galactic Brain Trust',
            'Found a Golden Age',
            'Galvanize the People',
            'Manipulate Galactic Law',
            'Master the Sciences',
            'Revolutionize Warfare',
            'Subdue the Galaxy',
            'Unify the Colonies',
        },
    },
    ['Secret Objectives'] = {
        transform = {
            parentGuid = PLACEMAT_GUID.DECKS,
            deck = {
                position = { x = 0.95, y = 0, z = -0.5 },  -- {-89.74, 0.02, 19.46}
                rotation = { x = 0, y = 0, z = 180 },
            }
        },
        shuffleOnDiscard = true,
        cardNames = {
            'Adapt New Strategies',
            'Become the Gatekeeper',
            'Control the Region',
            'Cut Supply Lines',
            'Destroy Their Greatest Ship',
            'Establish A Perimeter',
            'Forge An Alliance',
            'Form a Spy Network',
            'Fuel the War Machine',
            'Gather A Mighty Fleet',
            'Learn Secrets of the Cosmos',
            'Make an Example of Their World',
            'Master the Laws of Physics',
            'Mine Rare Metals',
            'Monopolize Production',
            'Occupy the Seat of the Empire',
            'Spark a Rebellion',
            'Threaten Enemies',
            'Turn Their Fleets to Dust',
            'Unveil Flagship',
        },
    },
    ['Agenda'] = {
        transform = {
            parentGuid = PLACEMAT_GUID.DECKS,
            deck = {
                position = { x = 0.01, y = 0, z = -0.5 },
                rotation = { x = 0, y = 0, z = 180 },
            },
            discard = {
                position = { x = 0.01, y = 0, z = 0.5 },
                rotation = { x = 0, y = 0, z = 0 },
            }
        },
        cardNames = {
            'Anti-Intellectual Revolution',
            'Archived Secret',
            'Arms Reduction',
            'Classified Document Leaks',
            'Colonial Redistribution',
            'Committee Formation',
            'Compensated Disarmament',
            'Conventions of War',
            'Core Mining',
            'Demilitarized Zone',
            'Economic Equality',
            'Enforced Travel Ban',
            'Executive Sanctions',
            'Fleet Regulations',
            'Holy Planet of Ixth',
            'Homeland Defense Act',
            'Imperial Arbiter',
            'Incentive Program',
            'Ixthian Artifact',
            'Judicial Abolishment',
            'Minister of Commerce',
            'Minister of Exploration',
            'Minister of Industry',
            'Minister of Peace',
            'Minister of Policy',
            'Minister of Sciences',
            'Minister of War',
            'Miscount Disclosed',
            'Mutiny',
            'New Constitution',
            'Prophecy of Ixth',
            'Public Execution',
            'Publicize Weapon Schematics',
            'Regulated Conscription',
            'Representative Government',
            'Research Team - Biotic',
            'Research Team - Cybernetic',
            'Research Team - Propulsion',
            'Research Team - Warfare',
            'Seed of an Empire',
            'Senate Sanctuary',
            'Shard of the Throne',
            'Shared Research',
            'Swords to Plowshares',
            'Terraforming Initiative',
            'The Crown of Emphidia',
            'The Crown of Thanlos',
            'Unconventional Measures',
            'Wormhole Reconstruction',
            'Wormhole Research',
        },
    },
    ['Actions'] = {
        transform = {
            parentGuid = PLACEMAT_GUID.DECKS,  -- {-91.73, 0.01, 15.59} @ {3.97, 1.00, 3.97}
            deck = {
                position = { x = -0.97, y = 0, z = -0.5 },  -- {-93.41, 0.41, 19.38}
                rotation = { x = 0, y = 0, z = 180 },
            },
            discard = {
                position = { x = -0.97, y = 0, z = 0.5 },  -- {-89.74, 0.02, 19.46}
                rotation = { x = 0, y = 0, z = 0 },
            }
        },
        cardNames = {
            'Ancient Burial Sites',
            'Assassinate Representative',
            'Bribery',
            'Bunker',
            'Confusing Legal Text',
            'Construction Rider',
            'Courageous to the End',
            'Cripple Defenses',
            'Diplomacy Rider',
            'Direct Hit (1)',
            'Direct Hit (2)',
            'Direct Hit (3)',
            'Direct Hit (4)',
            'Disable',
            'Distinguished Councilor',
            'Economic Initiative',
            'Emergency Repairs',
            'Experimental Battlestation',
            'Fighter Prototype',
            'Fire Team',
            'Flank Speed (1)',
            'Flank Speed (2)',
            'Flank Speed (3)',
            'Flank Speed (4)',
            'Focused Research',
            'Frontline Deployment',
            'Ghost Ship',
            'Imperial Rider',
            'In the Silence of Space',
            'Industrial Initiative',
            'Infiltrate',
            'Insubordination',
            'Intercept',
            'Leadership Rider',
            'Lost Star Chart',
            'Lucky Shot',
            'Maneuvering Jets (1)',
            'Maneuvering Jets (2)',
            'Maneuvering Jets (3)',
            'Maneuvering Jets (4)',
            'Mining Initiative',
            'Morale Boost (1)',
            'Morale Boost (2)',
            'Morale Boost (3)',
            'Morale Boost (4)',
            'Parley',
            'Plague',
            'Political Stability',
            'Politics Rider',
            'Public Disgrace',
            'Reactor Meltdown',
            'Reparations',
            'Repeal Law',
            'Rise of a Messiah',
            'Sabotage (1)',
            'Sabotage (2)',
            'Sabotage (3)',
            'Sabotage (4)',
            'Salvage',
            'Shields Holding (1)',
            'Shields Holding (2)',
            'Shields Holding (3)',
            'Shields Holding (4)',
            'Signal Jamming',
            'Skilled Retreat (1)',
            'Skilled Retreat (2)',
            'Skilled Retreat (3)',
            'Skilled Retreat (4)',
            'Spy',
            'Summit',
            'Tactical Bombardment',
            'Technology Rider',
            'Trade Rider',
            'Unexpected Action',
            'Unstable Planet',
            'Upgrade',
            'Uprising',
            'Veto',
            'War Effort',
            'Warfare Rider',
            -- Codex action cards
            'Hack Election',
            'Harness Energy',
            'Blitz',
            'Fighter Conscription',
            'Forward Supply Base',
            'Rally',
            'War Machine (1)',
            'War Machine (2)',
            'War Machine (3)',
            'War Machine (4)',
            'Master Plan',
            'Insider Information',
            'Plagiarize',
            'Scramble Frequency',
            'Solar Flare',
            'Reflective Shielding',
            'Impersonation',
            'Sanction',
            'Counterstroke',
            'Ghost Squad',
        },
    },
}

local _lowerCardNameToDeckAttributes = false
local _discardCardQueue = {}
local _discardDeckQueue = {}
local _waitForDestroy = {}
local _dealQueue = {}
local _dealCoroutineIsActive = false

local function _getDeckAttributes(cardName)
    assert(type(cardName) == 'string')
    if not _lowerCardNameToDeckAttributes then
        _lowerCardNameToDeckAttributes = {}
        for _, attributes in pairs(DECKS) do
            for _, cardName in ipairs(attributes.cardNames) do
                _lowerCardNameToDeckAttributes[string.lower(cardName)] = attributes
            end
        end
    end
    return _lowerCardNameToDeckAttributes[string.lower(cardName)]
end

local function _getTransform(deckAttributes, deckOrDiscard)
    assert(type(deckAttributes) == 'table' and not deckOrDiscard or type(deckOrDiscard) == 'string')

    -- Get the requested transform.  If the request is for 'discard' and the
    -- deck does not have a discard, use the main deck instead.
    local transform = deckAttributes.transform[deckOrDiscard]
    if not transform and deckOrDiscard == 'discard' then
        transform = deckAttributes.transform['deck']
    end

    local parentGuid = deckAttributes.transform.parentGuid
    local parent = parentGuid and assert(getObjectFromGUID(parentGuid))
    local parentRot = parent and parent.getRotation()

    return {
        position = parent and parent.positionToWorld(transform.position) or {
            x = transform.position.x,  -- make a copy, caller may mutate!
            y = transform.position.y,
            z = transform.position.z
        },
        rotation = {
            x = transform.rotation.x + (parentRot and parentRot.x) or 0,
            y = transform.rotation.y + (parentRot and parentRot.y) or 0,
            z = transform.rotation.z + (parentRot and parentRot.z) or 0,
        }
    }
end

local function _getDeck(deckTransform)
    assert(type(deckTransform) == 'table')
    local hits = Physics.cast({
        origin       = deckTransform.position,
        direction    = { x = 0, y = -1, z = 0 },
        type         = 3,  -- box
        size         = { x = 0.1, y = 4, z = 0.1 },
    })

    -- First look for a deck.
    for _, hit in ipairs(hits or {}) do
        if hit.hit_object.tag == 'Deck' then
            return hit.hit_object
        end
    end

    -- Failing that check if there is a single card.
    for _, hit in ipairs(hits or {}) do
        if hit.hit_object.tag == 'Card' then
            return hit.hit_object
        end
    end
end

-------------------------------------------------------------------------------

--- Discard this card, optionally removing it from a contiainer.
function discardCard(params)
    assert(type(params) == 'table')
    assert(type(params.guid) == 'string')
    assert(type(params.name) == 'string')
    assert(not params.index or (type(params.index) == 'number' and params.index > 0))
    assert(not params.containerGuid or type(params.containerGuid) == 'string')
    assert(not params.waitForDestroy or type(params.waitForDestroy) == 'boolean')

    local deckAttributes = _getDeckAttributes(params.name)
    if deckAttributes then
        params.deckAttributes = deckAttributes
        if params.waitForDestroy then
            params.waitForDestroy = nil
            _waitForDestroy[params.guid] = function() discardCard(params) end
        else
            table.insert(_discardCardQueue, params)
            Wait.frames(_processCardDiscardQueue, 2 + 2 * (params.index or 0))
        end
        return true
    end
end

function _processCardDiscardQueue()
    local params = table.remove(_discardCardQueue, 1)
    if not params then
        return
    end

    local deckAttributes = assert(params.deckAttributes)
    local transform = assert(_getTransform(deckAttributes, 'discard'))
    transform.position.y = transform.position.y + 3 + (params.index or 0) / 10

    local container = false
    local cardObject = false
    if params.containerGuid then
        container = getObjectFromGUID(params.containerGuid)
        if not container then
            -- Container does not exist anymore.
            cardObject = getObjectFromGUID(params.guid)
        elseif container.tag == 'Deck' and container.remainder and container.remainder.getGUID() == params.guid then
            -- Card is the last card in the deck.
            cardObject = container.remainder
        else
            -- Card is presumably in the container.  Verify.
            local found = false
            for _, entry in ipairs(container.getObjects()) do
                if entry.guid == params.guid then
                    found = true
                    break
                end
            end
            assert(found)
        end
    else
        -- Find card on the table.
        cardObject = getObjectFromGUID(params.guid)
    end

    if cardObject then
        cardObject.setLock(false)
        cardObject.setPosition(transform.position)
        cardObject.setRotation(transform.rotation)
    elseif container then
        local isLocked = container.getLock()
        container.setLock(false)
        cardObject = container.takeObject({
            guid              = params.guid,
            position          = transform.position,
            rotation          = transform.rotation,
            smooth            = false,
        })
        container.setLock(isLocked)
        assert(cardObject)
    else
        error('discard card: no card or container to look for one ("' .. (params.name or '') .. '")')
    end

    if deckAttributes.shuffleOnDiscard then
        if deckAttributes._waitShuffleId then
            Wait.stop(deckAttributes._waitShuffleId)
        end
        local function delayedShuffle()
            deckAttributes._waitShuffleId = nil
            local transform = _getTransform(deckAttributes, 'discard')
            local deck = _getDeck(transform)
            if deck and deck.tag == 'Deck' then
                deck.shuffle()
            end
        end
        deckAttributes._waitShuffleId = Wait.time(delayedShuffle, 2)
    end
end

function discardDeck(params)
    assert(type(params) == 'table')
    assert(type(params.guid) == 'string')
    assert(type(params.name) == 'string')
    assert(not params.index or (type(params.index) == 'number' and params.index > 0))
    assert(not params.containerGuid or type(params.containerGuid) == 'string')
    assert(not params.waitForDestroy or type(params.waitForDestroy) == 'boolean')

    -- The "wait for destroy" flag means the deck is being added to a container
    -- and we should wait for TTS to destroy the (old) version being added to
    -- the bag before retrieving the (new) version from the bag.
    --
    -- In that case, only process it if will discard at least one card.
    local function hasCandidateCard()
        local deck = getObjectFromGUID(params.guid)
        if not deck then
            error('discard deck: missing deck "' .. params.name .. '" (' .. params.guid .. ')')
        end
        if deck.tag ~= 'Deck' then
            error('discard deck: "' .. deck.getName() .. '" is not a deck')
        end
        for _, entry in ipairs(deck.getObjects()) do
            if _getDeckAttributes(entry.name) then
                return true
            end
        end
    end

    if params.waitForDestroy then
        if hasCandidateCard() then
            params.waitForDestroy = nil
            _waitForDestroy[params.guid] = function() discardDeck(params) end
            return true
        end
    else
        table.insert(_discardDeckQueue, params)
        Wait.frames(_processDeckDiscardQueue, 2 + 2 * (params.index or 0))
        return true
    end
end

function _processDeckDiscardQueue()
    local params = table.remove(_discardDeckQueue, 1)
    if not params then
        return
    end

    local container = false
    local deckObject = false
    if params.containerGuid then
        container = getObjectFromGUID(params.containerGuid)
        if container then
            local pos = container.getPosition()
            deckObject = container.takeObject({
                guid              = params.guid,
                position          = { x = pos.x, y = pos.y + 5 + (params.index or 0), z = pos.z },
                smooth            = false,
            })
        end
    else
        deckObject = getObjectFromGUID(params.guid)
    end

    if not deckObject then
        error('discard deck: no deck ("' .. (params.name or '') .. '")')
    end
    Wait.frames(function() deckObject.setLock(true) end, 1)

    local numAccepted = 0
    local numRejected = 0
    for i, entry in ipairs(deckObject.getObjects()) do
        local accepted = discardCard({
            guid = entry.guid,
            name = entry.name,
            containerGuid = deckObject.getGUID(),
            index = i
        })
        if accepted then
            numAccepted = numAccepted + 1
        else
            numRejected = numRejected + 1
        end
    end

    -- If any cards were not discarded, return the remaining deck to any container.
    if numRejected > 0 then
        local function delayedFinish()
            deckObject.setLock(false)
            if deckObject.remainder then
                deckObject = deckObject.remainder
                deckObject.setLock(false)
            end
            if container then
                container.putObject(deckObject)
            end
        end
        Wait.frames(delayedFinish, 6 + 2 * numAccepted)
    end
end

-------------------------------------------------------------------------------

--- Is the given card in its discard pile?
function isDiscard(cardGuid)
    assert(type(cardGuid) == 'string')
    local cardObject = assert(getObjectFromGUID(cardGuid))
    assert(cardObject.tag == 'Card')
    local deckAttributes = assert(_getDeckAttributes(cardObject.getName()))
    local discardTransform = assert(_getTransform(deckAttributes, 'discard'))
    local p1 = cardObject.getPosition()
    local p2 = discardTransform.position
    local d = math.sqrt((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
    return d < 1
end

--- Make sure dropped card it not going to wrong deck/discard.
function _verifyCardDrop(cardObject)
    assert(type(cardObject) == 'userdata' and cardObject.tag == 'Card')

    local function insideDeckTransform(deckTransform)
        local p1 = cardObject.getPosition()
        local p2 = deckTransform.position
        local d = math.sqrt((p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2)
        return d < 1 and deckTransform.rotation
    end

    local function insideDeckOrDiscard(deckAttributes)
        local deckTransform = _getTransform(deckAttributes, 'deck')
        local discardTransform = _getTransform(deckAttributes, 'discard')
        return insideDeckTransform(deckTransform) or insideDeckTransform(discardTransform)
    end

    local deckAttributes = _getDeckAttributes(cardObject.getName())
    if not deckAttributes then
        return  -- does not belong to a known deck
    else
        local rotation = insideDeckOrDiscard(deckAttributes)
        if rotation then
            -- Make sure it has the correct rotation.
            local collide = false
            local fast = true
            cardObject.setRotationSmooth(rotation, collide, fast)
            return  -- dropped in the expected deck area.
        end
    end

    for name, otherDeckAttributes in pairs(DECKS) do
        if name ~= deckAttributes.deckName and insideDeckOrDiscard(otherDeckAttributes) then
            local message = {
                'Warning: card from the "',
                deckAttributes.deckName,
                '" deck was dropped in the "',
                otherDeckAttributes.deckName,
                '" area'
            }
            broadcastToAll(table.concat(message, ''), 'Red')
        end
    end
end

-------------------------------------------------------------------------------

function deal(params)
    assert(type(params) == 'table')
    assert(type(params.deck) == 'string')
    assert(type(params.color) == 'string')
    assert(type(params.count) == 'number' and params.count > 0)

    params.deckAttributes = assert(DECKS[params.deck], 'bad deck name')

    table.insert(_dealQueue, params)
    if not _dealCoroutineIsActive then
        startLuaCoroutine(self, 'dealCoroutine')
    end
end

function dealCoroutine()
    _dealCoroutineIsActive = true

    while #_dealQueue > 0 do
        local params = table.remove(_dealQueue, 1)
        local deckTransform = _getTransform(params.deckAttributes, 'deck')
        local deck = _getDeck(deckTransform)

        -- Deal as many cards as able.
        if deck then
            local dealCount = 0
            if deck.tag == 'Deck' then
                dealCount = math.min(params.count, deck.getQuantity())
            elseif deck.tag == 'Card' then
                dealCount = 1
            end
            params.count = params.count - dealCount
            deck.deal(dealCount, params.color)
            coroutine.yield(0)
        end

        -- If not able to deal all cards shuffle discard.
        if params.count > 0 then
            local discardTransform = _getTransform(params.deckAttributes, 'discard')
            local discard = _getDeck(discardTransform)

            if discard then
                local bounds = discard.getBoundsNormalized()
                discard.setPosition({
                    x = deckTransform.position.x,
                    y = deckTransform.position.y + bounds.size.y / 2,
                    z = deckTransform.position.z
                })
                discard.setRotation(deckTransform.rotation)
                discard.setName(params.deckAttributes.deckName)
                coroutine.yield(0)

                if discard.tag == 'Deck' then
                    discard.shuffle()
                    coroutine.yield(0)
                end

                -- Re-add to front of queue, reattempt next service.
                table.insert(_dealQueue, 1, params)
            else
                -- Not able to deal all and no discard pile?
                printToAll('Warning: not able to deal ' .. params.count .. ' card' .. (params.count > 1 and 's' or '' ) .. ' from "' .. params.deck .. '" deck to ' .. params.color, 'Red')
            end
        end
    end

    _dealCoroutineIsActive = false
    return 1
end

-------------------------------------------------------------------------------
-- Add top/bottom context menu on Agenda cards to discard to top/bottom.

local function _isAgendaCard(object)
    assert(type(object) == 'userdata')
    assert(DECKS['Agenda'], 'No agenda deck??')
    if object.tag == 'Card' then
        local deckAttributes = _getDeckAttributes(object.getName())
        return deckAttributes and deckAttributes.deckName == 'Agenda'
    end
end

local function _putAgendaCard(cardObject, onTop)
    assert(type(cardObject) == 'userdata' and cardObject.tag == 'Card' and type(onTop) == 'boolean')

    -- Cannot use normal discard method as this is not going to the discard pile.
    local transform = _getTransform(DECKS['Agenda'], 'deck')
    assert(transform)

    -- Teleport to near (jump out of hand, if in hand).
    -- DO NOT SET POSITION SMOOTH, GETS PULLED BACK TO HAND!
    local nearby = { x = transform.position.x * 0.8, y = transform.position.y + 5, z = transform.position.z * 0.8 }
    cardObject.setPosition(nearby)
    cardObject.setRotation(transform.rotation)

    -- Wait a moment for card to leave hand, then place.
    local function finishPut()
        -- Smooth to final position.
        transform.position.y = transform.position.y + (onTop and 3 or 0)
        local collide = false
        local fast = false  -- slow so can see it go bottom/top
        cardObject.setPositionSmooth(transform.position, collide, fast)
    end
    Wait.frames(finishPut, 2)
end

function onObjectLeaveContainer(container, leaveObject)
    if _isAgendaCard(leaveObject) then
        local function putTop(playerColor)
            printToAll('Put agenda top', playerColor)
            _putAgendaCard(leaveObject, true)
        end
        local function putBottom(playerColor)
            printToAll('Put agenda bottom', playerColor)
            _putAgendaCard(leaveObject, false)
        end
        leaveObject.addContextMenuItem('Place Agenda Top', putTop, false)
        leaveObject.addContextMenuItem('Place Agenda Bottom', putBottom, false)
    end
end

function onObjectEnterContainer(container, enterObject)
    if _isAgendaCard(enterObject) then
        enterObject.clearContextMenu()
    end
end

-------------------------------------------------------------------------------

function onObjectDestroy(dyingObject)
    local guid = dyingObject.getGUID()
    if _waitForDestroy[guid] then
        local callback = _waitForDestroy[guid]
        _waitForDestroy[guid] = nil
        callback()
    end
end

-------------------------------------------------------------------------------

function onObjectDrop(playerColor, droppedObject)
    if droppedObject.tag == 'Card' then
        _verifyCardDrop(droppedObject)
    end
end

-------------------------------------------------------------------------------

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_DECK_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    -- Add deck names to attributes.
    for deckName, attributes in pairs(DECKS) do
        attributes.deckName = deckName
    end

    -- Test methods.
    self.addContextMenuItem('Discard cards', testDiscardCards, false)
    self.addContextMenuItem('Discard deck', testDiscardDeck, false)
    self.addContextMenuItem('Deal 1', function(color) testDeal(color, 1) end, false)
    self.addContextMenuItem('Deal 3', function(color) testDeal(color, 3) end, false)
end

function testDiscardCards()
    -- Discard any loose cards.
    local cards = {}
    local decks = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' then
            print('found ' .. object.getName())
            table.insert(cards, object)
        elseif object.tag == 'Deck' then
            table.insert(decks, object)
        end
    end

    for i, card in ipairs(cards) do
        discardCard({
            guid = card.getGUID(),
            name = card.getName(),
            index = i
        })
    end

    -- Find and discard all the Sabotage cards from inside a deck.
    for _, deck in ipairs(decks) do
        local entries = {}
        for _, entry in ipairs(deck.getObjects()) do
            if string.match(entry.name, '^Sabotage') then
                table.insert(entries, entry)
            end
        end
        for i, entry in ipairs(entries) do
            discardCard({
                guid = entry.guid,
                name = entry.name,
                index = i,
                containerGuid = deck.getGUID()
            })
        end
    end
end

function testDiscardDeck()
    local decks = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Deck' then
            table.insert(decks, object)
        end
    end

    -- Test discard deck.
    for _, deck in ipairs(decks) do
        if deck.getName() == 'Actions' then
            discardDeck({
                guid = deck.getGUID(),
                name = deck.getName(),
                index = nil
            })
        end
    end
end

function testDeal(color, count)
    deal({
        deck = 'Actions',
        color = color,
        count = count,
    })
end

-------------------------------------------------------------------------------
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)

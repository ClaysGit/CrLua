--- Manage shared stategy card actions.
-- @author GarnetBear did the original influence counting
-- @author Darrell June 2020
-- include <~/CrLua/Objects/TI4_Helpers/TI4_StrategyCardHelper>

-- Users should copy this getHelperClient function, and in onLoad via:
--
-- local strategyCardHelper = getHelperClient('TI4_STRATEGY_CARD_HELPER')
-- strategyCardHelper.register({
--     guid = self.getGUID(),
--     position = { x = ..., y = ..., z = ... },
--     rotation = { x = ..., y = ..., z = ... },
--     onPlayCallback = 'clickedOnPlay'  -- gets clicking player color as argument
-- })
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')

local ALLOCATE_COMMAND_TOKENS = {
    localPosition = { x = -0.1, y = 1, z = -5 },
    localDX = -0.4
}

local STRATEGY_CARD_INITIATIVE = {
    ['Zero Strategy Token'] = 0,
    ['Leadership'] = 1,
    ['Diplomacy'] = 2,
    ['Diplomacy (Revised)'] = 2,
    ['Politics'] = 3,
    ['Construction'] = 4,
    ['Industry'] = 4.5,
    ['Trade'] = 5,
    ['Warfare'] = 6,
    ['Logistics'] = 6.5,
    ['Technology'] = 7,
    ['Imperial'] = 8
}

local STRATEGY_CARD_SHEET_NAME = 'Strategy Card Mat'

local x0, dx = 5.62, -3.77
local z0, dz = -0.73, 4.57

local STRATEGY_CARD_RETURN_POSITION = {
    ['Leadership'] = { x = x0, y = 0, z = z0, snap = true },
    ['Diplomacy'] = { x = x0 + dx, y = 0, z = z0, snap = true },
    ['Diplomacy (Revised)'] = { x = x0 + dx, y = 0, z = z0, snap = false },
    ['Politics'] = { x = x0 + dx * 2, y = 0, z = z0, snap = true },
    ['Construction'] = { x = x0 + dx * 3, y = 0, z = z0, snap = true },

    ['Trade'] = { x = x0, y = 0, z = z0 + dz, snap = true },
    ['Warfare'] = { x = x0 + dx, y = 0, z = z0 + dz, snap = true },
    ['Technology'] = { x = x0 + dx * 2, y = 0, z = z0 + dz, snap = true },
    ['Imperial'] = { x = x0 + dx * 3, y = 0, z = z0 + dz, snap = true },

    ['Industry'] = { x = x0 + dx * 4, y = 0, z = z0, snap = false },
    ['Logistics'] = { x = x0 + dx * 4, y = 0, z = z0 + dz, snap = false },
}

local _lowerNameToInfluence = false
local _guidToParameters = {}  -- strategy cards
local _strategyCardSheetGuid = false
local _allocatedTokenGuidToColor = {}  -- unassigned command tokens
local _putTokenGuidSet = {}

function getStrategyCardSheet()
    local result = _strategyCardSheetGuid and getObjectFromGUID(_strategyCardSheetGuid)
    if not result then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == STRATEGY_CARD_SHEET_NAME then
                _strategyCardSheetGuid = object.getGUID()
                result = object
                break
            end
        end
    end
    return result
end

function _setSnapPoints()
    local sheet = assert(getStrategyCardSheet())
    local snapPoints = {}
    local rotation = sheet.getRotation()
    rotation.y = rotation.y + 90
    for _, position in pairs(STRATEGY_CARD_RETURN_POSITION) do
        if position.snap then
            table.insert(snapPoints, {
                position = position,
                rotation = rotation,
                rotation_snap = true
            })
        end
    end
    sheet.setSnapPoints(snapPoints)
end

function register(parameters)
    assert(type(parameters) == 'table')
    assert(type(parameters.guid) == 'string')
    assert(type(parameters.ui) == 'string')
    assert(type(parameters.onPlayCallback) == 'string')

    _guidToParameters[parameters.guid] = parameters

    local strategyCard = assert(getObjectFromGUID(parameters.guid))
    strategyCard.clearButtons()

    local BUTTON_WIDTH = 500
    local BUTTON_HEIGHT = 200
    local BUTTON_FONT_SIZE = 100

    local position = { x = -0.2, y = -0.13, z = -1.25 }
    local rotation = { x = 0, y = 0, z = 180 }
    if parameters.flip then
        -- "Extra Strat Cards" are flipped.
        position.y = 0.13
        rotation.z = 0
    end

    self.setVar('play_' .. parameters.guid, function(_, playerColor) _onClickPlay(strategyCard, parameters, playerColor) end)
    strategyCard.clearButtons()
    strategyCard.createButton({
        click_function = 'play_' .. parameters.guid,
        function_owner = self,
        label = 'Play',
        position = position,
        rotation = rotation,
        width = BUTTON_WIDTH,
        height = BUTTON_HEIGHT,
        font_size = BUTTON_FONT_SIZE,
        tooltip = 'Show UI'
    })
end

-------------------------------------------------------------------------------

function _onClickPlay(strategyCard, parameters, playerColor)
    assert(type(strategyCard) == 'userdata' and type(parameters) == 'table' and type('playerColor') == 'string')

    -- Toggle visibility
    local seated = {}
    for _, color in pairs(getSeatedPlayers()) do
        table.insert(seated, color)
    end
    local active = UI.getAttribute(parameters.ui, 'active')
    active = string.lower(active) == 'true' and true or false
    if active or #seated == 0 then
        UI.setAttribute(parameters.ui, 'active', false)
    else
        UI.setAttribute(parameters.ui, "visibility", table.concat(seated, "|"))
        UI.setAttribute(parameters.ui, "active", true)
        -- Tell the card in case there is any custom handling there.
        broadcastToAll('Activating ' .. strategyCard.getName(), playerColor)
        strategyCard.call(parameters.onPlayCallback, playerColor)
    end
end

-------------------------------------------------------------------------------

function uniqueList(order)
    local result = {}
    local seenSet = {}
    for _, color in ipairs(order) do
        if not seenSet[color] then
            seenSet[color] = true
            table.insert(result, color)
        end
    end
    return result
end

function getInitiativeOrder()
    local guidToInitiative = {}
    local guidToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local initiative = STRATEGY_CARD_INITIATIVE[object.getName()]
        if initiative then
            local guid = object.getGUID()
            guidToInitiative[guid] = initiative
            guidToPosition[guid] = object.getPosition()
        end
    end

    local guidToZoneColor = _zoneHelper.zonesFromPositions(guidToPosition)

    local colorToInitiative = {}
    local strategyCardGuidToPlayerColor = {}
    for guid, initiative in pairs(guidToInitiative) do
        local color = guidToZoneColor[guid]
        if color then
            local vsValue = colorToInitiative[color] or initiative
            colorToInitiative[color] = math.min(initiative, vsValue)
        end
        if initiative > 0 then
            strategyCardGuidToPlayerColor[guid] = color or false  -- false so included in map
        end
    end

    -- Generate turn order, ONLY INCLUDE PLAYERS WITH INITIATIVE VALUES!
    -- (Skip non-grey "spectators", non-players that can interact with table.)
    local turnOrder = {}
    for color, _ in pairs(colorToInitiative) do
        table.insert(turnOrder, color)
    end
    table.sort(turnOrder, function(a, b) return colorToInitiative[a] < colorToInitiative[b] end)

    return {
        order = uniqueList(turnOrder),
        strategyCardGuidToPlayerColor = strategyCardGuidToPlayerColor
    }
end

-- Expose in case external wants to control end of phase.
function endStatusPhaseInInitiativeOrder(playerColorOrder)
    -- Return strategy cards.
    for guid, parameters in pairs(_guidToParameters) do
        local strategyCard = getObjectFromGUID(guid)
        if strategyCard then
            _returnStrategyCard(strategyCard)
        end
    end

    -- Be paranoid and make sure colors only appear once!
    local order = uniqueList(playerColorOrder or Turns.order)

    _doEndOfStatusPhase(order)
end

function recomputeInfluence(playerColor)
    assert(type(playerColor) == 'string')

    local voteCounterName = playerColor .. ' Player Votes'
    local voteCounter = false
    local lowerNameToCards = {}

    -- Gather other relevant objects in a single pass.
    local inHandGuidSet = _zoneHelper.inHand()
    for _, object in ipairs(getAllObjects()) do
        if not inHandGuidSet[object.getGUID()] then
            local name = object.getName()
            -- Unlike the other generic influence count, this one looks at face up only.
            if object.tag == 'Card' and not object.is_face_down then
                local lowerName = string.lower(name)
                local cards = lowerNameToCards[lowerName]
                if not cards then
                    cards = {}
                    lowerNameToCards[lowerName] = cards
                end
                table.insert(cards, object)
            elseif name == voteCounterName then
                voteCounter = object
            end
        end
    end

    -- Get just the cards in this player's zone.
    local guidToPosition = {}
    for _, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            guidToPosition[object.getGUID()] = object.getPosition()
        end
    end
    local guidToZone = _zoneHelper.zonesFromPositions(guidToPosition)
    local lowerNameToInZoneCards = {}
    for lowerName, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            if guidToZone[object.getGUID()] == playerColor then
                local inZoneCards = lowerNameToInZoneCards[lowerName]
                if not inZoneCards then
                    inZoneCards = {}
                    lowerNameToInZoneCards[lowerName] = inZoneCards
                end
                table.insert(inZoneCards, object)
            end
        end
    end

    if voteCounter then
        _countInfluence(playerColor, voteCounter, lowerNameToCards, lowerNameToInZoneCards)
    else
        _safeBroadcastToColor('No vote counter detected.', playerColor, {0.8,0.2,0.2})
    end
end

function dealAllActionCards(dealOrder)
    local lowerNameToCards = {}
    local isFranken = false

    -- Gather other relevant objects in a single pass.
    local inHandGuidSet = _zoneHelper.inHand()
    for _, object in ipairs(getAllObjects()) do
        if not inHandGuidSet[object.getGUID()] then
            local name = object.getName()
            if (object.tag == 'Card' and not object.is_face_down) or name == 'Scheming' or name == 'Versatile' then
                local lowerName = string.lower(name)
                local cards = lowerNameToCards[lowerName]
                if not cards then
                    cards = {}
                    lowerNameToCards[lowerName] = cards
                end
                table.insert(cards, object)
            end
            isFranken = isFranken or string.match(name, '^TI4 MultiRoller') and string.find(string.lower(name), 'franken')
        end
    end

    -- Sort cards into per-player zones.
    local guidToPosition = {}
    for _, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            guidToPosition[object.getGUID()] = object.getPosition()
        end
    end
    local colorToLowerNameToInZoneCards = {}
    local guidToZone = _zoneHelper.zonesFromPositions(guidToPosition)
    for lowerName, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            local color = guidToZone[object.getGUID()]
            if color then
                local lowerNameToInZoneCards = colorToLowerNameToInZoneCards[color]
                if not lowerNameToInZoneCards then
                    lowerNameToInZoneCards = {}
                    colorToLowerNameToInZoneCards[color] = lowerNameToInZoneCards
                end
                local inZoneCards = lowerNameToInZoneCards[lowerName]
                if not inZoneCards then
                    inZoneCards = {}
                    lowerNameToInZoneCards[lowerName] = inZoneCards
                end
                table.insert(inZoneCards, object)
            end
        end
    end

    -- Be paranoid about repeats in the list.
    local order = uniqueList(dealOrder or Turns.order)

    for _, color in ipairs(order) do
        local faction = _factionHelper.fromColor(color)
        if not faction then
            _safeBroadcastToColor('No faction sheet detected for ' .. color .. '.', color, {0.8,0.2,0.2})
        end
        -- Franken do not benefit from faction attributes and may have different flagships.
        if isFranken then
            faction = false
        end

        local lowerNameToInZoneCards = colorToLowerNameToInZoneCards[color] or {}
        local numActionCards = _getDealActionCardsCount(color, faction, lowerNameToInZoneCards)
        _deckHelper.deal({
            deck = 'Actions',
            count = numActionCards,
            color = color
        })
    end
end

-------------------------------------------------------------------------------

function _returnStrategyCard(strategyCard)
    assert(type(strategyCard) == 'userdata')

    -- Look for political stability.  Would be nice to combine this with the
    -- other single-pass scan but keeping it separate makes it simpler.
    local function hasPoliticalStability(playerColor)
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'Political Stability' and not object.is_face_down then
                local inHandGuidSet = _zoneHelper.inHand()
                if inHandGuidSet[object.getGUID()] then
                    return false
                end
                return playerColor == _zoneHelper.zoneFromPosition(object.getPosition())
            end
        end
    end

    local playerColor = _zoneHelper.zoneFromPosition(strategyCard.getPosition())
    if playerColor and hasPoliticalStability(playerColor) then
        broadcastToAll(playerColor .. ' has Political Stability, not returning strategy card(s)', {0.1,0.5,0.1})
        return
    end

    local sheet = assert(getStrategyCardSheet())
    local offset = assert(STRATEGY_CARD_RETURN_POSITION[strategyCard.getName()])

    local position = sheet.positionToWorld(offset)
    local rotation = sheet.getRotation()

    local dx = strategyCard.getPosition().x - position.x
    local dz = strategyCard.getPosition().z - position.z
    local d = math.sqrt(dx ^ 2 + dz ^ 2)

    local parameters = _guidToParameters[strategyCard.getGUID()]
    if parameters.flip then
        rotation.z = (rotation.z + 180) % 360
    end

    if d > 1 then
        local collide = false
        local fast = true
        local abovePos = { x = position.x, y = position.y + 1, z = position.z}
        strategyCard.setLock(false)  -- paranoia
        strategyCard.setPositionSmooth(abovePos, collide, fast)
        strategyCard.setRotationSmooth(rotation, collide, fast)
        if playerColor then
            _safeBroadcastToColor('Returned Strategy Card ' .. strategyCard.getName() .. '.', playerColor, {1,1,1})
        end
    end
end

-------------------------------------------------------------------------------

function _safeBroadcastToColor(message, playerColor, messageColor)
    for _, player in ipairs(Player.getPlayers()) do
        if player.color == playerColor then
            broadcastToColor(message, playerColor, messageColor)
            return
        end
    end
    broadcastToAll(message, messageColor)
end

function _readyCards(playerColor, lowerNameToInZoneCards)
    assert(type(playerColor) == 'string' and type(lowerNameToInZoneCards) == 'table')
    for lowerName, inZoneCards in pairs(lowerNameToInZoneCards) do
        for _, card in ipairs(inZoneCards) do
            if card.is_face_down then
                card.flip()
            end
        end
    end
    _safeBroadcastToColor('Readied Cards.', playerColor, {1,1,1})
end

function _repairUnits(playerColor, units)
    assert(type(playerColor) == 'string' and type(units) == 'table')
    for _, unit in ipairs(units) do
        local rotation = unit.getRotation()
        if rotation.z > 90 and rotation.z < 270 then
            unit.flip()
        end
    end
    _safeBroadcastToColor('Repaired Units.', playerColor, {1,1,1})
end

function _countInfluence(playerColor, voteCounter, lowerNameToCards, lowerNameToInZoneCards)
    assert(type(playerColor) == 'string' and type(voteCounter) == 'userdata' and type(lowerNameToCards) == 'table' and type(lowerNameToInZoneCards) == 'table')

    if not _lowerNameToInfluence then
        _lowerNameToInfluence = {}
        for lowerName, planet in pairs(_systemHelper.planets()) do
            if (planet.influence or 0) > 0 then
                _lowerNameToInfluence[lowerName] = planet.influence
            end
        end
        for lowerName, attributes in pairs(_systemHelper.nonPlanetResourceInfluenceCards()) do
            if (attributes.influence or 0) > 0 then
                _lowerNameToInfluence[lowerName] = attributes.influence
            end
        end
    end

    local influence = 0
    for lowerName, inZoneCards in pairs(lowerNameToInZoneCards) do
        local cardInfluence = _lowerNameToInfluence[lowerName]
        if cardInfluence then
            influence = influence + (cardInfluence * #inZoneCards)
        end
    end

    -- This card can be anywhere on the table except agenda discard pile.
    local cards = lowerNameToCards['representative government']
    if cards then
        for _, card in ipairs(cards) do
            if not card.is_face_down and not _deckHelper.isDiscard(card.getGUID()) then
                _safeBroadcastToColor('Representative Government active.', playerColor, {0.1,0.5,0.1})
                influence = 1
                break
            end
        end
    end

    voteCounter.setValue(influence)
end

function _returnCommandTokens(playerColor, commandTokens, commandTokensBag, zoneExceptions)
    assert(type(playerColor) == 'string' and type(commandTokens) == 'table' and type(commandTokensBag) == 'userdata')

    local function insideException(p)
        local function _insideBounds(bounds, p)
            if p.x < bounds.center.x - bounds.size.x / 2 then return false end
            if p.x > bounds.center.x + bounds.size.x / 2 then return false end
            if p.z < bounds.center.z - bounds.size.z / 2 then return false end
            if p.z > bounds.center.z + bounds.size.z / 2 then return false end
            return true
        end
        for _, zoneException in ipairs(zoneExceptions) do
            if _insideBounds(zoneException.getBounds(), p) then
                return true
            end
        end
    end

    -- Only return command tokens not in a player zone.  Allow them to live
    -- in other player zones, just not on the map.
    local guidToCommandToken = {}
    local guidToPosition = {}
    for _, commandToken in ipairs(commandTokens) do
        local guid = commandToken.getGUID()
        guidToCommandToken[guid] = commandToken
        guidToPosition[guid] = commandToken.getPosition()
    end
    local guidToZone = _zoneHelper.zonesFromPositions(guidToPosition)
    for guid, commandToken in pairs(guidToCommandToken) do
        if not guidToZone[guid] or insideException(commandToken.getPosition()) then
            commandToken.setLock(false)  -- paranoia
            _putTokenGuidSet[guid] = true
            commandTokensBag.putObject(commandToken)
        end
    end

    _safeBroadcastToColor('Returned Command Tokens.', playerColor, {1,1,1})
end

function _getAllocateCommandTokensCount(playerColor, faction, lowerNameToInZoneCards)
    assert(type(playerColor) == 'string' and type(lowerNameToInZoneCards) == 'table')
    local result = 2
    local ownerFaction = _factionHelper.fromColor(playerColor)
    if faction and faction.extraCommandTokens then
        _safeBroadcastToColor('Faction extra command token active.', playerColor, {0.1,0.5,0.1})
        result = result + faction.extraCommandTokens
    end
    if lowerNameToInZoneCards['hyper metabolism'] then
        _safeBroadcastToColor('Hyper Metabolism active.', playerColor, {0.1,0.5,0.1})
        result = result + 1
    end
    if lowerNameToInZoneCards['versatile'] then
        _safeBroadcastToColor('Versatile active.', playerColor, {0.1,0.5,0.1})
        result = result + 1
    end
    if lowerNameToInZoneCards['cybernetic enhancements ω'] and ownerFaction.name ~= 'The L1Z1X Mindnet' then
        _safeBroadcastToColor('Cybernetic Enhancements Ω used. Returning to L1Z1X Mindnet player.', playerColor, {0.1,0.5,0.1})
        result = result + 1
        local mindnetColor = _factionHelper.fromTokenName('L1Z1X Mindnet').color
        if mindnetColor then
            lowerNameToInZoneCards['cybernetic enhancements ω'][1].deal(1, mindnetColor)
            _safeBroadcastToColor('Cybernetic Enhancements Ω used. Returned to your hand.', mindnetColor, {0.1,0.5,0.1})
        end
    end
    return result
end

function _allocateCommandTokens(playerColor, commandSheet, commandTokensBag, numCommandTokens)
    assert(type(playerColor) == 'string' and type(commandSheet) == 'userdata' and type(commandTokensBag) == 'userdata' and type(numCommandTokens) == 'number')
    -- Watch out for an empty bag!

    local pos = ALLOCATE_COMMAND_TOKENS.localPosition
    local dx = ALLOCATE_COMMAND_TOKENS.localDX
    for i = 1, numCommandTokens do
        if commandTokensBag.getQuantity() == 0 then
            _safeBroadcastToColor('You are out of Command Tokens.', playerColor, {0.8,0.2,0.2})
            break
        end
        local token = commandTokensBag.takeObject({
            position = commandSheet.positionToWorld({
                x = pos.x + (i * dx),
                y = pos.y + 1 + (i * 0.25),
                z = pos.z
            })
        })
        _addUnallocatedCommandToken(token, playerColor)
    end
    _safeBroadcastToColor('Gained Command Tokens.', playerColor, {1,1,1})
end

function _getDealActionCardsCount(playerColor, faction, lowerNameToInZoneCards)
    assert(type(playerColor) == 'string' and type(lowerNameToInZoneCards) == 'table')
    local result = 1
    if faction and faction.extraActionCards then
        _safeBroadcastToColor('Faction extra action cards active.', playerColor, {0.1,0.5,0.1})
        result = result + faction.extraActionCards
    end
    if lowerNameToInZoneCards['neural motivator'] then
        _safeBroadcastToColor('Neural Motivator active.', playerColor, {0.1,0.5,0.1})
        result = result + 1
    end
    if lowerNameToInZoneCards['scheming'] then
        _safeBroadcastToColor('Scheming active.', playerColor, {0.1,0.5,0.1})
        result = result + 1
    end
    if lowerNameToInZoneCards['minister of policy'] then
        _safeBroadcastToColor('Minister of Policy.', playerColor, {0.1,0.5,0.1})
        result = result + 1
    end
    return result
end

--- Move the speaker agenda token to match the speaker token.
function moveSpeakerAgendaToken()
    local speakerTokenName = 'Speaker Token'
    local speakerTokenAgendaName = 'Speaker Token - Agenda'

    local speakerToken = false
    local speakerTokenAgenda = false
    local colorToVoteCounter = {}

    for _, object in ipairs(getAllObjects()) do
        local name = object.getName()
        if name == speakerTokenName then
            speakerToken = object
        elseif name == speakerTokenAgendaName then
            speakerTokenAgenda = object
        end
        local color = string.match(name, '(.*) Player Votes')
        if color then
            colorToVoteCounter[color] = object
        end
    end

    if speakerToken and speakerTokenAgenda then
        local zoneColor = _zoneHelper.zoneFromPosition(speakerToken.getPosition())
        local voteCounter = zoneColor and colorToVoteCounter[zoneColor]
        if voteCounter then
            local pos = voteCounter.getPosition()
            pos.z = pos.z + 4.3 * (pos.z > 0 and 1 or -1)
            local rot = voteCounter.getRotation()
            rot.y = (rot.y + 180) % 360
            local collide = false
            local fast = true
            speakerTokenAgenda.setLock(false)  -- paranoia
            speakerTokenAgenda.setPositionSmooth(pos, collide, fast)
            speakerTokenAgenda.setRotationSmooth(rot, collide, fast)
        end
    end
end

-------------------------------------------------------------------------------

local function _doEndOfStatusPhaseCoroutineBody(playerColor)
    assert(type(playerColor) == 'string')

    local faction = _factionHelper.fromColor(playerColor)
    local tokenName = faction and faction.tokenName
    local commandTokenNameSet = {
        [(tokenName or playerColor) .. ' Command Token'] = true,
        [playerColor .. ' Command Token'] = true
    }
    local commandTokenBagNameSet = {
        [(tokenName or playerColor) .. ' Command Tokens Bag'] = true,
        [playerColor .. ' Command Tokens Bag'] = true
    }
    local unitNamePattern = '^' .. playerColor .. ' '
    local flagshipName = faction and faction.flagship
    local commandSheetName = 'Command Sheet (' .. playerColor .. ')'
    local voteCounterName = playerColor .. ' Player Votes'

    local zoneExceptionNameSet = {
        ['Ghosts of Creuss Tile'] = true,
    }
    local zoneExceptions = {}

    local commandTokens = {}
    local commandTokensBag = false
    local commandSheet = false
    local voteCounter = false
    local units = {}
    local lowerNameToCards = {}

    local isFranken = false

    -- Gather other relevant objects in a single pass.
    local inHandGuidSet = _zoneHelper.inHand()
    for _, object in ipairs(getAllObjects()) do
        if not inHandGuidSet[object.getGUID()] then
            local name = object.getName()
            if commandTokenNameSet[name] then
                table.insert(commandTokens, object)
            elseif object.tag == 'Bag' and commandTokenBagNameSet[name] then
                commandTokensBag = object
            elseif name == commandSheetName then
                commandSheet = object
            elseif name == voteCounterName then
                voteCounter = object
            elseif string.match(name, unitNamePattern) or name == flagshipName then
                table.insert(units, object)
            elseif zoneExceptionNameSet[name] then
                table.insert(zoneExceptions, object)
            elseif object.tag == 'Card' or name == 'Scheming' or name == 'Versatile' then
                local lowerName = string.lower(name)
                local cards = lowerNameToCards[lowerName]
                if not cards then
                    cards = {}
                    lowerNameToCards[lowerName] = cards
                end
                table.insert(cards, object)
            end

            isFranken = isFranken or string.match(name, '^TI4 MultiRoller') and string.find(string.lower(name), 'franken')
        end
    end
    coroutine.yield(0)

    -- Get just the cards in this player's zone.
    local guidToPosition = {}
    for _, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            guidToPosition[object.getGUID()] = object.getPosition()
        end
    end
    local guidToZone = _zoneHelper.zonesFromPositions(guidToPosition)
    local lowerNameToInZoneCards = {}
    for lowerName, cards in pairs(lowerNameToCards) do
        for _, object in ipairs(cards) do
            if guidToZone[object.getGUID()] == playerColor then
                local inZoneCards = lowerNameToInZoneCards[lowerName]
                if not inZoneCards then
                    inZoneCards = {}
                    lowerNameToInZoneCards[lowerName] = inZoneCards
                end
                table.insert(inZoneCards, object)
            end
        end
    end
    coroutine.yield(0)

    if not faction then
        _safeBroadcastToColor('No faction sheet detected for ' .. playerColor .. '.', playerColor, {0.8,0.2,0.2})
    end

    -- Franken do not benefit from faction attributes and may have different flagships.
    if isFranken then
        faction = false
    end

    _readyCards(playerColor, lowerNameToInZoneCards)
    _repairUnits(playerColor, units)

    -- Count ALL cards, may not be face up yet.
    if voteCounter then
        _countInfluence(playerColor, voteCounter, lowerNameToCards, lowerNameToInZoneCards)
    else
        _safeBroadcastToColor('No vote counter detected for ' .. playerColor .. '.', playerColor, {0.8,0.2,0.2})
    end

    local numCommandTokens = _getAllocateCommandTokensCount(playerColor, faction, lowerNameToInZoneCards)
    if commandTokensBag then
        _returnCommandTokens(playerColor, commandTokens, commandTokensBag, zoneExceptions)

        -- Wait for puts to complete (objects destroyed), otherwise TTS may
        -- pull out put-not-quite-finished tokens and things break.
        local function putPending()
            for _, _ in pairs(_putTokenGuidSet) do
                return true
            end
        end
        while putPending() do
            coroutine.yield(0)
        end
        coroutine.yield(0)
        coroutine.yield(0)

        _allocateCommandTokens(playerColor, commandSheet, commandTokensBag, numCommandTokens)
    else
        _safeBroadcastToColor('No token bag detected for ' .. playerColor .. '.', playerColor, {0.8,0.2,0.2})
    end
end

-------------------------------------------------------------------------------

local _endOfStatusPhasePlayerColors = false

function _doEndOfStatusPhase(playerColors)
    _endOfStatusPhasePlayerColors = playerColors
    startLuaCoroutine(self, '_doEndOfStatusPhaseCoroutine')
end

function _doEndOfStatusPhaseCoroutine()
    local playerColors = _endOfStatusPhasePlayerColors
    _endOfStatusPhasePlayerColors = false
    assert(type(playerColors) == 'table')

    -- Do all end of status phase actions.
    for _, playerColor in ipairs(playerColors) do
        assert(type(playerColor) == 'string')
        _doEndOfStatusPhaseCoroutineBody(playerColor)
        coroutine.yield(0)
    end

    moveSpeakerAgendaToken()
    coroutine.yield(0)

    return 1 -- REQUIRED to exit coroutine
end

-------------------------------------------------------------------------------

function _addUnallocatedCommandToken(object, color)
    local guid = object.getGUID()
    _allocatedTokenGuidToColor[guid] = color
    _resetUnallocatedCommandTokenSignal()
end

function _clearUnallocatedCommandToken(object)
    local guid = object.getGUID()
    if _allocatedTokenGuidToColor[guid] then
        _allocatedTokenGuidToColor[guid] = nil
        _resetUnallocatedCommandTokenSignal()
    end
end

local _resetUnallocatedCommandTokenWaitId = false

function _resetUnallocatedCommandTokenSignal()
    local function delayed()
        _resetUnallocatedCommandTokenWaitId = false

        local colorToUnallocatedCount = {}
        for guid, color in pairs(_allocatedTokenGuidToColor) do
            colorToUnallocatedCount[color] = (colorToUnallocatedCount[color] or 0) + 1
        end

        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Counter' then
                local color = string.match(object.getName(), '(.*) Player Votes')
                if color then
                    if colorToUnallocatedCount[color] then
                        object.createButton({
                            click_function = 'doNothing',
                            function_owner = self,
                            label          = 'Please allocate\nCommand Tokens',
                            position       = { x = 0, y = 0.24, z = 0.25 },
                            rotation       = { x = 0, y = 180, z = 0 },
                            width          = 400,
                            height         = 50,
                            font_size      = 40,
                            color          = 'White',
                            font_color     = 'Black',
                        })
                    else
                        object.clearButtons()
                    end
                end
            end
        end
    end

    if _resetUnallocatedCommandTokenWaitId then
        Wait.stop(_resetUnallocatedCommandTokenWaitId)
        _resetUnallocatedCommandTokenWaitId = false
    end
    _resetUnallocatedCommandTokenWaitId = Wait.frames(delayed, 5)
end

function doNothing()
end

-------------------------------------------------------------------------------

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_STRATEGY_CARD_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    -- Place snap points where strategy cards live.
    _setSnapPoints()
end

function onObjectPickUp(playerColor, pickedUpObject)
    assert(type(playerColor) == 'string', type(pickedUpObject) == 'userdata')

    -- Merely picking up an allocated token clears "unassigned".
    _clearUnallocatedCommandToken(pickedUpObject)
end

function onObjectDestroy(dyingObject)
    _putTokenGuidSet[dyingObject.getGUID()] = nil
    _clearUnallocatedCommandToken(dyingObject)
end

-------------------------------------------------------------------------------
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)

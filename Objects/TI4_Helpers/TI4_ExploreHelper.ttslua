-- @author Darrell for context menu stuff
-- @author Milty for adapting to exploration
-- #include <~/CrLua/Objects/TI4_Helpers/TI4_ExploreHelper>

local exploreCardToTokenMap = {
    ["Propulsion Research Facility"] = {"Propulsion Research Facility Token"}, -- 1r1i or blue
    ["Cybernetic Research Facility"] = {"Cybernetic Research Facility Token"}, -- 1r1i or yellow
    ["Biotic Research Facility"] = {"Biotic Research Facility Token"}, -- 1r1i or green
    ["Warfare Research Facility"] = {"Warfare Research Facility Token"}, -- 1r1i or red
    ["Lazax Survivors"] = {"Lazax Survivors Token"}, -- 1r2i
    ["Rich World"] = {"Rich World Token"}, -- 1r
    ["Mining World"] = {"Mining World Token"}, -- 2r
    ["Dyson Sphere"] = {"Dyson Sphere Token"}, -- 2r1i
    ["Paradise World"] = {"Paradise World Token"}, -- 2i
    ["Tomb of Emphidia"] = {"Tomb of Emphidia Token"}, -- 1i
    ["Demilitarized Zone (PoK)"] = {"DMZ Token"},
    ["Gamma Wormhole"] = {"Gamma Wormhole Token"},
    ["Gamma Relay"] = {"Gamma Wormhole Token"},
    ["Mirage (Exploration)"] = {"Mirage Token", "Mirage", "Mirage Flight Academy"},
    ["Ion Storm"] = {"Ion Storm Token"},
    ["Stellar Converter"] = {"Stellar Converter Token"},
}

local attachTokens = {
    ['Propulsion Research Facility Token'] = {
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'blue' },
    },
    ['Cybernetic Research Facility Token'] = {
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'yellow' },
    },
    ['Biotic Research Facility Token'] = {
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'green' },
    },
    ['Warfare Research Facility Token'] = {
        faceUp = { resources = 1, influence = 1 },
        faceDown = { tech = 'red' },
    },
    ['Lazax Survivors Token'] = {
        faceUpOrDown = { resources = 1, influence = 2 },
    },
    ['Rich World Token'] = {
        faceUpOrDown = { resources = 1 },
    },
    ['Mining World Token'] = {
        faceUpOrDown = { resources = 2 },
    },
    ['Dyson Sphere Token'] = {
        faceUpOrDown = { resources = 2, influence = 1 },
    },
    ['Paradise World Token'] = {
        faceUpOrDown = { influence = 2 },
    },
    ['Tomb of Emphidia Token'] = {
        faceUpOrDown = { influence = 1 },
    },
    ['DMZ Token'] = {
        faceUpOrDown = {},
    },
}

-------------------------------------------------------------------------------

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _deckHelper = getHelperClient('TI4_DECK_HELPER')

local function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

-------------------------------------------------------------------------------

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_EXPLORE_HELPER')
    self.setDescription('Adds right-click exploration options to system tiles and frontier tokens, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    local function delayedAdd()
        local attachObjectGuids = {}
        for _, object in ipairs(getAllObjects()) do
            if isExplorable(object) then
                applyExplorationGoodness(object)
            elseif isFrontierToken(object) then
                applyFrontierGoodness(object)
            elseif AttachLib.isAttachToken(object) then
                table.insert(attachObjectGuids, object.getGUID())
            end
        end

        -- These are more expensive, spread them out.
        local function attachOnePerFrame()
            local guid = table.remove(attachObjectGuids)
            local object = getObjectFromGUID(guid)
            if object then
                AttachLib.attach(object)
            end
            if #attachObjectGuids > 0 then
                Wait.frames(attachOnePerFrame, 1)
            end
        end
        Wait.frames(attachOnePerFrame, 1)
    end
    Wait.frames(delayedAdd, 11)
end

function onObjectSpawn(object)
    if isExplorable(object) then
        applyExplorationGoodness(object)
    elseif isFrontierToken(object) then
        applyFrontierGoodness(object)
    elseif AttachLib.isAttachToken(object) then
        AttachLib.attach(object)
    end

    -- Give token when card is drawn.
    if object.tag == 'Card' and object.getName() == 'Stellar Converter' then
        local guid = object.guid
        local function delayedCheck()
            local object = getObjectFromGUID(guid)
            if object then
                checkCardForToken(object, false, false)
            end
        end
        Wait.time(delayedCheck, 5)
    end
end

function onObjectDrop(playerColor, droppedObject)
    if AttachLib.isAttachToken(droppedObject) then
        AttachLib.attach(droppedObject)
    end
end

function onObjectPickUp(playerColor, pickupObject)
    if AttachLib.isAttachToken(pickupObject) then
        AttachLib.detach(pickupObject)
    end
end

-------------------------------------------------------------------------------

function applyExplorationGoodness(object)
    assert(type(object) == 'userdata')
    if object.getName() == 'Mirage Token' then
        local function exploreMirage()
            -- System tile has correct data when Mirage dropped there, but
            -- since Mirage can move re-find system when asked to explore.
            local system = _systemHelper.systemFromPosition(object.getPosition())
            if system then
                explorePlanet(system.guid, 'Mirage')
            else
                print('Mirage not attached to a system, cannot explore')
            end
        end
        object.addContextMenuItem('Explore Mirage', exploreMirage, false)
    else
        local systemList = _systemHelper.systems()
        local planetList = systemList[object.getGUID()].planets
        if planetList ~= nil then
            for i, planet in ipairs(planetList) do
                if planet.trait ~= nil then
                    object.addContextMenuItem('Explore ' .. planet.name, function() explorePlanet(object.getGUID(), planet.name) end, false)
                end
            end
        end
    end
end

function applyFrontierGoodness(object)
    assert(type(object) == 'userdata')
    object.addContextMenuItem('Explore Frontier', function() exploreFrontier(object) end, false)
end

function explorePlanet(tileGUID, planetName)
    local systemList = _systemHelper.systems()
    local planetTrait = false
    local deckType = false
    local tile = false
    local tilePos = false
    local planetPos = false
    local tileRot = false

    local traitMap = {
        ['cultural'] = 'Cultural Exploration',
        ['hazardous'] = 'Hazardous Exploration',
        ['industrial'] = 'Industrial Exploration'
    }

    for i, planet in ipairs(systemList[tileGUID].planets) do
        if planet.name == planetName then
            planetTrait = planet.trait
            planetPos = planet.position
        end
    end
    assert(planetTrait)

    deckType = traitMap[planetTrait]

    local tile = assert(getObjectFromGUID(tileGUID))
    local tilePos = tile.getPosition()
    local tileRot = tile.getRotation()

    local exploreDeckGuid = _deckHelper.getDeckWithReshuffle(deckType)
    if not exploreDeckGuid then
        print('ERROR: Unable to locate ' .. deckType .. ' deck.')
        return
    end
    local exploreDeck = assert(getObjectFromGUID(exploreDeckGuid))

    local position = tile.positionToWorld(planetPos)
    position.y = position.y + 3
    local rotation = { x = 0, y = tileRot.y, z = 0 }

    if exploreDeck.tag == 'Deck' then
        exploreDeck.takeObject({
          position = position,
          rotation = rotation,
          callback_function = function(obj) checkCardForToken(obj, tileGUID, planetName) end,
          smooth = true
        })
    elseif exploreDeck.tag == 'Card' then
        local collide = false
        local fast = true
        exploreDeck.setPositionSmooth(position, collide, fast)
        exploreDeck.setRotationSmooth(rotation, collide, fast)
    else
        error('exploreFrontier: bad "' .. deckType .. '" deck')
    end
    broadcastToAll('Exploring Planet: ' .. planetName)
end

function exploreFrontier(token)
    assert(type(token) == 'userdata')

    local tokenPos = token.getPosition()
    local tokenRot = token.getRotation()

    local frontierDeckGuid = _deckHelper.getDeckWithReshuffle('Frontier Exploration')
    if not frontierDeckGuid then
        print('ERROR: Unable to locate "Frontier Exploration" deck.')
        return
    end
    local frontierDeck = assert(getObjectFromGUID(frontierDeckGuid))

    local position = { x = tokenPos.x, y = tokenPos.y + 3, z = tokenPos.z }
    local rotation = { x = 0, y = 0, z = 0 }
    local system = _systemHelper.systemFromPosition(tokenPos)
    local systemObject = system and getObjectFromGUID(system.guid)
    if systemObject then
        rotation.y = systemObject.getRotation().y
    end

    if frontierDeck.tag == 'Deck' then
        frontierDeck.takeObject({
            position = position,
            rotation = rotation,
            callback_function = function(obj) checkCardForToken(obj, '', false) end,
            smooth = true
        })
    elseif frontierDeck.tag == 'Card' then
        local collide = false
        local fast = true
        frontierDeck.setPositionSmooth(position, collide, fast)
        frontierDeck.setRotationSmooth(rotation, collide, fast)
    else
        error('exploreFrontier: bad "Frontier Exploration" deck')
    end

    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag', 'Infinite'))
    frontierTokenBag.putObject(token)

    broadcastToAll('Exploring Frontier Token')
end

function checkCardForToken(object_spawned, tileGUID, planetName)
    local cardName = object_spawned.getName()
    local tokenList = exploreCardToTokenMap[cardName]

    if tokenList then
        local tokensToRetrieveSet = {}
        for _, item in ipairs(tokenList) do
            tokensToRetrieveSet[item] = true
        end

        local explorationBag = _getByName('Exploration Bag', 'Bag')
        local explorationBagContents = explorationBag.getObjects()
        for i, token in ipairs(explorationBagContents) do
            if tokensToRetrieveSet[token.name] then
                local objRot = object_spawned.getRotation()
                local techRot = 0
                if planetName then
                    local system = _systemHelper.systemFromGuid(tileGUID)
                    for _, planet in ipairs(system.planets) do
                        if planet.name == planetName then
                            if planet.tech ~= nil then techRot = 180 end
                        end
                    end
                end
                local position = object_spawned.getPosition()
                position.y = position.y + i * 0.3
                object_spawned.translate({ x = 0, y = 2, z = 0 })
                explorationBag.takeObject({
                    position = position,
                    rotation = {objRot.x, objRot.y, techRot},
                    guid = token.guid,
                    smooth = false
                })

                -- Only get each token once.
                tokensToRetrieveSet[token.name] = nil
            end
        end
    end
end

-------------------------------------------------------------------------------

local _systemGuids = false
function isExplorable(object)
    if not _systemGuids then
        _systemGuids = {}
        for guid, _ in pairs(_systemHelper.systems()) do
            _systemGuids[guid] = true
        end
    end
    if object.tag ~= 'Generic' then
        return false
    end
    if _systemGuids[object.getGUID()] then
        return true
    end
    if object.getName() == 'Mirage Token' then
        return true
    end
end

function isFrontierToken(object)
    return object.tag == 'Generic' and object.getName() == 'Frontier Token'
end

function getAllFrontierTokens()
    local frontierTokens = {}

    for _, object in ipairs(getAllObjects()) do
        if isFrontierToken(object) then
            table.insert(frontierTokens, object)
        end
    end

    return frontierTokens
end

local _getByNameCache = {}
function _getByName(name, tag)
    local guid = _getByNameCache[name]
    local object = guid and getObjectFromGUID(guid)
    if object and ((not tag) or object.tag == tag) then
        return object
    end
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == name and ((not tag) or object.tag == tag) then
            _getByNameCache[name] = object.getGUID()
            return object
        end
    end
    error('_getByName: missing "' .. name .. '"')
end

-------------------------------------------------------------------------------

-- Default position is slightly right of center
local DEFAULT_FRONTIER_TOKEN_POSITION = { x = -1, y = 0, z = 0 }

function systemShouldGetFrontierToken(system)
    if system.planets and #system.planets > 0 then
        return false
    end
    if system.hyperlane == true then
        return false
    end

    return true
end

function _placeFrontierTokensCoroutine()
    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag'))

    local guidToSystem = _systemHelper.systems()
    local emptySystemGuidToTokenPositions = {}
    local emptySystemGuidToPosition = {}
    local frontierTokenObjectsToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local system = guidToSystem[object.getGUID()]
        -- Collect all system tiles that are 'empty', along with the position a frontier token would go
        if system and systemShouldGetFrontierToken(system) then
            local tokenPosition = object.positionToWorld(DEFAULT_FRONTIER_TOKEN_POSITION)
            emptySystemGuidToPosition[object.getGUID()] = object.getPosition()
            emptySystemGuidToTokenPositions[object.getGUID()] = tokenPosition
        -- Collect all current frontier token positions
        elseif isFrontierToken(object) then
            frontierTokenObjectsToPosition[object.getGUID()] = object.getPosition()
        end
    end
    coroutine.yield(0)

    -- Find set of hex coordinates containing frontier tokens
    local frontierTokenGuidToHex = _systemHelper.hexesFromPositions(frontierTokenObjectsToPosition)
    local hexesWithFrontierTokens = {}
    for _, hex in pairs(frontierTokenGuidToHex) do
        hexesWithFrontierTokens[hex] = true
    end

    -- Empty systems to hex coordinates
    local emptySystemGuidToHex = _systemHelper.hexesFromPositions(emptySystemGuidToPosition)

    -- For each empty system, if it's hex coordinate doesn't have a frontier token then place a new one.
    for systemGuid, tokenPosition in pairs(emptySystemGuidToTokenPositions) do
        if emptySystemGuidToHex[systemGuid] and not hexesWithFrontierTokens[emptySystemGuidToHex[systemGuid]] then
            frontierTokenBag.takeObject({
                position = { x = tokenPosition.x, y = tokenPosition.y + 3, z = tokenPosition.z },
                smooth   = true,
            })
            coroutine.yield(0)
        end
    end

    return 1
end

function placeFrontierTokens()
    startLuaCoroutine(self, '_placeFrontierTokensCoroutine')
end

function retrieveFrontierTokens()
    local frontierTokenBag = assert(_getByName('Frontier Tokens Bag'))

    -- Grab all frontier tokens, from everywhere.
    for _, object in ipairs(getAllObjects()) do
        if isFrontierToken(object) then
            frontierTokenBag.putObject(object)
        end
    end
end

-------------------------------------------------------------------------------

AttachLib = {}

function AttachLib.isAttachToken(object)
    assert(type(object) == 'userdata')
    return attachTokens[object.getName()] and true or false
end

function AttachLib.attach(attachTokenObject)
    assert(type(attachTokenObject) == 'userdata')
    local attrs = assert(attachTokens[attachTokenObject.getName()])
    local system, planetName = AttachLib._getSystemAndPlanetName(attachTokenObject.getPosition())
    if planetName then
        AttachLib._injectAttachment(system, planetName, attachTokenObject)
        local card = AttachLib._getPlanetCard(planetName)
        if card then
            AttachLib._attachDecal(card, attachTokenObject)
        end
    end
end

function AttachLib.detach(attachTokenObject)
    assert(type(attachTokenObject) == 'userdata')
    local attrs = assert(attachTokens[attachTokenObject.getName()])
    local system, planetName = AttachLib._getSystemAndPlanetName(attachTokenObject.getPosition())
    if planetName then
        AttachLib._ejectAttachment(system, planetName, attachTokenObject)
        local card = AttachLib._getPlanetCard(planetName)
        if card then
            AttachLib._detachDecal(card, attachTokenObject)
        end
    end
end

function AttachLib._getSystemAndPlanetName(position)
    assert(type(position) == 'table')
    local system = _systemHelper.systemFromPosition(position)
    local planet = system and _systemHelper.planetFromPosition({
        systemGuid = system.guid,
        position = position,
        exact = false
    })
    local card = false
    if planet then
        -- Do NOT cache planet cards by guid, deck helper may change guids.
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Card' and object.getName() == planet.name then
                card = object
                break
            end
        end
    end
    return system, (planet and planet.name), card
end

--- Add attachment to a system's planet entry.
function AttachLib._injectAttachment(system, planetName, attachTokenObject)
    assert(type(system) == 'table' and type(planetName) == 'string' and type(attachTokenObject) == 'userdata')
    -- TODO
end

-- Remove attachment from a system's planet entry.  DO NOT USE CURRENT ORIENTATION,
-- token may have flipped, instead remove by name.
function AttachLib._ejectAttachment(system, planetName, attachTokenObject)
    assert(type(system) == 'table' and type(planetName) == 'string' and type(attachTokenObject) == 'userdata')
    -- TODO
end

--- Find the card object.
function AttachLib._getPlanetCard(planetName)
    assert(type(planetName) == 'string')
    -- Do NOT cache planet cards by guid, deck helper may change guids.
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Card' and object.getName() == planetName then
            return object
        end
    end
end

--- Add a decal to the planet card, with layout.
function AttachLib._attachDecal(planetCardObject, attachTokenObject)
    assert(type(planetCardObject) == 'userdata' and planetCardObject.tag == 'Card')
    assert(type(attachTokenObject) == 'userdata')
    local decalImage = false
    if attachTokenObject.is_face_down then
        decalImage = attachTokenObject.getCustomObject().image_bottom
    else
        decalImage = attachTokenObject.getCustomObject().image
    end
    if not decalImage then
        return  -- wrong object type with a different custom table?
    end
    local name = attachTokenObject.getName()
    local decals = planetCardObject.getDecals() or {}

    -- Remove if already present.
    for i, decal in ipairs(decals) do
        if decal.name == name then
            table.remove(decals, i)
        end
    end

    -- Add decal.
    local scale = { x = 0.6, y = 0.6, z = 1 } -- scale is literal size here
    table.insert(decals, {
        name = name,
        url = decalImage,
        position = { x = 0, y = 0.4, z = 0 },
        rotation = { x = 90, y = 180, z = 0 },
        scale = scale,
    })
    table.insert(decals, {
        name = name,
        url = decalImage,
        position = { x = 0, y = -0.4, z = 0 },
        rotation = { x = 270, y = 0, z = 0 },
        scale = scale,
    })
    AttachLib._layoutDecals(decals)
    planetCardObject.setDecals(decals)
end

--- Remove a decal from the planet card, with layout.
function AttachLib._detachDecal(planetCardObject, attachTokenObject)
    assert(type(planetCardObject) == 'userdata' and planetCardObject.tag == 'Card')
    assert(type(attachTokenObject) == 'userdata')
    local name = attachTokenObject.getName()
    local decals = planetCardObject.getDecals() or {}
    for i = #decals, 1, -1 do
        local decal = decals[i]
        if decal.name == name then
            table.remove(decals, i)
        end
    end
    AttachLib._layoutDecals(decals)
    planetCardObject.setDecals(decals)
end

--- Organize tokens for a grid layout, avoid planet res/inf and name areas.
function AttachLib._layoutDecals(decals)
    assert(type(decals) == 'table')
    local nextIndex = 0
    local nameToZeroBasedIndex = {}
    for _, decal in ipairs(decals) do
        if not nameToZeroBasedIndex[decal.name] then
            nameToZeroBasedIndex[decal.name] = nextIndex
            nextIndex = nextIndex + 1
        end
    end
    local x0 = 0.33
    local z0 = -1.1
    local dx = -0.66
    local dz = 0.65
    local numCols = 2
    for _, decal in ipairs(decals) do
        local zi = nameToZeroBasedIndex[decal.name]
        local row = math.floor(zi / numCols)
        local col = zi % numCols
        if row > 1 then
            row = row + 1.5 -- planet name area
        end
        decal.position = {
            x = x0 + dx * col,
            y = decal.position.y,
            z = z0 + dz * row
        }
        if decal.position.y < 0 then
            decal.position.x = -decal.position.x
        end
    end
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)

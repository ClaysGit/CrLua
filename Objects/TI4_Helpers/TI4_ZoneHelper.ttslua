--- Player zones.
-- @author Darrell

-- Users should copy this getHelperClient function, and use via:
--
-- local zoneHelper = getHelperClient('TI4_ZONE_HELPER')
-- local color = zoneHelper.zoneFromPosition(object.getPosition())
-- local guidToZone = zoneHelper.zonesFromPositions(guidToPosition)
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

-- Player zones table.
local _zones = {
    -- Defaults for 6p and 8p tables.  Map default zone color to XZ border points.
    defaults = {
        [6] = {
            zones = {
                Yellow = {{21, -50}, {21, -6}, {51, -6}, {51, -50}},
                Red = {{-21, -50}, {-21, -6}, {-1.5, -21}, {1.5, -21}, {21, -6}, {21, -50}},
                Green = {{-51, -50}, {-51, -6}, {-21, -6}, {-21, -50}},
                Purple = {{21, 6}, {21, 49}, {51, 49}, {51, 6}},
                Blue = {{-21, 6}, {-21, 49}, { 21, 49}, {21, 6}, {1.5, 21}, {-1.5, 21}},
                White = {{-51, 6}, {-51, 49}, {-21, 49}, {-21, 6}},
            },
            tableXZ = {{-48, -28}, {-48, 28}, {48, 28}, {48, -28}},
            y = 1,
        },
        [8] = {
            zones = {
                Pink = {{40.5, -100}, {40.5, -15}, {78, -15}, {78, -100}},
                White = {{0, -100}, {0, -15}, {40.5, -15}, {40.5, -100}},
                Red = {{-40.5, -100}, {-40.5, -15}, {0, -15}, {0, -100}},
                Orange = {{-78, -100}, {-78, -15}, {-40.5, -15}, {-40.5, -100}},
                Yellow = {{-78, 15}, {-78, 100}, {-40.5, 100}, {-40.5, 15}},
                Green = {{-40.5, 15}, {-40.5, 100}, {0, 100}, {0, 15}},
                Blue = {{0, 15}, {0, 100}, {40.5, 100}, {40.5, 15}},
                Purple = {{40.5, 15}, {40.5, 100}, {78, 100}, {78, 15}},
            },
            tableXZ = {{-78, -15}, {-78, 15}, {78, 15}, {78, -15}},
            y = 5,
        },
    },

    -- Current zones.
    y = false,
    zones = {},
    tableXZ = {},

    lastUpdate = false,
    periodicUpdateSeconds = 3,
}

-- Objects in players' hands.
local _inHand = {
    lastUpdateFrame = false,
    guidToColor = false,
}

function zoneColors()
    _maybeUpdateZones()
    local result = {}
    for zoneColor, zone in pairs(_zones.zones) do
        table.insert(result, zoneColor)
    end
    return result
end

--- Get zone color from position.
-- @param position table : {xyz} position.
-- @return string : zone color, or nil if not in zone.
function zoneColorFromPosition(position)
    assert(type(position) == 'table' and type(position.x) == 'number')
    _maybeUpdateZones()
    for zoneColor, zone in pairs(_zones.zones) do
        if _boundingBoxContains(zone.boundingBox, position) and _polygonContains(zone.polygon, position) then
            return zoneColor
        end
    end
end

--- Get the hand color if object is in player hand.
-- @param guid string.
-- @return string : player color holding object in hand, if held.
function handColorFromGuid(guid)
    if _inHand.lastUpdateFrame ~= Time.frame_count then
        _inHand.lastUpdateFrame = Time.frame_count
        _inHand.guidToColor = {}
        for _, player in ipairs(Player.getPlayers()) do
            for i = 1, player.getHandCount() do
                for _, object in ipairs(player.getHandObjects(i)) do
                    _inHand.guidToColor[object.guid] = player.color
                end
            end
        end
    end
    return _inHand.guidToColor[guid]
end

--- Given map from guids to positions, return map from guids to zone/hand.
-- This is a bulk operation to reduce call overhead.
-- @param keyToPosition table : arbitrary keys (e.g. guids) to {xyz} tables.
-- @return table : map from keys to zone colors.
function zoneAndHandColorsFromGuidsAndPositions(guidToPosition)
    assert(type(guidToPosition) == 'table')
    _maybeUpdateZones()
    local result = {}
    for guid, position in pairs(guidToPosition) do
        result[guid] = {
            zoneColor = zoneColorFromPosition(position),
            handColor = handColorFromGuid(guid)
        }
    end
    return result
end

--- Is position on the main table?
-- @param position table : {xyz} position.
-- @return boolean : true if on main table.
function inTableZone(position)
    assert(type(position) == 'table' and type(position.x) == 'number')
    _maybeUpdateZones()
    return _boundingBoxContains(_zones.table.boundingBox, position) and _polygonContains(_zones.table.polygon, position)
end

--- Get XYZ border about a zone (suitable for vector lines).
-- @param zoneColor string : zone color.
-- @return table : list of {xyz} points.
function zoneBorder(zoneColor)
    assert(type(zoneColor) == 'string')
    _maybeUpdateZones()
    local result = {}
    for _, xz in ipairs(_zones.zones[zoneColor] or {}) do
        table.insert(result, { x = xz[0], y = _zones.y, z = xz[1] })
    end
    return result
end

function _boundingBox(polygonXZ)
    assert(type(polygonXZ) == 'table')

    local min, max
    for i, vertex in ipairs(polygonXZ) do
        local x, z = vertex[1], vertex[2]
        if i == 1 then
            min = { x = x, z = z }
            max = { x = x, z = z }
        else
            min.x = math.min(min.x, x)
            min.z = math.min(min.z, z)
            max.x = math.max(max.x, x)
            max.z = math.max(max.z, z)
        end
    end
    return { min = min, max = max }
end

function _testBoundingBox()
    local polygon = { {0, 0}, {-1, 2}, {1, 0}, {0, -2} }
    local box = _boundingBox(polygon)
    assert(box.min.x == -1 and box.min.z == -2)
    assert(box.max.x == 1 and box.max.z == 2)
end

function _boundingBoxContains(boxXZ, position)
    assert(type(boxXZ) == 'table' and boxXZ.min and type(position) == 'table' and position.x)
    local gteMin = position.x >= boxXZ.min.x and position.z >= boxXZ.min.z
    local lteMax = position.x <= boxXZ.max.x and position.z <= boxXZ.max.z
    return gteMin and lteMax
end

function _testBoundingBoxContains()
    local box = _boundingBox({ {0, 0}, {2, 2} })
    assert(_boundingBoxContains(box, { x = 1, z = 1 }))
    assert(not _boundingBoxContains(box, { x = 3, z = 3 }))
end

--- Is the point inside the polygon (2D)?
-- Uses the "ray casting method".
-- @see https://love2d.org/wiki/PointWithinShape
--
-- @param polygonXZ table : list of 2d points, each point is a list of two numbers.
-- @param point table : list of 2 numbers.
-- @return boolean : true if point is inside polygon.
function _polygonContains(polygonXZ, position)
    assert(type(polygonXZ) == 'table' and type(position) == 'table' and position.x)

    local x, z = 1, 2
    local numverts = #polygonXZ
    local tx, tz = position.x, position.z
    local p0 = polygonXZ[numverts]

    -- get test bit for above/below X axis
    local zflag0 = p0[z] >= tz
    local insideFlag = false

    for _, p1 in ipairs(polygonXZ) do
        local zflag1 = p1[z] >= tz

        -- Check if endpoints straddle (are on opposite sides) of X axis
        -- (i.e. the Zs differ); if so, +X ray could intersect this edge.
        if zflag0 ~= zflag1 then
            -- Check intersection of pgon segment with +X ray.
            -- Note if >= point's X; if so, the ray hits it.
            if ((p1[z] - tz) * (p0[x] - p1[x]) >= (p1[x] - tx) * (p0[z] - p1[z])) == zflag1 then
                insideFlag = not insideFlag
            end
        end

        -- Move to the next pair of vertices, retaining info as possible.
        zflag0 = zflag1
        p0 = p1
    end

    return insideFlag
end

function _testPolygonContains()
    local polygon = { {0,0}, {0,2}, {2,2}, {2,0} }
    assert(_polygonContains(polygon, {1,1}))
    assert(not _polygonContains(polygon, {3,3}))
end

function _maybeUpdateZones()
    if not _zones.lastUpdate or (Time.time - _zones.lastUpdate) > _zones.periodicUpdateSeconds then
        _zones.lastUpdate = Time.time

        local colorToCommandSheet = {}
        local numCommandSheets = 0
        for _, object in ipairs(getAllObjects()) do
            local color = string.match(object.getName(), '^Command Sheet %((%a+)%)$')
            if color then
                colorToCommandSheet[color] = object
                numCommandSheets = numCommandSheets + 1
            end
        end

        local default = _zones.defaults[numCommandSheets] or _zones.defaults[6]
        _zones.y = default.y
        _zones.table = {
            polygon = default.tableXZ,
            boundingBox = _boundingBox(default.tableXZ)
        }
        _zones.zones = {}
        for color, commandSheet in pairs(colorToCommandSheet) do
            for _, polygon in pairs(default.zones) do
                if _polygonContains(polygon, commandSheet.getPosition()) then
                    _zones.zones[color] = {
                        polygon = polygon,
                        boundingBox = _boundingBox(polygon)
                    }
                    break
                end
            end
        end
    end
end

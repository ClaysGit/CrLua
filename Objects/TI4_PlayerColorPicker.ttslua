--- Change player color, both TTS Player and TI4 components.
-- This is a separate, explicit action not triggered by chaging color via TTS.
--
-- 1. Find objects owned by the "previous" color, searching the table including in
-- hands and even decks (stacked promissory notes?).  Place units in unit bags
-- and promissory notes into a notes deck, then pack all into the color bag.
--
-- 2. Get the hand current turn state, change color, create new hand and fix turns.
--
-- 3. Unpack objects from the new color bag, placing units and promissory notes
-- where we found the originals, including in hands or decks around the table.
--
-- Preserves vote counter value too, because this is already too complex.
--
-- There's some other nonsense with flagship names, uses hard-coded list of names.
-- Custom flagships might not be replaced, users may rename to "COLOR Flagship"
-- (don't forget the unit inside the bag too!) to include them in the switch.
--
-- @author v0.1.0 Mage
-- @author v2.0 Darrell June 2020
--
-- Darrell's hexbox: http://cloud-3.steamusercontent.com/ugc/1052100459404186281/643C6C76721F95244DC2AA1D3EF7D83529241FC1/

local TAG = 'ColorPicker'

local SWAP = {
    -- Only pack one copy of these, only expect one during unpack.
    SINGLETONS = {
        'Command Sheet ($COLOR)',
        '$COLOR Player Votes',
    },

    -- Move cards into deck, pack deck.  Only expect deck during unpack.
    DECKS = {
        ['Notes ($COLOR)'] = {
            'Trade Agreement ($COLOR)',
            'Support for the Throne ($COLOR)',
            'Political Secret ($COLOR)',
            'Ceasefire ($COLOR)',
        },
    },

    -- Move units into unit bags, pack (full) unit bags.  Unpack (full) bags.
    UNITS = {
        '$COLOR Infantry',
        '$COLOR Fighter',
        '$COLOR Cruiser',
        '$COLOR Destroyer',
        '$COLOR Carrier',
        '$COLOR Space Dock',
        '$COLOR PDS',
        '$COLOR Dreadnought',
        '$COLOR War Sun',
        '$COLOR Flagship'
    },

    -- These objects stay on table, just rename.
    SIMPLE_RENAME = {
        'Active/Passed ($COLOR)'
    }
}

-- Keep in 'contstant' rather than placing the string in code.
local ANONYMOUS_FLAGSHIP_NAME = '$COLOR Flagship'
local ANONYMOUS_PIECES_BAG_NAME = '$COLOR Player Pieces'

function onLoad(saveState)
    CrLua.Log.setLogLevel(CrLua.Log.LOG_LEVEL.DEBUG)
    Wait.time(resetUi, 0.2)
end

function onPlayerChangeColor(player_color)
    Wait.time(resetUi, 2)
end

function onObjectEnterContainer(container, enter_object)
    if container == self then
        Wait.time(resetUi, 2)
    end
end

function onObjectLeaveContainer(container, leave_object)
    if container == self then
        Wait.time(resetUi, 2)
    end
end

function filterObjectEnter(enterObject)
    return string.match(enterObject.getName(), ' Player Pieces$') and true or false
end

-------------------------------------------------------------------------------

local _values = {}

function resetUi()
    _values = {}
    self.UI.setXmlTable(buildXmlTable())
end

function buildXmlTable()
    -- get seated players will not find black.
    local prevColors = {}
    for _, object in ipairs(getAllObjects()) do
        local color = string.match(object.getName(), '^Command Sheet %((%a+)%)$')
        if color then
            table.insert(prevColors, color)
        end
    end
    table.sort(prevColors)
    local prevOptions = {
        {
            tag = 'Option',
            value = '---',
            selected = true,
        }
    }
    for _, color in ipairs(prevColors) do
        table.insert(prevOptions, {
            tag = 'Option',
            value = color,
        })
    end
    local nextColors = {}
    for _, entry in ipairs(self.getObjects()) do
        local color = string.match(entry.name, '(%u%l+) Player Pieces$')
        assert(color)
        table.insert(nextColors, color)
    end
    table.sort(nextColors)
    local nextOptions = {
        {
            tag = 'Option',
            value = '---',
            selected = true,
        }
    }
    for _, color in ipairs(nextColors) do
        if color ~= 'Grey' and color ~= 'Black' then
            table.insert(nextOptions, {
                tag = 'Option',
                value = color,
            })
        end
    end

    local fontSize = 20
    local dropdownWidth = 180
    local dropdownHeight = 30
    local buttonHeight = 50
    local buttonWidth = 100

    return {
        {
            tag = 'Panel',
            attributes = {
                position = '-10 0 -62',
                rotation = '0 0 90',
                width = 200,
                height = 270,
                --color = '#ff0000',
            },
            children = {
                {
                    tag = 'VerticalLayout',
                    attributes = {
                        padding = '10 10 10 10',
                        spacing = 10,
                        childForceExpandHeight = false,
                        childForceExpandWidth = false,
                        childAlignment = 'MiddleCenter',
                    },
                    children = {
                        {
                            tag = 'Text',
                            attributes = {
                                fontSize = fontSize,
                            },
                            value = 'Switch from color:'
                        },
                        {
                            tag = 'Dropdown',
                            attributes = {
                                id = 'prevColor',
                                onValueChanged = 'onValueChanged',
                                preferredWidth = dropdownWidth,
                                preferredHeight = dropdownHeight,
                            },
                            children = prevOptions
                        },
                        {
                            tag = 'Text',
                            attributes = {
                                fontSize = fontSize,
                            },
                            value = 'to color (scrollable):'
                        },
                        {
                            tag = 'Dropdown',
                            attributes = {
                                id = 'nextColor',
                                onValueChanged = 'onValueChanged',
                                preferredWidth = dropdownWidth,
                                preferredHeight = dropdownHeight,
                            },
                            children = nextOptions
                        },
                        {
                            tag = 'Text',
                            attributes = {
                                preferredHeight = 5,
                            }
                        },
                        {
                            tag = 'Button',
                            attributes = {
                                id = 'swapColors',
                                onClick = 'onButtonClick',
                                preferredWidth = buttonWidth,
                                preferredHeight = buttonHeight,
                                fontSize = fontSize,
                            },
                            value = 'Switch!'
                        }
                    }
                }
            }
        }
    }
end

-------------------------------------------------------------------------------

function onButtonClick(player, wha, id)
    if id == 'swapColors' then
        -- self.UI.getAttribute('prevColor', 'text') does not work?
        local prevColor = _values['prevColor']
        local nextColor = _values['nextColor']
        CrLua.Log.d(TAG, 'onButtonClick: prev=' .. tostring(prevColor) .. ' next=' .. tostring(nextColor))
        if prevColor and nextColor then
            swap(prevColor, nextColor)
        end
    end
end

function onValueChanged(player, value, id)
    CrLua.Log.d(TAG, 'onValueChanged: id=' .. tostring(id) .. ' value=' .. tostring(value))
    _values[id] = value
end

-------------------------------------------------------------------------------

function swap(prevColor, nextColor)
    assert(type(prevColor) == 'string' and type(nextColor) == 'string')

    local flagshipName = getFlagshipName(prevColor)
    CrLua.Log.d(TAG, 'swap: prev=' .. prevColor .. ' next=' .. nextColor .. ' flagship=' .. (flagshipName or 'nil'))

    -- Get to-pack items, make sure they are all there before swapping!
    local ruleToItems = getSwapRuleToItems(prevColor, nextColor, flagshipName)
    verifyRuleToItems(ruleToItems)

    -- TTS needs a frame to finish pack/unpack to let objects settle.  Do the
    -- swap in a coroutine, yielding after each take/put and other major state
    -- change (such as Player.changeColor).
    -- Rather than managing callback_function for barriers, just inspect state.
    local function swapCoroutineFunction()
        -- Do coroutine management manually vs startLuaCoroutine version.
        local swapCoroutine = coroutine.running()
        local function resumeSwapCoroutine()
            local success, errorMessage = coroutine.resume(swapCoroutine)
            if not success then
                error(TAG .. ': error in swap coroutine: ' .. (errorMessage or 'nil'))
            end
        end
        local function waitAndAutoResume()
            Wait.frames(resumeSwapCoroutine, 2)
            coroutine.yield(1)
        end

        local function isEntrySpawning(listOrTable)
            assert(type(listOrTable) == 'table')
            for _, entry in pairs(listOrTable) do
                if entry.spawning then
                    return true
                end
            end
        end
        local function isGuidActive(list)
            assert(type(list) == 'table')
            for _, guid in ipairs(list) do
                if getObjectFromGUID(guid) then
                    return true
                end
            end
        end

        local prevBag = getPiecesBag(prevColor, true, {-3, 3, 0})
        waitAndAutoResume()
        while prevBag.spawning do waitAndAutoResume() end

        local putGuids = packSingletons(ruleToItems, prevBag)
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        local deckRuleToCardObjects = retrieveCards(ruleToItems)
        while isEntrySpawning(deckRuleToCardObjects) do waitAndAutoResume() end
        waitAndAutoResume()

        local deckRuleToDeckObject, putGuids = packCardsIntoDecks(prevColor, deckRuleToCardObjects)
        deckRuleToCardObjects = nil
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        local putGuids = packDecks(deckRuleToDeckObject, prevBag)
        deckRuleToDeckObject = nil
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        local unitBags, putGuids = packUnitsIntoUnitBags(ruleToItems)
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        local flagships, flagshipBag = startRenameFlagshipToGeneric(unitBags, prevColor, flagshipName)
        while isEntrySpawning(flagships) do waitAndAutoResume() end
        waitAndAutoResume()

        local putGuids = finishRenameFlagshipToGeneric(flagships, flagshipBag)
        flagships = nil
        flagshipBag = nil
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        local putGuids = packUnitBags(unitBags, prevBag)
        unitBags = nil
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        prevBag.setLock(false)
        self.putObject(prevBag)
        prevBag = nil
        waitAndAutoResume()

        doSimpleRename(ruleToItems)
        waitAndAutoResume()

        local turnState = getTurnState()
        Player[prevColor].changeColor(nextColor)
        waitAndAutoResume()

        setTurnState(turnState, prevColor, nextColor)
        turnState = nil
        waitAndAutoResume()

        local handState, handObjects = getHandState(prevColor, nextColor)

        -- Transfer objects from the old hand to the new.  First move the new
        -- hand to the middle (so deal does not hit another hand on the way),
        -- then deal to change hands.  Moving out of the hand via setPosition
        -- does not work reliably.
        Player[nextColor].setHandTransform({
            position = { x = 0, y = 10, z = 0 },
            scale = { x = 1, y = 1, z = 1 }
        }, 1)
        waitAndAutoResume()
        for i, object in ipairs(handObjects) do
            object.deal(1, nextColor)
            object.setLock(true)
        end
        local function isBusy()
            local player = Player[prevColor]
            for i = 1, player.getHandCount() do
                if #player.getHandObjects(i) > 0 then
                    return true
                end
            end
        end
        while isBusy() do waitAndAutoResume() end
        waitAndAutoResume()

        swapHandState(handState, prevColor, nextColor)
        handState = nil
        waitAndAutoResume()

        -- Move prev hand objects to next hand a second time, in case warping
        -- the hand transform did not take all the contents.  This should also
        -- fix any orientation problems such as cards being upside down.
        for i, object in ipairs(handObjects) do
            object.setLock(false)
            object.deal(1, nextColor)
        end

        local nextBag = getPiecesBag(nextColor, true, {3, 3, 0})
        waitAndAutoResume()
        while nextBag.spawning do waitAndAutoResume() end

        unpackSingletons(ruleToItems, nextBag)
        waitAndAutoResume()

        local deckRuleToDeckObject = unpackDecks(nextColor, ruleToItems, nextBag)
        while isEntrySpawning(deckRuleToDeckObject) do waitAndAutoResume() end
        waitAndAutoResume()

        local spawning = unpackCardsFromDecks(ruleToItems, deckRuleToDeckObject)
        deckRuleToDeckObject = nil
        while isEntrySpawning(spawning) do waitAndAutoResume() end
        waitAndAutoResume()

        local unitRuleToUnitBag = unpackUnitBags(nextColor, ruleToItems, nextBag)
        while isEntrySpawning(unitRuleToUnitBag) do waitAndAutoResume() end
        waitAndAutoResume()

        local flagships, flagshipBag = startRenameFlagshipFromGeneric(unitRuleToUnitBag, flagshipName)
        while isEntrySpawning(flagships) do waitAndAutoResume() end
        waitAndAutoResume()

        local putGuids = finishRenameFlagshipFromGeneric(flagships, flagshipBag)
        flagships = nil
        flagshipBag = nil
        while isGuidActive(putGuids) do waitAndAutoResume() end
        waitAndAutoResume()

        unpackUnitsFromUnitBags(ruleToItems, unitRuleToUnitBag)
        unitRuleToUnitBag = nil
        waitAndAutoResume()

        self.putObject(nextBag)
        print(TAG .. ': finished')

        return 1
    end
    coroutine.resume(coroutine.create(swapCoroutineFunction))
end

-------------------------------------------------------------------------------

--- Find entry in a container.
-- @container: game Object.
-- @name string: object name.
-- @return string: container entry guid (may changer after unpacking!).
function getContainerEntryGuid(container, name)
    assert(container.tag == 'Deck' or container.tag == 'Bag' or container.tag == 'Generic')
    for _, entry in ipairs(container.getObjects()) do
        if entry.name == name then
            return entry.guid
        end
    end
end

--- Get with-color name.
-- @param anonymousName string: string containing $COLOR.
-- @return string: same string substiting actual color.
function applyColorToAnonymousName(anonymousName, color)
    assert(type(anonymousName) == 'string' and type(color) == 'string')
    return string.gsub(anonymousName, '$COLOR', color)
end

--- Get flagship.
-- @param color string.
-- @return string: flagship name.
function getFlagshipName(color)
    CrLua.TI4.Faction.update()
    local faction = CrLua.TI4.Faction.fromColor(color)
    if faction then
        local lowerFactionName = string.lower(faction.name)
        for flagshipName, attributes in pairs(CrLua.TI4.Unit.FLAGSHIP) do
            if string.lower(attributes.faction) == lowerFactionName then
                return flagshipName
            end
        end
    end
end

--- Retrieve or create a bag for color pieces.
function getPiecesBag(color, createIfMissing, offset)
    local name = applyColorToAnonymousName(ANONYMOUS_PIECES_BAG_NAME, color)
    local guid = getContainerEntryGuid(self, name)
    local position = {
        x = self.getPosition().x + (offset.x or offset[1]),
        y = self.getPosition().y + (offset.y or offset[2]),
        z = self.getPosition().z + (offset.z or offset[3])
    }
    local bag = guid and self.takeObject({
        guid = guid,
        position = position
    })
    if not bag and createIfMissing then
        bag = spawnObject({
            type = 'Bag',
            position = position,
            sound = false,
            snap_to_grid = false,
        })
        bag.setName(name)
        bag.use_grid = false
        bag.use_snap_points = false
        bag.sticky = false
    end
    assert(bag)
    bag.setLock(true)
    return bag
end

-------------------------------------------------------------------------------

--- Gather to-be-replaced objects.
-- Build map from "$COLOR" anonymous name to list of items.
-- @param prevColor string (existing color getting replaced).
-- @param nextColor string (new color to be used).
-- @param flagshipName string, may be nil/false to ignore.
-- @return table: map from top-level swap rule to list of items.
function getSwapRuleToItems(prevColor, nextColor, flagshipName)
    assert(type(prevColor) == 'string' and type(nextColor) == 'string')
    assert(not flagshipName or type(flagshipName) == 'string')

    local simpleRules = {}
    simpleRules = CrLua.List.join(simpleRules, SWAP.SINGLETONS)
    simpleRules = CrLua.List.join(simpleRules, SWAP.UNITS)
    simpleRules = CrLua.List.join(simpleRules, SWAP.SIMPLE_RENAME)

    -- Map from object name to swap rule.  For cards, the swap rule is the deck.
    local nameToAnonAndNext = {}
    for _, anonymousName in ipairs(simpleRules) do
        local prevName = applyColorToAnonymousName(anonymousName, prevColor)
        local nextName = applyColorToAnonymousName(anonymousName, nextColor)
        nameToAnonAndNext[prevName] = { anon = anonymousName, next = nextName }
    end
    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        -- Store the deck mostly for unpack position.  Packing only uses
        -- individual cards (stored with the anonymous deck name rule).
        -- Decks may contain non-swap things like faction promissory notes,
        -- other player's notes, etc.
        local prevName = applyColorToAnonymousName(anonymousDeck, prevColor)
        local nextName = applyColorToAnonymousName(anonymousDeck, nextColor)
        nameToAnonAndNext[prevName] = { anon = anonymousDeck, next = nextName }
        for _, anonymousCard in ipairs(anonymousCards) do
            local prevName = applyColorToAnonymousName(anonymousCard, prevColor)
            local nextName = applyColorToAnonymousName(anonymousCard, nextColor)
            nameToAnonAndNext[prevName] = { anon = anonymousCard, next = nextName }
        end
    end
    if flagshipName then
        -- Add a special rule for custom flagship name.
        nameToAnonAndNext[flagshipName] = { anon = ANONYMOUS_FLAGSHIP_NAME, next = flagshipName }
    end

    -- Find items in a single pass.
    local ruleToItems = {}
    local function getRuleToItems(anonAndNext)
        assert(type(anonAndNext) == 'table')
        local items = ruleToItems[anonAndNext.anon]
        if not items then
            items = {}
            ruleToItems[anonAndNext.anon] = items
        end
        return items
    end
    for _, object in ipairs(getAllObjects()) do

        -- Live objects.
        local name = object.getName()
        local anonAndNext = nameToAnonAndNext[name]
        if anonAndNext then
            local items = getRuleToItems(anonAndNext)
            table.insert(items, {
                name = {
                    anon = anonAndNext.anon,
                    prev = name,
                    next = anonAndNext.next,
                },
                live = {
                    object = object,
                    transform = {
                        position = CrLua.Table.copy(object.getPosition()),
                        rotation = CrLua.Table.copy(object.getRotation()),
                        scale = CrLua.Table.copy(object.getScale())
                    },
                    tag = object.tag,
                    value = object.getValue() or false,
                    lock = object.getLock() or false,
                },
                dead = false
            })
        end

        -- "Dead" objects inside a deck.
        if object.tag == 'Deck' then
            for _, entry in ipairs(object.getObjects()) do
                local anonAndNext = nameToAnonAndNext[entry.name]
                if anonAndNext then
                    local items = getRuleToItems(anonAndNext)
                    table.insert(items, {
                        name = {
                            anon = anonAndNext.anon,
                            prev = entry.name,
                            next = anonAndNext.next,
                        },
                        live = false,
                        dead = {
                            guid = entry.guid,
                            container = object,
                            transform = {
                                position = CrLua.Table.copy(object.getPosition()),
                                rotation = CrLua.Table.copy(object.getRotation()),
                                scale = CrLua.Table.copy(object.getScale())
                            }
                        }
                    })
                end
            end
        end
    end

    -- Store false for missing values, then lock table to detect errors
    -- attempting to read missing keys.
    for name, anonAndNext in pairs(nameToAnonAndNext) do
        local rule = anonAndNext.anon
        ruleToItems[rule] = ruleToItems[rule] or false
    end

    -- Lock the table down, prevent attempting to access missing keys.
    -- Do not lock transform, metatables are not compatible with vectors.
    local function lockRecursive(name, t)
        assert(type(t) == 'table')
        for k, v in pairs(t) do
            if type(v) == 'table' and k ~= 'transform' then
                lockRecursive(tostring(k), v)
            end
        end
        CrLua.LockTable.readOnlyRequireKey(name, t)
    end
    lockRecursive('ruleToItems', ruleToItems)

    return ruleToItems
end

--- Make sure all items are found!
function verifyRuleToItems(ruleToItems)
    assert(type(ruleToItems) == 'table')

    for _, anonymousName in ipairs(SWAP.SINGLETONS) do
        local items = ruleToItems[anonymousName]
        if not items then
            error(TAG .. ': missing "' .. anonymousName .. '"')
        end
    end

    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        -- Only look for cards, they were pulled from decks during scan.
        for _, anonymousCard in ipairs(anonymousCards) do
            local items = ruleToItems[anonymousCard]
            if not items then
                error(TAG .. ': missing "' .. anonymousCard .. '"')
            elseif #items > 1 then
                error(TAG .. ': multiple "' .. anonymousCard .. '"')
            end
        end
    end

    for _, anonymousName in ipairs(SWAP.UNITS) do
        local items = ruleToItems[anonymousName]
        local bag = false
        for _, item in ipairs(items or {}) do
            if item.live and item.live.tag == 'Bag' then
                if bag then
                    error(TAG .. ': multiple unit bags "' .. anonymousName .. '"')
                end
                bag = item.live.object
            end
        end
        if not bag then
            error(TAG .. ': missing unit bag "' .. anonymousName .. '"')
        end
    end
    return true
end

-------------------------------------------------------------------------------

function packSingletons(ruleToItems, bag)
    assert(type(ruleToItems) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'packSingletons')

    -- Keep only the first of any singleton objects (players may have cloned extras).
    local putGuids = {}
    for _, anonymousName in ipairs(SWAP.SINGLETONS) do
        local items = ruleToItems[anonymousName]
        for i, item in ipairs(items or {}) do
            assert(item.live.object)
            if i == 1 then
                item.live.object.setLock(false)
                table.insert(putGuids, item.live.object.getGUID())
                bag.putObject(item.live.object)
                CrLua.LockTable.setEvenIfLocked(item.live, 'object', false)
            else
                destroyObject(item.live.object)
                CrLua.LockTable.setEvenIfLocked(item.live, 'object', false)
            end
        end
    end
    return putGuids
end

function retrieveCards(ruleToItems)
    assert(type(ruleToItems) == 'table')
    CrLua.Log.d(TAG, 'retrieveCards')

    local deckRuleToCardObjects = {}

    -- When taking the second last card from a deck, the deck turns into a card.
    local containerToRemainder = {}

    -- Get card objects, taking from decks if necessary.
    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        local cardObjects = deckRuleToCardObjects[anonymousDeck]
        if not cardObjects then
            cardObjects = {}
            deckRuleToCardObjects[anonymousDeck] = cardObjects
        end
        for i, anonymousCard in ipairs(anonymousCards) do
            local items = ruleToItems[anonymousCard]
            assert(not items or #items == 1)
            local item = not items or items[1]
            if item then
                if item.live then
                    assert(item.live.object)
                    table.insert(cardObjects, item.live.object)
                    CrLua.LockTable.setEvenIfLocked(item.live, 'object', false)
                else
                    assert(item.dead)
                    local position = CrLua.Table.copy(item.dead.transform.position)
                    position.y = position.y + 3 + i

                    -- Watch out for taking the last card, when taking the
                    -- second-last, the deck gets transformed into the last.
                    local object = false
                    local remainder = containerToRemainder[item.dead.container]
                    if remainder then
                        assert(remainder.getName() == item.name.prev)
                        object = remainder
                        object.setPosition(position)
                    else
                        object = item.dead.container.takeObject({
                            guid = item.dead.guid,
                            position = position
                        })
                        local remainder = item.dead.container.remainder
                        containerToRemainder[item.dead.container] = remainder
                    end
                    assert(object and object.tag == 'Card')
                    object.setLock(true)
                    table.insert(cardObjects, object)
                end
            end
        end
    end

    return deckRuleToCardObjects
end

function packCardsIntoDecks(deckColor, deckRuleToCardObjects)
    assert(type(deckColor) == 'string' and type(deckRuleToCardObjects) == 'table')
    CrLua.Log.d(TAG, 'packCardsIntoDecks')

    local deckRuleToDeckObject = {}
    local putGuids = {}
    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        local cardObjects = deckRuleToCardObjects[anonymousDeck]
        assert(#cardObjects == #anonymousCards)
        local deck = false
        for i, cardObject in ipairs(cardObjects) do
            assert(cardObject and cardObject.tag == 'Card')
            cardObject.setLock(false)
            table.insert(putGuids, cardObject.getGUID())
            if i == 1 then
                deck = cardObject
            elseif i == 2 then
                deck = deck.putObject(cardObject)
            else
                -- TTS needs a frame to finish creating the deck object.
                -- Put additional cards next frame.
                local function delayedPut()
                    local lock = deck.getLock() or false
                    deck.setLock(false)
                    deck.putObject(cardObject)
                    deck.setLock(lock)
                end
                Wait.frames(delayedPut, 1)
            end
        end
        assert(deck and deck.tag == 'Deck')
        deck.setLock(true)
        deck.setName(applyColorToAnonymousName(anonymousDeck, deckColor))
        deckRuleToDeckObject[anonymousDeck] = deck
    end
    return deckRuleToDeckObject, putGuids
end

function packDecks(deckRuleToDeckObject, bag)
    assert(type(deckRuleToDeckObject) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'packDecks')

    local putGuids = {}
    for anonymousDeck, deckObject in pairs(deckRuleToDeckObject) do
        assert(deckObject.tag == 'Deck')
        deckObject.setLock(false)
        table.insert(putGuids, deckObject.getGUID())
        bag.putObject(deckObject)
    end
    return putGuids
end

function packUnitsIntoUnitBags(ruleToItems)
    assert(type(ruleToItems) == 'table')
    CrLua.Log.d(TAG, 'packUnitsIntoUnitBags')

    local unitBags = {}
    local putGuids = {}
    for _, anonymousName in ipairs(SWAP.UNITS) do
        local items = ruleToItems[anonymousName]

        -- Find bag.
        local unitBag = false
        for _, item in ipairs(items or {}) do
            assert(item.live and item.live.object)
            if item.live.tag == 'Bag' then
                assert(not unitBag)
                unitBag = item.live.object
                CrLua.LockTable.setEvenIfLocked(item.live, 'object', false)
            end
        end
        assert(unitBag)
        table.insert(unitBags, unitBag)

        -- Pack units into unit bag.
        for _, item in ipairs(items or {}) do
            if item.live.tag ~= 'Bag' then
                table.insert(putGuids, item.live.object.getGUID())
                unitBag.putObject(item.live.object)
                CrLua.LockTable.setEvenIfLocked(item.live, 'object', false)
            end
        end
    end
    return unitBags, putGuids
end

function startRenameFlagshipToGeneric(unitBags, color, flagshipName)
    assert(type(unitBags) == 'table' and type(color) == 'string')
    assert(not flagshipName or type(flagshipName) == 'string')
    CrLua.Log.d(TAG, 'startRenameFlagshipToGeneric')

    local genericName = applyColorToAnonymousName(ANONYMOUS_FLAGSHIP_NAME, color)

    local function getFlagshipBag()
        for _, unitBag in ipairs(unitBags) do
            if unitBag.getName() == flagshipName then
                return unitBag
            end
        end
    end

    local flagshipBag = getFlagshipBag()
    local flagships = {}
    if flagshipName then
        flagshipBag.setName(genericName)
        while flagshipBag.getQuantity() > 0 do
            local position = CrLua.Table.copy(flagshipBag.getPosition())
            position.y = position.y + 3 + flagshipBag.getQuantity()
            local flagship = flagshipBag.takeObject({
                position = position
            })
            flagship.setName(genericName)
            flagship.setLock(true)
            table.insert(flagships, flagship)
        end
    end
    assert(not flagshipName or #flagships > 0)
    return flagships, flagshipBag
end

function finishRenameFlagshipToGeneric(flagships, flagshipBag)
    assert(type(flagships) == 'table' and not flagshipBag or type(flagshipBag) == 'userdata')
    CrLua.Log.d(TAG, 'finishRenameFlagshipToGeneric')

    local putGuids = {}
    if flagshipBag then
        assert(flagshipBag.tag == 'Bag')
        for _, flagship in ipairs(flagships) do
            flagship.setLock(false)
            table.insert(putGuids, flagship.getGUID())
            flagshipBag.putObject(flagship)
        end
    end
    return putGuids
end

function packUnitBags(unitBags, bag)
    assert(type(unitBags) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'packUnitBags')

    local putGuids = {}
    for _, unitBag in ipairs(unitBags) do
        assert(unitBag.tag == 'Bag')
        unitBag.setLock(false)
        table.insert(putGuids, unitBag.getGUID())
        bag.putObject(unitBag)
    end
    return putGuids
end

-------------------------------------------------------------------------------

function doSimpleRename(ruleToItems)
    assert(type(ruleToItems) == 'table')
    CrLua.Log.d(TAG, 'doSimpleRename')

    for _, anonymousName in ipairs(SWAP.SIMPLE_RENAME) do
        local items = ruleToItems[anonymousName]
        for i, item in ipairs(items or {}) do
            assert(item.live and item.live.object)
            item.live.object.setName(item.name.next)
        end
    end
end

-------------------------------------------------------------------------------

function getTurnState()
    CrLua.Log.d(TAG, 'getTurnState')

    return {
        enable = Turns.enable,
        order = CrLua.Table.copy(Turns.order),
        current = Turns.turn_color
    }
end

function setTurnState(state, prevColor, nextColor)
    assert(type(state) == 'table' and type(prevColor) == 'string' and type(nextColor) == 'string')
    CrLua.Log.d(TAG, 'setTurnState')

    for i, color in ipairs(state.order) do
        if color == prevColor then
            state.order[i] = nextColor
        end
    end
    if state.current == prevColor then
        state.current = nextColor
    end

    Turns.order = state.order
    Turns.turn_color = state.current
    Turns.enable = state.enable
end

-------------------------------------------------------------------------------

function getHandState(prevColor, nextColor)
    assert(type(prevColor) == 'string' and type(nextColor) == 'string')
    CrLua.Log.d(TAG, 'getHandState')

    local function getHandTransforms(player)
        local handTransforms = {}
        for i = 1, player.getHandCount() do
            table.insert(handTransforms, CrLua.Table.copy(player.getHandTransform(i)))
        end
        return handTransforms
    end
    local function getHandObjects(player)
        local handObjects = {}
        for i = 1, player.getHandCount() do
            for _, object in ipairs(player.getHandObjects(i)) do
                table.insert(handObjects, object)
            end
        end
        return handObjects
    end

    local prevPlayer = Player[prevColor]
    local nextPlayer = Player[nextColor]

    return {
        prev = {
            handTransforms = getHandTransforms(prevPlayer),
        },
        next = {
            handTransforms = getHandTransforms(nextPlayer)
        }
    }, getHandObjects(prevPlayer)
end

function swapHandState(state, prevColor, nextColor)
    assert(type(state) == 'table')
    CrLua.Log.d(TAG, 'swapHandState')

    local function setHandTransforms(player, handTransforms)
        for i, handTransform in ipairs(handTransforms) do
            player.setHandTransform(handTransform, i)
        end
    end

    local prevPlayer = Player[prevColor]
    local nextPlayer = Player[nextColor]

    setHandTransforms(prevPlayer, state.next.handTransforms)
    setHandTransforms(nextPlayer, state.prev.handTransforms)
end

-------------------------------------------------------------------------------

function _unpackLive(container, item, color)
    assert(item.live)
    local name = color and applyColorToAnonymousName(item.name.anon, color) or item.name.next
    local guid = getContainerEntryGuid(container, name)
    local object = guid and container.takeObject({
        guid = guid,
        position = item.live.transform.position,
        rotation = item.live.transform.rotation,
    })
    if object then
        object.setScale(item.live.transform.scale)
        if item.live.lock then
            object.setLock(item.live.lock)
        end
        if item.live.value then
            object.setValue(item.live.value)
        end
    end
    return object
end

function unpackSingletons(ruleToItems, bag)
    assert(type(ruleToItems) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'unpackSingletons')

    for _, anonymousName in ipairs(SWAP.SINGLETONS) do
        local items = ruleToItems[anonymousName]
        local object = false
        for i, item in ipairs(items or {}) do
            assert(item.live)
            if i == 1 then
                object = assert(_unpackLive(bag, item))
            else
                local clone = object.clone({
                    position = item.live.transform.position
                })
                clone.setRotation(item.live.transform.rotation)
                clone.setScale(item.live.transform.scale)
                if item.live.lock then
                    clone.setLock(item.live.lock)
                end
                if item.live.value then
                    clone.setValue(item.live.value)
                end
            end
        end
    end
end

function unpackDecks(nextColor, ruleToItems, bag)
    assert(type(ruleToItems) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'unpackDecks')

    local deckRuleToDeckObject = {}

    local i = 0
    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        local deck = false
        local deckItems = ruleToItems[anonymousDeck]
        if deckItems then
            assert(#deckItems == 1)
            local deckItem = deckItems[1]
            assert(deckItem.live and deckItem.live.tag == 'Deck')
            deck = assert(_unpackLive(bag, deckItem))
        else
            local position = CrLua.Table.copy(bag.getPosition())
            position.y = position.y + 3 + i
            i = i + 1
            local deckName = applyColorToAnonymousName(anonymousDeck, nextColor)
            local guid = assert(getContainerEntryGuid(bag, deckName))
            deck = bag.takeObject({
                guid = guid,
                position = position
            })
        end
        assert(deck and deck.tag == 'Deck')
        deckRuleToDeckObject[anonymousDeck] = deck
    end

    return deckRuleToDeckObject
end

function unpackCardsFromDecks(ruleToItems, deckRuleToDeckObject)
    assert(type(ruleToItems) == 'table' and type(deckRuleToDeckObject) == 'table')
    CrLua.Log.d(TAG, 'unpackCardsFromDecks')

    local spawning = {}
    for anonymousDeck, anonymousCards in pairs(SWAP.DECKS) do
        local deck = assert(deckRuleToDeckObject[anonymousDeck])
        local remainder = false
        for _, anonymousCard in ipairs(anonymousCards) do
            local items = ruleToItems[anonymousCard]
            assert(items and #items == 1)
            local item = items[1]

            if item.live then
                if remainder then
                    assert(remainder.tag == 'Card')
                    assert(remainder.getName() == item.name.next)
                    remainder.setPosition(item.live.transform.position)
                    remainder.setRotation(item.live.transform.rotation)
                    remainder.setScale(item.live.transform.scale)
                    remainder.setLock(item.live.lock)
                else
                    local object = assert(_unpackLive(deck, item))
                    table.insert(spawning, object)
                    remainder = deck.remainder
                end
            end
        end
    end
    return spawning
end

function unpackUnitBags(nextColor, ruleToItems, bag)
    assert(type(nextColor) == 'string' and type(ruleToItems) == 'table' and type(bag) == 'userdata')
    CrLua.Log.d(TAG, 'unpackUnitBags')

    local unitRuleToUnitBag = {}

    for _, anonymousName in ipairs(SWAP.UNITS) do
        local items = ruleToItems[anonymousName]
        local unitBagItem = false
        for _, item in ipairs(items) do
            if item.live and item.live.tag == 'Bag' then
                assert(not unitBagItem)
                unitBagItem = item
            end
        end
        assert(unitBagItem)
        local unitBag = assert(_unpackLive(bag, unitBagItem, nextColor))
        unitRuleToUnitBag[anonymousName] = unitBag
    end

    return unitRuleToUnitBag
end

function startRenameFlagshipFromGeneric(unitRuleToUnitBag, flagshipName)
    assert(type(unitRuleToUnitBag) == 'table' and not flagshipName or type(flagshipName) == 'string')
    assert(not flagshipName or type(flagshipName) == 'string')
    CrLua.Log.d(TAG, 'startRenameFlagshipFromGeneric')

    local flagshipBag = assert(unitRuleToUnitBag[ANONYMOUS_FLAGSHIP_NAME])

    local flagships = {}
    if flagshipName then
        flagshipBag.setName(flagshipName)
        while flagshipBag.getQuantity() > 0 do
            local position = CrLua.Table.copy(flagshipBag.getPosition())
            position.y = position.y + 3 + flagshipBag.getQuantity()
            local flagship = flagshipBag.takeObject({
                position = position
            })
            flagship.setName(flagshipName)
            flagship.setLock(true)
            table.insert(flagships, flagship)
        end
    end
    assert(not flagshipName or #flagships > 0)
    return flagships, flagshipBag
end

function finishRenameFlagshipFromGeneric(flagships, flagshipBag)
    assert(type(flagships) == 'table' and not flagshipBag or type(flagshipBag) == 'userdata')
    CrLua.Log.d(TAG, 'finishRenameFlagshipFromGeneric')

    local putGuids = {}
    if flagshipBag then
        assert(flagshipBag.tag == 'Bag')
        for _, flagship in ipairs(flagships) do
            flagship.setLock(false)
            table.insert(putGuids, flagship.getGUID())
            flagshipBag.putObject(flagship)
        end
    end
    return putGuids
end

function unpackUnitsFromUnitBags(ruleToItems, unitRuleToUnitBag)
    assert(type(ruleToItems) == 'table' and type(unitRuleToUnitBag) == 'table')
    CrLua.Log.d(TAG, 'unpackUnitsFromUnitBags')

    for _, anonymousName in ipairs(SWAP.UNITS) do
        local items = ruleToItems[anonymousName]
        local unitBag = assert(unitRuleToUnitBag[anonymousName])
        for _, item in ipairs(items) do
            if item.live and item.live.tag ~= 'Bag' then
                assert(_unpackLive(unitBag, item))
            end
        end
    end
end

-------------------------------------------------------------------------------

#include <~/CrLua/CrLua>
#include <~/CrLua/LockGlobals>

#include <~/CrLua/List>
#include <~/CrLua/LockTable>
#include <~/CrLua/Log>
#include <~/CrLua/Table>
#include <~/CrLua/Util>

#include <~/CrLua/TI4/Faction>
#include <~/CrLua/TI4/Unit>

CrLua.assertRequired({ 'Log', 'TI4.Unit' })
CrLua.lock()

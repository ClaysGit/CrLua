--- Reset command and owner tokens to use ThatRobHuman's new mesh / UV map.
-- @author darrell

function getHelperClient(helperObjectName)
    local function getHelperObject()
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == helperObjectName then return object end
        end
        error('missing object "' .. helperObjectName .. '"')
    end
    local helperObject = false
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')

local IMAGE = {
    ['Arborec'] = 'Arborec',
    ['Barony of Letnev'] = 'Letnev',
    ['Clan of Saar'] = 'Saar',
    ['Embers of Muaat'] = 'Muaat',
    ['Emirates of Hacan'] = 'Hacan',
    ['Federation of Sol'] = 'Sol',
    ['Ghosts of Creuss'] = 'Creuss',
    ['L1Z1X Mindnet'] = 'L1Z1X',
    ['Mentak Coalition'] = 'Mentak',
    ['Naalu Collective'] = 'Naalu',
    ['Nekro Virus'] = 'Nekro',
    ["Sardakk N'orr"] = 'Sardakk',
    ['Universities of Jol-Nar'] = 'JolNar',
    ['Winnu'] = 'Winnu',
    ['Xxcha Kingdom'] = 'Xxcha',
    ['Yin Brotherhood'] = 'Yin',
    ['Yssaril Tribes'] = 'Yssaril',
}

local COMMAND_TOKEN = {
    SCALE = { x = 1.35, y = 1, z = 1.35 },
    MODEL = 'file:////Users/darrell/Downloads/tokens/command-semitintable.obj',
    COLLIDER = 'file:////Users/darrell/Downloads/tokens/command-tintable.obj',
    IMAGE_PREFIX = 'file:////Users/darrell/Downloads/x3n_CCs/x3n_CC_',
    IMAGE_SUFFIX = '.jpg',
}

local OWNER_TOKEN = {
    SCALE = { x = 1.4, y = 1, z = 1.4 },
    MODEL = 'file:////Users/darrell/Downloads/tokens/owner-semitintable.obj',
    COLLIDER = 'file:////Users/darrell/Downloads/tokens/owner-tintable.obj',
    IMAGE_PREFIX = 'file:////Users/darrell/Downloads/x3n_CCs/x3n_CC_',
    IMAGE_SUFFIX = '.jpg',
}

local _tileGuidToContainers = false
local _deletedItems = false
local _deletePendingSet = {}

-------------------------------------------------------------------------------

function onLoad(save_state)
    _deletedItems = getObjectByName('Bag', 'TI4 Deleted Items')
    self.addContextMenuItem('Mutate', mutate)
end

function onObjectDestroy(dyingObject)
    _deletePendingSet[dyingObject.getGUID()] = nil
end

function getObjectByName(tag, name)
    for _, object in ipairs(getAllObjects()) do
        if object.tag == tag and object.getName() == name then
            return object
        end
    end
end

-------------------------------------------------------------------------------

function mutate()
    startLuaCoroutine(self, 'mutateCoroutine')
end

local function mutateJson(json, image, rule)
    assert(type(json) == 'string' and type(image) == 'string' and type(rule) == 'table')
    json = JSON.decode(json)

    json.Transform.scaleX = rule.SCALE.x
    json.Transform.scaleY = rule.SCALE.y
    json.Transform.scaleZ = rule.SCALE.z

    json.CustomMesh.MeshURL = rule.MODEL
    json.CustomMesh.ColliderURL = rule.COLLIDER
    json.CustomMesh.DiffuseURL = rule.IMAGE_PREFIX .. image .. rule.IMAGE_SUFFIX

    return JSON.encode_pretty(json)
end

local function mutateObject(object, image, rule, isFirst)
    assert(type(object) == 'userdata' and type(image) == 'string' and type(rule) == 'table')
    print('mutating ' .. object.getName())

    local guid = object.getGUID()
    local json = object.getJSON()
    local originalLock = object.getLock() or false

    json = mutateJson(json, image, rule)
    local spawnParams = {
        json              = json,
        position          = object.getPosition(),
        rotation          = object.getRotation(),
        scale             = rule.SCALE,
        callback_function = nil,
        sound             = false,
        params            = nil,
        snap_to_grid      = object.use_grid
    }

    -- Delete object, wait for delete to actually happen before reusing guid!
    if _deletedItems then
        _deletedItems.call('ignoreGuid', guid)
    end
    _deletePendingSet[guid] = true
    destroyObject(object)
    object = nil
    while _deletePendingSet[guid] do
        coroutine.yield(0)
    end
    coroutine.yield(0)
    coroutine.yield(0)
    coroutine.yield(0)

    local object = spawnObjectJSON(spawnParams)
    assert(object.getGUID() == guid)

    -- Wait for spawn, plus extra time for texture to load.
    object.setLock(true)
    while object.spawning do
        coroutine.yield(0)
    end
    local waitUntil = Time.time + (isFirst and 3 or 0.2)
    while Time.time < waitUntil do
        coroutine.yield(0)
    end
    object.setLock(originalLock)

    return object
end

function mutateCoroutine()

    local function takeByName(bag, name)
        local p = bag.getPosition()
        for _, entry in ipairs(bag.getObjects()) do
            if entry.name == name then
                return bag.takeObject({
                    guid = entry.guid,
                    position = { x = p.x, y = p.y + 5, z = p.z },
                    smooth = false
                })
            end
        end
        error('missing ' .. bag.getName() .. '/' .. name)
    end

    local factionsBox = assert(getObjectByName('Bag', 'Factions'))
    local p = factionsBox.getPosition()
    for _, entry in ipairs(factionsBox.getObjects()) do
        local tokenName = string.match(entry.name, '^(.*) Box$')
        local image = tokenName and IMAGE[tokenName]
        if image then
            local box = factionsBox.takeObject({
                guid = entry.guid,
                position = { x = p.x, y = p.y + 5, z = p.z },
                smooth = false
            })
            box.setLock(true)
            coroutine.yield(0)
            coroutine.yield(0)

            ---------------------------

            local commandTokens = takeByName(box, tokenName .. ' Command Tokens Bag')
            assert(commandTokens.tag == 'Bag')
            commandTokens.setLock(true)
            coroutine.yield(0)
            coroutine.yield(0)

            for i, tokenEntry in ipairs(commandTokens.getObjects()) do
                local token = commandTokens.takeObject({
                    guid = tokenEntry.guid,
                    position = { x = p.x, y = p.y + 15, z = p.z },
                    smooth = false
                })
                token.setLock(true)
                coroutine.yield(0)
                coroutine.yield(0)

                token = mutateObject(token, image, COMMAND_TOKEN, i == 1)
                coroutine.yield(0)
                coroutine.yield(0)

                token.setLock(false)
                commandTokens.putObject(token)
                coroutine.yield(0)
                coroutine.yield(0)
            end

            commandTokens.setLock(false)
            box.putObject(commandTokens)
            coroutine.yield(0)
            coroutine.yield(0)

            ---------------------------

            local ownerTokens = takeByName(box, tokenName .. ' Owner Tokens Bag')
            assert(ownerTokens.tag == 'Infinite')
            ownerTokens.setLock(true)
            coroutine.yield(0)
            coroutine.yield(0)

            local token = ownerTokens.takeObject({
                position = { x = p.x, y = p.y + 15, z = p.z },
                smooth = false
            })
            token.setLock(true)
            coroutine.yield(0)
            coroutine.yield(0)

            token = mutateObject(token, image, OWNER_TOKEN, true)
            coroutine.yield(0)
            coroutine.yield(0)

            ownerTokens.reset()
            coroutine.yield(0)
            coroutine.yield(0)

            token.setLock(false)
            ownerTokens.putObject(token)
            coroutine.yield(0)
            coroutine.yield(0)

            ownerTokens.setLock(false)
            box.putObject(ownerTokens)
            coroutine.yield(0)
            coroutine.yield(0)

            ---------------------------

            box.setLock(false)
            factionsBox.putObject(box)
            coroutine.yield(0)
            coroutine.yield(0)
        end
    end

    print('done!')
    return 1
end

-------------------------------------------------------------------------------
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)
